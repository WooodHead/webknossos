webpackJsonp([1],Array(63).concat([
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_, $) {var ActionBarView, BackboneToOxalisAdapterModel, Constants, Marionette, Modal, OxalisController, OxalisModel, SkeletonArbitraryTabView, SkeletonPlaneTabView, SkeletonTracingRightMenuView, TracingLayoutView, TracingView, UserScriptsModalView, ViewmodeRightMenuView, ViewmodeTabView, VolumeTabView, VolumeTracingRightMenuView, app,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Marionette = __webpack_require__(49);
	
	app = __webpack_require__(48);
	
	ActionBarView = __webpack_require__(64);
	
	SkeletonPlaneTabView = __webpack_require__(194);
	
	SkeletonArbitraryTabView = __webpack_require__(223);
	
	VolumeTabView = __webpack_require__(226);
	
	ViewmodeTabView = __webpack_require__(229);
	
	SkeletonTracingRightMenuView = __webpack_require__(231);
	
	VolumeTracingRightMenuView = __webpack_require__(256);
	
	ViewmodeRightMenuView = __webpack_require__(258);
	
	UserScriptsModalView = __webpack_require__(259);
	
	TracingView = __webpack_require__(260);
	
	OxalisController = __webpack_require__(261);
	
	OxalisModel = __webpack_require__(266);
	
	Constants = __webpack_require__(61);
	
	BackboneToOxalisAdapterModel = __webpack_require__(222);
	
	Modal = __webpack_require__(307);
	
	TracingLayoutView = (function(superClass) {
	  extend(TracingLayoutView, superClass);
	
	  function TracingLayoutView() {
	    this.showUserScriptsModal = bind(this.showUserScriptsModal, this);
	    return TracingLayoutView.__super__.constructor.apply(this, arguments);
	  }
	
	  TracingLayoutView.prototype.MARGIN = 40;
	
	  TracingLayoutView.prototype.className = "text-nowrap";
	
	  TracingLayoutView.prototype.traceTemplate = _.template("<div id=\"action-bar\"></div>\n<div id=\"sliding-canvas\">\n  <div id=\"settings-menu-wrapper\" class=\"navmenu-fixed-left offcanvas\">\n    <div id=\"settings-menu\"></div>\n  </div>\n  <div id=\"tracing\"></div>\n  <div id=\"right-menu\"></div>\n</div>\n<div class=\"modal-wrapper\"></div>");
	
	  TracingLayoutView.prototype.viewTemplate = _.template("<div id=\"action-bar\"></div>\n<div id=\"settings-menu\"></div>\n<div id=\"tracing\"></div>\n<div id=\"right-menu\"></div>\n<div class=\"modal-wrapper\"></div>");
	
	  TracingLayoutView.prototype.getTemplate = function() {
	    if (this.isTracingMode()) {
	      return this.traceTemplate;
	    } else {
	      return this.viewTemplate;
	    }
	  };
	
	  TracingLayoutView.prototype.ui = {
	    "rightMenu": "#right-menu",
	    "slidingCanvas": "#sliding-canvas"
	  };
	
	  TracingLayoutView.prototype.regions = {
	    "actionBar": "#action-bar",
	    "rightMenu": "#right-menu",
	    "tracingContainer": "#tracing",
	    "settings": "#settings-menu",
	    "modalWrapper": ".modal-wrapper"
	  };
	
	  TracingLayoutView.prototype.events = {
	    "hidden.bs.offcanvas #settings-menu-wrapper": "doneSliding",
	    "shown.bs.offcanvas #settings-menu-wrapper": "doneSliding"
	  };
	
	  TracingLayoutView.prototype.initialize = function(options) {
	    this.options = _.extend({}, options, {
	      model: new OxalisModel(options)
	    });
	    this.model = this.options.model;
	    this.options.adapterModel = new BackboneToOxalisAdapterModel(this.model);
	    this.listenTo(this, "render", this.afterRender);
	    this.listenTo(app.vent, "planes:resize", this.resizeRightMenu);
	    this.listenTo(this.model, "change:mode", this.renderSettings);
	    this.listenTo(this.model, "sync", this.renderRegions);
	    $(window).on("resize", this.resizeRightMenu.bind(this));
	    $("#add-script-link").removeClass("hide").on("click", this.showUserScriptsModal);
	    return app.oxalis = new OxalisController(this.options);
	  };
	
	  TracingLayoutView.prototype.doneSliding = function(evt) {
	    return this.resizeRightMenu();
	  };
	
	  TracingLayoutView.prototype.resizeRightMenu = function() {
	    var menuPosition, newWidth, slidingCanvasOffset;
	    if (this.isSkeletonMode()) {
	      menuPosition = this.ui.rightMenu.position();
	      slidingCanvasOffset = this.ui.slidingCanvas.position().left;
	      newWidth = window.innerWidth - menuPosition.left - slidingCanvasOffset - this.MARGIN;
	      if (menuPosition.left < window.innerWidth && newWidth > 350) {
	        return this.ui.rightMenu.width(newWidth);
	      }
	    }
	  };
	
	  TracingLayoutView.prototype.renderRegions = function() {
	    var actionBarView, tracingView;
	    this.render();
	    actionBarView = new ActionBarView(this.options);
	    tracingView = new TracingView(this.options);
	    this.tracingContainer.show(tracingView, {
	      preventDestroy: true
	    });
	    if (!this.model.settings.advancedOptionsAllowed) {
	      return;
	    }
	    this.actionBar.show(actionBarView, {
	      preventDestroy: true
	    });
	    if (this.isSkeletonMode()) {
	      this.rightMenuView = new SkeletonTracingRightMenuView(this.options);
	    } else if (this.isVolumeMode()) {
	      this.rightMenuView = new VolumeTracingRightMenuView(this.options);
	    } else {
	      this.rightMenuView = new ViewmodeRightMenuView(this.options);
	    }
	    this.rightMenu.show(this.rightMenuView);
	    this.renderSettings();
	    return this.maybeShowNewTaskTypeModal();
	  };
	
	  TracingLayoutView.prototype.showUserScriptsModal = function(event) {
	    var modalView;
	    event.preventDefault();
	    modalView = new UserScriptsModalView();
	    this.modalWrapper.show(modalView);
	    return modalView.show();
	  };
	
	  TracingLayoutView.prototype.maybeShowNewTaskTypeModal = function() {
	    var taskType, text, title;
	    if (window.location.search.indexOf("differentTaskType") < 0 || (this.model.tracing.task == null)) {
	      return;
	    }
	    taskType = this.model.tracing.task.type;
	    title = "Attention, new Task Type: " + taskType.summary;
	    if (taskType.description) {
	      text = "You are now tracing a new task with the following description:<br>" + taskType.description;
	    } else {
	      text = "You are now tracing a new task with no description.";
	    }
	    return Modal.show(text, title);
	  };
	
	  TracingLayoutView.prototype.renderSettings = function() {
	    var settingsTabClass, settingsTabView;
	    if (!this.model.initialized) {
	      return;
	    }
	    if (this.isSkeletonMode()) {
	      settingsTabClass = this.isArbitraryMode() ? SkeletonArbitraryTabView : SkeletonPlaneTabView;
	      settingsTabView = new settingsTabClass(this.options);
	    } else if (this.isVolumeMode()) {
	      settingsTabView = new VolumeTabView(this.options);
	    } else {
	      settingsTabView = new ViewmodeTabView(this.options);
	    }
	    return this.settings.show(settingsTabView);
	  };
	
	  TracingLayoutView.prototype.isTracingMode = function() {
	    return this.model.get("controlMode") !== Constants.CONTROL_MODE_VIEW;
	  };
	
	  TracingLayoutView.prototype.isSkeletonMode = function() {
	    var ref;
	    return (ref = this.model.get("mode"), indexOf.call(Constants.MODES_SKELETON, ref) >= 0) && this.isTracingMode();
	  };
	
	  TracingLayoutView.prototype.isVolumeMode = function() {
	    return this.model.get("mode") === Constants.MODE_VOLUME && this.isTracingMode();
	  };
	
	  TracingLayoutView.prototype.isArbitraryMode = function() {
	    var ref;
	    return ref = this.model.get("mode"), indexOf.call(Constants.MODES_ARBITRARY, ref) >= 0;
	  };
	
	  TracingLayoutView.prototype.onDestroy = function() {
	    $("#add-script-link").addClass("hide").off("click");
	    return app.oxalis = null;
	  };
	
	  return TracingLayoutView;
	
	})(Marionette.LayoutView);
	
	module.exports = TracingLayoutView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(1)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var ActionBarView, Constants, DatasetActionsView, DatasetPositionView, Marionette, SkeletonActionsView, ViewModesView, VolumeActionsView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	DatasetActionsView = __webpack_require__(65);
	
	DatasetPositionView = __webpack_require__(187);
	
	ViewModesView = __webpack_require__(191);
	
	VolumeActionsView = __webpack_require__(192);
	
	SkeletonActionsView = __webpack_require__(193);
	
	Constants = __webpack_require__(61);
	
	ActionBarView = (function(superClass) {
	  extend(ActionBarView, superClass);
	
	  function ActionBarView() {
	    return ActionBarView.__super__.constructor.apply(this, arguments);
	  }
	
	  ActionBarView.prototype.className = "container-fluid";
	
	  ActionBarView.prototype.template = _.template("\n<% if (isTraceMode) { %>\n  <a href=\"#\" id=\"menu-toggle-button\" class=\"btn btn-default\"\n    data-toggle=\"offcanvas\"\n    data-target=\"#settings-menu-wrapper\"\n    data-canvas=\"#sliding-canvas\"\n    data-placement=\"left\"\n    data-autohide=\"false\"\n    data-disable-scrolling=\"false\"><i class=\"fa fa-bars\"></i>Menu</a>\n<% } %>\n\n<% if (isTraceMode) { %>\n  <div id=\"dataset-actions\"></div>\n<% } %>\n\n<div id=\"dataset-position\"></div>\n\n<% if (isVolumeMode) { %>\n  <div id=\"volume-actions\"></div>\n<% } %>\n\n<% if (isTraceMode) { %>\n  <div id=\"view-modes\"></div>\n  <div id=\"skeleton-actions\"></div>\n<% } %>");
	
	  ActionBarView.prototype.templateHelpers = function() {
	    return {
	      isTraceMode: this.isTraceMode(),
	      isVolumeMode: this.isVolumeMode()
	    };
	  };
	
	  ActionBarView.prototype.regions = {
	    "datasetActionButtons": "#dataset-actions",
	    "datasetPosition": "#dataset-position",
	    "viewModes": "#view-modes",
	    "volumeActions": "#volume-actions",
	    "skeletonActions": "#skeleton-actions"
	  };
	
	  ActionBarView.prototype.initialize = function(options) {
	    this.datasetPositionView = new DatasetPositionView(options);
	    if (this.isTraceMode()) {
	      this.datasetActionsView = new DatasetActionsView(options);
	      if (this.isVolumeMode()) {
	        this.volumeActionsView = new VolumeActionsView(options);
	      } else {
	        this.viewModesView = new ViewModesView(options);
	        this.skeletonActionsView = new SkeletonActionsView(options);
	      }
	    }
	    return this.listenTo(this, "render", this.afterRender);
	  };
	
	  ActionBarView.prototype.afterRender = function() {
	    this.datasetPosition.show(this.datasetPositionView);
	    if (this.isTraceMode()) {
	      this.datasetActionButtons.show(this.datasetActionsView);
	      if (this.isVolumeMode()) {
	        return this.volumeActions.show(this.volumeActionsView);
	      } else {
	        this.viewModes.show(this.viewModesView);
	        return this.skeletonActions.show(this.skeletonActionsView);
	      }
	    }
	  };
	
	  ActionBarView.prototype.isTraceMode = function() {
	    return this.model.get("controlMode") === Constants.CONTROL_MODE_TRACE;
	  };
	
	  ActionBarView.prototype.isVolumeMode = function() {
	    return this.model.get("mode") === Constants.MODE_VOLUME;
	  };
	
	  return ActionBarView;
	
	})(Marionette.LayoutView);
	
	module.exports = ActionBarView;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var Constants, DatasetActionsView, Marionette, MergeModalView, Request, ShareModalView, Toast, _, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	app = __webpack_require__(48);
	
	Toast = __webpack_require__(18);
	
	Request = __webpack_require__(17);
	
	MergeModalView = __webpack_require__(66);
	
	ShareModalView = __webpack_require__(184);
	
	Constants = __webpack_require__(61);
	
	DatasetActionsView = (function(superClass) {
	  extend(DatasetActionsView, superClass);
	
	  function DatasetActionsView() {
	    return DatasetActionsView.__super__.constructor.apply(this, arguments);
	  }
	
	  DatasetActionsView.prototype.template = _.template("<% if(tracing.restrictions.allowUpdate){ %>\n  <a href=\"#\" class=\"btn btn-primary\" id=\"trace-save-button\">Save</a>\n<% } else { %>\n  <button class=\"btn btn-primary disabled\">Read only</button>\n<% } %>\n<div class=\"btn-group btn-group\">\n  <% if(tracing.restrictions.allowFinish) { %>\n    <a href=\"/annotations/<%- tracingType %>/<%- tracingId %>/finishAndRedirect\" class=\"btn btn-default\" id=\"trace-finish-button\"><i class=\"fa fa-check-circle-o\"></i>Archive</a>\n  <% } %>\n  <% if(tracing.restrictions.allowDownload || ! tracing.downloadUrl) { %>\n    <a class=\"btn btn-default\" id=\"trace-download-button\"><i class=\"fa fa-download\"></i>Download</a>\n  <% } %>\n  <button class=\"btn btn-default\" id=\"trace-share-button\"><i class=\"fa fa-share-alt\"></i>Share</button>\n</div>\n\n<% if(tracing.restrictions.allowFinish && tracing.task) { %>\n    <button class=\"btn btn-default\" id=\"trace-next-task-button\"><i class=\"fa fa-step-forward\"></i>Finish and Get Next Task</button>\n<% } %>\n\n<% if (isSkeletonMode) { %>\n  <div class=\"btn btn-default\" id=\"trace-merge-button\"><i class=\"fa fa-folder-open\"></i>Merge Tracing</div>\n  <div class=\"merge-modal-wrapper\"></div>\n<% } %>");
	
	  DatasetActionsView.prototype.templateHelpers = function() {
	    return {
	      isSkeletonMode: this.isSkeletonMode()
	    };
	  };
	
	  DatasetActionsView.prototype.events = {
	    "click #trace-finish-button": "finishTracing",
	    "click #trace-download-button": "downloadTracing",
	    "click #trace-save-button": "saveTracing",
	    "click #trace-merge-button": "mergeTracing",
	    "click #trace-share-button": "shareTracing",
	    "click #trace-next-task-button": "getNextTask"
	  };
	
	  DatasetActionsView.prototype.ui = {
	    "modalWrapper": ".merge-modal-wrapper"
	  };
	
	  DatasetActionsView.prototype.finishTracing = function(evt) {
	    evt.preventDefault();
	    return this.saveTracing().then((function(_this) {
	      return function() {
	        if (confirm("Are you sure you want to permanently finish this tracing?")) {
	          return app.router.loadURL(evt.currentTarget.href);
	        }
	      };
	    })(this));
	  };
	
	  DatasetActionsView.prototype.downloadTracing = function(evt) {
	    evt.preventDefault();
	    return this.saveTracing().then((function(_this) {
	      return function() {
	        return window.open(_this.model.tracing.downloadUrl, "_blank");
	      };
	    })(this));
	  };
	
	  DatasetActionsView.prototype.saveTracing = function(evt) {
	    if (evt) {
	      evt.preventDefault();
	    }
	    return this.model.save();
	  };
	
	  DatasetActionsView.prototype.mergeTracing = function() {
	    var modalView;
	    modalView = new MergeModalView({
	      model: this.model
	    });
	    this.ui.modalWrapper.html(modalView.render().el);
	    return modalView.show();
	  };
	
	  DatasetActionsView.prototype.shareTracing = function() {
	    var modalView, model;
	    model = this.model.skeletonTracing || this.model.volumeTracing;
	    model.stateLogger.save();
	    modalView = new ShareModalView({
	      model: this.model
	    });
	    this.ui.modalWrapper.html(modalView.render().el);
	    return modalView.show();
	  };
	
	  DatasetActionsView.prototype.isSkeletonMode = function() {
	    return _.contains(Constants.MODES_SKELETON, this.model.get("mode"));
	  };
	
	  DatasetActionsView.prototype.getNextTask = function() {
	    var tracingType;
	    tracingType = this.model.skeletonTracing || this.model.volumeTracing;
	    return tracingType.stateLogger.save().then((function(_this) {
	      return function() {
	        return Request.$(Request.triggerRequest("/annotations/" + _this.model.tracingType + "/" + _this.model.tracingId + "/finish"));
	      };
	    })(this)).then((function(_this) {
	      return function() {
	        return Request.$(Request.receiveJSON("/user/tasks/request")).then(function(annotation) {
	          var differentTaskType, differentTaskTypeParam, ref;
	          differentTaskType = annotation.task.type.id !== ((ref = _this.model.tracing.task) != null ? ref.type.id : void 0);
	          differentTaskTypeParam = differentTaskType ? "?differentTaskType" : "";
	          return app.router.loadURL("/annotations/" + annotation.typ + "/" + annotation.id + differentTaskTypeParam);
	        }, function() {
	          return setTimeout((function() {
	            return app.router.loadURL("/dashboard");
	          }), 2000);
	        });
	      };
	    })(this));
	  };
	
	  return DatasetActionsView;
	
	})(Marionette.ItemView);
	
	module.exports = DatasetActionsView;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, MergeModalView, ProjectCollection, ProjectModel, Request, SelectionView, TaskTypeCollection, TeamCollection, Toast, UserAnnotationCollection, UserCollection, _, app, jsRoutes,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Toast = __webpack_require__(18);
	
	Request = __webpack_require__(17);
	
	app = __webpack_require__(48);
	
	UserAnnotationCollection = __webpack_require__(67);
	
	SelectionView = __webpack_require__(68);
	
	UserCollection = __webpack_require__(70);
	
	TeamCollection = __webpack_require__(72);
	
	TaskTypeCollection = __webpack_require__(75);
	
	ProjectCollection = __webpack_require__(181);
	
	ProjectModel = __webpack_require__(182);
	
	jsRoutes = __webpack_require__(183);
	
	MergeModalView = (function(superClass) {
	  extend(MergeModalView, superClass);
	
	  function MergeModalView() {
	    return MergeModalView.__super__.constructor.apply(this, arguments);
	  }
	
	  MergeModalView.prototype.className = "modal fade";
	
	  MergeModalView.prototype.template = _.template("<div class=\"modal-dialog\">\n  <div class=\"modal-content\">\n    <div class=\"modal-header\">\n      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n      <h4 class=\"modal-title\">Merge</h4>\n    </div>\n    <div class=\"modal-body container-fluid\">\n      <div class=\"form-group\">\n        <label for=\"task-type\">Task type</label>\n        <div class=\"row\">\n          <div class=\"col-md-10 task-type\"></div>\n          <div class=\"col-md-2\">\n            <button class=\"btn btn-primary\" id=\"task-type-merge\">Merge</button>\n          </div>\n        </div>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"project\">Project</label>\n        <div class=\"row\">\n          <div class=\"col-md-10 project\"></div>\n          <div class=\"col-md-2\">\n            <button class=\"btn btn-primary\" id=\"project-merge\">Merge</button>\n          </div>\n        </div>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"nml\">NML</label>\n        <div class=\"row\">\n          <div class=\"col-md-10\">\n            <form action=\"<%- jsRoutes.controllers.admin.NMLIO.upload().url %>\"\n                method=\"POST\"\n                enctype=\"multipart/form-data\"\n                id=\"upload-and-explore-form\"\n                class=\"inline-block\">\n\n                <div class=\"fileinput fileinput-new input-group\" data-provides=\"fileinput\">\n                  <div class=\"form-control\" data-trigger=\"fileinput\">\n                    <span class=\"fileinput-filename\"></span>\n                  </div>\n                  <span class=\"input-group-addon btn btn-default btn-file\">\n                    <span class=\"fileinput-new\">\n                      <i class=\"fa fa-upload\"></i>\n                      Upload NML\n                    </span>\n                    <span class=\"fileinput-exists\">\n                      <i class=\"fa fa-upload hide\" id=\"form-upload-icon\"></i>\n                      <i class=\"fa fa-spinner fa-spin\" id=\"form-spinner-icon\"></i>\n                      Change</span>\n                    <input type=\"file\" name=\"nmlFile\" accept=\".nml\">\n                  </span>\n                </div>\n            </form>\n          </div>\n          <div class=\"col-md-2\">\n            <button class=\"btn btn-primary\" id=\"nml-merge\">Merge</button>\n          </div>\n        </div>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"explorative\">Explorative annotations</label>\n        <div class=\"row\">\n          <div class=\"col-md-10 explorative\">\n            <input type=\"text\" class=\"form-control\" placeholder=\"Explorative annotation id\"></input>\n          </div>\n          <div class=\"col-md-2\">\n            <button class=\"btn btn-primary\" id=\"explorative-merge\">Merge</button>\n          </div>\n        </div>\n      </div>\n      <hr>\n      <div class=\"checkbox hidden\">\n        <label>\n          <input type=\"checkbox\" id=\"checkbox-read-only\">\n          The merged tracing will be read-only.\n        </label>\n      </div>\n      <div>\n        The merged tracing will be saved as a new explorative tracing.\n      </div>\n    </div>\n  </div>\n</div>");
	
	  MergeModalView.prototype.regions = {
	    "tasktype": ".task-type",
	    "project": ".project"
	  };
	
	  MergeModalView.prototype.events = {
	    "click #task-type-merge": "mergeTaskType",
	    "click #project-merge": "mergeProject",
	    "click #nml-merge": "mergeNml",
	    "change input[type=file]": "selectFiles",
	    "submit @ui.uploadAndExploreForm": "uploadFiles",
	    "click #explorative-merge": "mergeExplorative",
	    "change.bs.fileinput": "selectFiles"
	  };
	
	  MergeModalView.prototype.ui = {
	    "tasktype": ".task-type",
	    "project": ".project",
	    "explorative": ".explorative",
	    "uploadAndExploreForm": "#upload-and-explore-form",
	    "formSpinnerIcon": "#form-spinner-icon",
	    "formUploadIcon": "#form-upload-icon",
	    "fileInput": ":file"
	  };
	
	  MergeModalView.prototype.initialize = function() {
	    return this.nml = void 0;
	  };
	
	  MergeModalView.prototype.show = function() {
	    this.$el.modal("show");
	    return Request.receiveJSON("/api/user").then((function(_this) {
	      return function(user) {
	        _this.taskTypeSelectionView = new SelectionView({
	          collection: new TaskTypeCollection(),
	          childViewOptions: {
	            modelValue: function() {
	              return "" + (this.model.get("summary"));
	            }
	          }
	        });
	        _this.projectSelectionView = new SelectionView({
	          collection: new ProjectCollection(),
	          childViewOptions: {
	            modelValue: function() {
	              return "" + (this.model.get("name"));
	            }
	          }
	        });
	        _this.tasktype.show(_this.taskTypeSelectionView);
	        return _this.project.show(_this.projectSelectionView);
	      };
	    })(this));
	  };
	
	  MergeModalView.prototype.mergeTaskType = function() {
	    var taskTypeId, url;
	    taskTypeId = this.ui.tasktype.find("select :selected").prop("id");
	    url = "/annotations/CompoundTaskType/" + taskTypeId + "/merge/" + (this.model.get("tracingType")) + "/" + (this.model.get("tracingId"));
	    return this.merge(url);
	  };
	
	  MergeModalView.prototype.mergeProject = function() {
	    var projectId, url;
	    projectId = this.ui.project.find("select :selected").prop("value");
	    url = "/annotations/CompoundProject/" + projectId + "/merge/" + (this.model.get("tracingType")) + "/" + (this.model.get("tracingId"));
	    return this.merge(url);
	  };
	
	  MergeModalView.prototype.mergeNml = function() {
	    var url;
	    if (this.nml) {
	      url = "/annotations/" + this.nml.typ + "/" + this.nml.id + "/merge/" + (this.model.get("tracingType")) + "/" + (this.model.get("tracingId"));
	      return this.merge(url);
	    } else {
	      return Toast.error("Please upload NML file");
	    }
	  };
	
	  MergeModalView.prototype.mergeExplorative = function() {
	    var explorativeId;
	    explorativeId = this.ui.explorative.find("input").val();
	    return this.validateId(explorativeId).then((function(_this) {
	      return function() {
	        var url;
	        url = "/annotations/Explorational/" + explorativeId + "/merge/" + (_this.model.get("tracingType")) + "/" + (_this.model.get("tracingId"));
	        return _this.merge(url);
	      };
	    })(this));
	  };
	
	  MergeModalView.prototype.merge = function(url) {
	    var readOnly;
	    readOnly = document.getElementById('checkbox-read-only').checked;
	    return Request.receiveJSON(url + "/" + readOnly).then(function(annotation) {
	      var redirectUrl;
	      Toast.message(annotation.messages);
	      redirectUrl = "/annotations/" + annotation.typ + "/" + annotation.id;
	      return app.router.loadURL(redirectUrl);
	    });
	  };
	
	  MergeModalView.prototype.selectFiles = function(event) {
	    if (this.ui.fileInput[0].files.length) {
	      return this.ui.uploadAndExploreForm.submit();
	    }
	  };
	
	  MergeModalView.prototype.toggleIcon = function(state) {
	    this.ui.formSpinnerIcon.toggleClass("hide", state);
	    return this.ui.formUploadIcon.toggleClass("hide", !state);
	  };
	
	  MergeModalView.prototype.uploadFiles = function(event) {
	    var form;
	    event.preventDefault();
	    this.toggleIcon(false);
	    form = this.ui.uploadAndExploreForm;
	    return Request.always(Request.sendMultipartFormReceiveJSON(form.attr("action"), {
	      data: new FormData(form[0])
	    }).then((function(_this) {
	      return function(data) {
	        _this.nml = data.annotation;
	        return Toast.message(data.messages);
	      };
	    })(this)), (function(_this) {
	      return function() {
	        return _this.toggleIcon(true);
	      };
	    })(this));
	  };
	
	  MergeModalView.prototype.validateId = function(id) {
	    return Request.receiveJSON("/api/find?q=" + id + "&type=id");
	  };
	
	  return MergeModalView;
	
	})(Marionette.LayoutView);
	
	module.exports = MergeModalView;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, UserAnnotationCollection, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	UserAnnotationCollection = (function(superClass) {
	  extend(UserAnnotationCollection, superClass);
	
	  function UserAnnotationCollection() {
	    return UserAnnotationCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  UserAnnotationCollection.prototype.url = function() {
	    return "/api/users/" + this.userId + "/annotations";
	  };
	
	  UserAnnotationCollection.prototype.initialize = function(models, options) {
	    this.userId = options.userId;
	    return this.dataSetName = options.dataSetName;
	  };
	
	  UserAnnotationCollection.prototype.parse = function(response) {
	    if (this.dataSetName) {
	      return _.filter(response, {
	        dataSetName: this.dataSetName
	      });
	    } else {
	      return response;
	    }
	  };
	
	  return UserAnnotationCollection;
	
	})(Backbone.Collection);
	
	module.exports = UserAnnotationCollection;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, SelectionItemView, SelectionView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	SelectionItemView = __webpack_require__(69);
	
	SelectionView = (function(superClass) {
	  extend(SelectionView, superClass);
	
	  function SelectionView() {
	    return SelectionView.__super__.constructor.apply(this, arguments);
	  }
	
	  SelectionView.prototype.tagName = "select";
	
	  SelectionView.prototype.className = "form-control";
	
	  SelectionView.prototype.attributes = function() {
	    return {
	      name: this.options.name,
	      required: this.options.required
	    };
	  };
	
	  SelectionView.prototype.childView = SelectionItemView;
	
	  SelectionView.prototype.initialize = function(options) {
	    if (options.emptyOption) {
	      this.listenTo(this, "show", this.afterRender);
	    }
	    return this.collection.fetch({
	      data: options.data
	    });
	  };
	
	  SelectionView.prototype.afterRender = function() {
	    return this.$el.prepend("<option></option>");
	  };
	
	  return SelectionView;
	
	})(Marionette.CollectionView);
	
	module.exports = SelectionView;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, SelectionItemView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	SelectionItemView = (function(superClass) {
	  extend(SelectionItemView, superClass);
	
	  function SelectionItemView() {
	    return SelectionItemView.__super__.constructor.apply(this, arguments);
	  }
	
	  SelectionItemView.prototype.tagName = "option";
	
	  SelectionItemView.prototype.attributes = function() {
	    var defaults, key, ref, value;
	    defaults = {
	      id: this.model.get("id"),
	      value: this.options.modelValue()
	    };
	    if (this.options.defaultItem) {
	      ref = _.pairs(this.options.defaultItem)[0], key = ref[0], value = ref[1];
	      if (this.model.get(key) === value) {
	        _.extend(defaults, {
	          selected: true
	        });
	      }
	    }
	    return defaults;
	  };
	
	  SelectionItemView.prototype.template = _.template("<%- label %>");
	
	  SelectionItemView.prototype.initialize = function(options) {
	    this.modelValue = options.modelValue;
	    this.modelLabel = options.modelLabel;
	    return this.listenTo(this, "render", this.afterRender);
	  };
	
	  SelectionItemView.prototype.serializeData = function() {
	    var label;
	    label = this.modelLabel ? this.modelLabel() : this.modelValue();
	    return {
	      value: this.modelValue(),
	      label: label,
	      id: this.model.get("id")
	    };
	  };
	
	  return SelectionItemView;
	
	})(Marionette.ItemView);
	
	module.exports = SelectionItemView;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var PaginationCollection, UserCollection,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	PaginationCollection = __webpack_require__(71);
	
	UserCollection = (function(superClass) {
	  extend(UserCollection, superClass);
	
	  function UserCollection() {
	    return UserCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  UserCollection.prototype.url = "/api/users";
	
	  UserCollection.prototype.sortAttribute = "firstName";
	
	  UserCollection.prototype.state = {
	    pageSize: 50
	  };
	
	  return UserCollection;
	
	})(PaginationCollection);
	
	module.exports = UserCollection;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, PaginationCollection, _,
	  slice = [].slice;
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	PaginationCollection = (function() {
	  function PaginationCollection(models, options) {
	    var ref;
	    _.extend(this, Backbone.Events);
	    if (options != null ? options.fullCollection : void 0) {
	      this.fullCollection = options.fullCollection;
	    } else {
	      this.fullCollection = new Backbone.Collection(models, options);
	      if (this.initialize) {
	        this.initialize.call(this.fullCollection, models, options);
	      }
	    }
	    if (this.model != null) {
	      this.fullCollection.model = this.model;
	    }
	    if (this.url != null) {
	      this.fullCollection.url = this.url;
	    }
	    if (this.parse != null) {
	      this.fullCollection.parse = this.parse;
	    }
	    if (this.idAttribute != null) {
	      this.fullCollection.idAttribute = this.idAttribute;
	    }
	    this.currentModels = this.fullCollection.models.slice();
	    this.state = _.defaults((ref = _.clone(this.state)) != null ? ref : {}, {
	      pageSize: 10,
	      currentPage: 0,
	      sorting: null,
	      filter: null,
	      collectionFilter: null,
	      filterQuery: ""
	    });
	    if (this.sortAttribute) {
	      this.setSort(this.sortAttribute, "asc");
	    }
	    this.length = Math.min(this.state.pageSize, this.fullCollection.length);
	    this.models = this.currentModels.slice(0, this.length);
	    this.listenTo(this.fullCollection, "reset", this._reset);
	    this.listenTo(this.fullCollection, "add", this._passthroughEvent("add"));
	    this.listenTo(this.fullCollection, "remove", this._passthroughEvent("remove"));
	    this.listenTo(this.fullCollection, "sync", this._passthroughEvent("sync"));
	    this._reset = _.debounce(this._reset, 50);
	    return;
	  }
	
	  PaginationCollection.prototype.add = function() {
	    return this.fullCollection.add.apply(this.fullCollection, arguments);
	  };
	
	  PaginationCollection.prototype.remove = function() {
	    return this.fullCollection.remove.apply(this.fullCollection, arguments);
	  };
	
	  PaginationCollection.prototype.set = function() {
	    return this.fullCollection.set.apply(this.fullCollection, arguments);
	  };
	
	  PaginationCollection.prototype.fetch = function() {
	    return this.fullCollection.fetch.apply(this.fullCollection, arguments);
	  };
	
	  PaginationCollection.prototype.create = function() {
	    return this.fullCollection.create.apply(this.fullCollection, arguments);
	  };
	
	  PaginationCollection.prototype.reset = function() {
	    return this.fullCollection.reset.apply(this.fullCollection, arguments);
	  };
	
	  PaginationCollection.prototype.setPageSize = function(pageSize) {
	    this.state.pageSize = pageSize;
	    this._reset();
	  };
	
	  PaginationCollection.prototype.setSorting = function(field, order) {
	    this.setSort(field, order);
	  };
	
	  PaginationCollection.prototype.setSort = function(field, order) {
	    if (order === "asc") {
	      order = 1;
	    }
	    if (order === "desc") {
	      order = -1;
	    }
	    this.state.sorting = function(left, right) {
	      var leftValue, rightValue;
	      leftValue = left.get(field);
	      rightValue = right.get(field);
	      if (_.isString(leftValue) && _.isString(rightValue)) {
	        if (order > 0) {
	          return leftValue.localeCompare(rightValue);
	        } else {
	          return rightValue.localeCompare(leftValue);
	        }
	      } else {
	        if (order > 0) {
	          return leftValue - rightValue;
	        } else {
	          return rightValue - leftValue;
	        }
	      }
	    };
	    this._reset();
	  };
	
	  PaginationCollection.prototype.setCollectionFilter = function(filter) {
	    this.state.collectionFilter = filter;
	  };
	
	  PaginationCollection.prototype.setFilter = function(fields, query) {
	    var pattern, regexp, words;
	    if (query === '' || !_.isString(query)) {
	      this.state.filterQuery = "";
	      this.state.filter = null;
	    } else {
	      words = _.map(query.match(/\w+/ig), function(element) {
	        return element.toLowerCase();
	      });
	      pattern = "(" + _.uniq(words).join("|") + ")";
	      regexp = new RegExp(pattern, "igm");
	      this.state.filterQuery = query;
	      this.state.filter = function(model) {
	        return _.any(fields, function(fieldName) {
	          var value;
	          value = model.get(fieldName);
	          if (value != null) {
	            return !!value.toString().match(regexp);
	          } else {
	            return false;
	          }
	        });
	      };
	    }
	    this._reset();
	  };
	
	  PaginationCollection.prototype.at = function(index) {
	    return this.currentModels[index];
	  };
	
	  PaginationCollection.prototype.get = function(index) {
	    return this.at(index);
	  };
	
	  PaginationCollection.prototype.clone = function() {
	    var clonedCollection;
	    clonedCollection = new PaginationCollection(null, {
	      fullCollection: this.fullCollection
	    });
	    clonedCollection.setPageSize(this.state.pageSize);
	    return clonedCollection;
	  };
	
	  PaginationCollection.prototype._lastPageIndex = function() {
	    return Math.ceil(this.currentModels.length / this.state.pageSize) - 1;
	  };
	
	  PaginationCollection.prototype._passthroughEvent = function(eventType) {
	    return function() {
	      var args;
	      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	      this._reset();
	      this.trigger.apply(this, [eventType].concat(slice.call(args)));
	    };
	  };
	
	  PaginationCollection.prototype._resetModels = function() {
	    var models;
	    models = this.fullCollection.models.slice();
	    if (this.state.collectionFilter != null) {
	      models = models.filter(this.state.collectionFilter);
	    }
	    if (this.state.filter != null) {
	      models = models.filter(this.state.filter);
	    }
	    if (this.state.sorting != null) {
	      models = models.sort(this.state.sorting);
	    }
	    this.currentModels = models;
	    this.state.currentPage = Math.max(0, Math.min(this._lastPageIndex(), this.state.currentPage));
	  };
	
	  PaginationCollection.prototype._reset = function() {
	    this._resetModels();
	    this.models = this.currentModels.slice(this.state.currentPage * this.state.pageSize, Math.min((this.state.currentPage + 1) * this.state.pageSize, this.currentModels.length));
	    this.length = this.models.length;
	    this.trigger("reset");
	  };
	
	  PaginationCollection.prototype.getPaginationInfo = function() {
	    return {
	      firstPage: 0,
	      lastPage: this._lastPageIndex(),
	      currentPage: this.state.currentPage,
	      pageSize: this.state.pageSize
	    };
	  };
	
	  PaginationCollection.prototype.getPreviousPage = function() {
	    this.getPage(this.state.currentPage - 1);
	  };
	
	  PaginationCollection.prototype.getNextPage = function() {
	    this.getPage(this.state.currentPage + 1);
	  };
	
	  PaginationCollection.prototype.getFirstPage = function() {
	    this.getPage(0);
	  };
	
	  PaginationCollection.prototype.getLastPage = function() {
	    this.getPage(this._lastPageIndex());
	  };
	
	  PaginationCollection.prototype.getPage = function(pageIndex) {
	    if ((0 <= pageIndex && pageIndex < Math.ceil(this.currentModels.length / this.state.pageSize))) {
	      this.state.currentPage = pageIndex;
	      this._reset();
	    }
	  };
	
	  PaginationCollection.prototype.toJSON = function() {
	    return this.models.map(function(model) {
	      return model.toJSON();
	    });
	  };
	
	  PaginationCollection.prototype.findWhere = function() {
	    return this.fullCollection.findWhere.apply(this.fullCollection, arguments);
	  };
	
	  return PaginationCollection;
	
	})();
	
	module.exports = PaginationCollection;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, SortedCollection, TeamCollection, TeamModel, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	TeamModel = __webpack_require__(73);
	
	SortedCollection = __webpack_require__(74);
	
	TeamCollection = (function(superClass) {
	  extend(TeamCollection, superClass);
	
	  function TeamCollection() {
	    return TeamCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  TeamCollection.prototype.url = "/api/teams";
	
	  TeamCollection.prototype.model = TeamModel;
	
	  TeamCollection.prototype.sortAttribute = "name";
	
	  return TeamCollection;
	
	})(SortedCollection);
	
	module.exports = TeamCollection;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, TeamModel, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	TeamModel = (function(superClass) {
	  extend(TeamModel, superClass);
	
	  function TeamModel() {
	    return TeamModel.__super__.constructor.apply(this, arguments);
	  }
	
	  TeamModel.prototype.urlRoot = "/api/teams";
	
	  TeamModel.prototype.defaults = {
	    name: "",
	    owner: "",
	    roles: [
	      {
	        name: "admin"
	      }, {
	        name: "user"
	      }
	    ],
	    isEditable: "true"
	  };
	
	  return TeamModel;
	
	})(Backbone.Model);
	
	module.exports = TeamModel;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, SortedCollection,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Backbone = __webpack_require__(3);
	
	SortedCollection = (function(superClass) {
	  extend(SortedCollection, superClass);
	
	  function SortedCollection() {
	    return SortedCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  SortedCollection.prototype.initialize = function() {
	    if (this.sortAttribute) {
	      return this.setSort(this.sortAttribute, "asc");
	    }
	  };
	
	  SortedCollection.prototype.setSort = function(field, sortDirection) {
	    if (sortDirection === "asc") {
	      sortDirection = 1;
	    }
	    if (sortDirection === "desc") {
	      sortDirection = -1;
	    }
	    this.comparator = function(left, right) {
	      var leftValue, rightValue;
	      leftValue = left.get(field);
	      rightValue = right.get(field);
	      if (_.isString(leftValue) && _.isString(rightValue)) {
	        if (sortDirection > 0) {
	          return leftValue.localeCompare(rightValue);
	        } else {
	          return rightValue.localeCompare(leftValue);
	        }
	      } else {
	        if (sortDirection > 0) {
	          return leftValue - rightValue;
	        } else {
	          return rightValue - leftValue;
	        }
	      }
	    };
	    return this.sort();
	  };
	
	  return SortedCollection;
	
	})(Backbone.Collection);
	
	module.exports = SortedCollection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var SortedCollection, TaskTypeCollection, TaskTypeModel, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	TaskTypeModel = __webpack_require__(76);
	
	SortedCollection = __webpack_require__(74);
	
	TaskTypeCollection = (function(superClass) {
	  extend(TaskTypeCollection, superClass);
	
	  function TaskTypeCollection() {
	    return TaskTypeCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  TaskTypeCollection.prototype.url = "/api/taskTypes";
	
	  TaskTypeCollection.prototype.model = TaskTypeModel;
	
	  TaskTypeCollection.prototype.sortAttribute = "summary";
	
	  TaskTypeCollection.prototype.parse = function(responses) {
	    return _.map(responses, TaskTypeModel.prototype.parse);
	  };
	
	  TaskTypeCollection.prototype.addJSON = function(item) {
	    item = this.parse([item])[0];
	    return this.add(item);
	  };
	
	  return TaskTypeCollection;
	
	})(SortedCollection);
	
	module.exports = TaskTypeCollection;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var FormatUtils, TaskTypeModel, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	FormatUtils = __webpack_require__(77);
	
	TaskTypeModel = (function(superClass) {
	  extend(TaskTypeModel, superClass);
	
	  function TaskTypeModel() {
	    return TaskTypeModel.__super__.constructor.apply(this, arguments);
	  }
	
	  TaskTypeModel.prototype.url = function() {
	    return "/api/taskTypes/" + this.id;
	  };
	
	  TaskTypeModel.prototype.parse = function(response) {
	    response.formattedHash = FormatUtils.formatHash(response.id);
	    response.formattedShortText = FormatUtils.formatShortText(response.description);
	    return response;
	  };
	
	  TaskTypeModel.prototype.destroy = function() {
	    var options;
	    options = {
	      url: "/api/taskTypes/" + (this.get('id')) + "/delete"
	    };
	    return TaskTypeModel.__super__.destroy.call(this, options);
	  };
	
	  return TaskTypeModel;
	
	})(Backbone.Model);
	
	module.exports = TaskTypeModel;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var FormatUtils, _, moment;
	
	_ = __webpack_require__(2);
	
	moment = __webpack_require__(78);
	
	FormatUtils = (function() {
	  function FormatUtils() {}
	
	  FormatUtils.formatSeconds = function(seconds) {
	    var days, hours, minutes, ref, t;
	    t = moment.duration({
	      seconds: seconds
	    });
	    ref = [t.days(), t.hours(), t.minutes(), t.seconds()], days = ref[0], hours = ref[1], minutes = ref[2], seconds = ref[3];
	    return (days === 0 && hours === 0 && minutes === 0 ? seconds + "s" : days === 0 && hours === 0 ? minutes + "m " + seconds + "s" : days === 0 ? hours + "h " + minutes + "m " + seconds + "s" : days + "d " + hours + "h " + minutes + "m " + seconds + "s");
	  };
	
	  FormatUtils.formatHash = function(id) {
	    return id.slice(-6);
	  };
	
	  FormatUtils.formatShortText = function(text, maxLength) {
	    if (maxLength == null) {
	      maxLength = 100;
	    }
	    if (text.length > maxLength && maxLength > 4) {
	      return text.slice(0, maxLength - 4) + " ...";
	    } else {
	      return text;
	    }
	  };
	
	
	  /**
	   * Return current date and time
	   */
	
	  FormatUtils.formatDate = function() {
	    return moment().format("YYYY-MM-DD HH:mm");
	  };
	
	  return FormatUtils;
	
	})();
	
	module.exports = FormatUtils;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.14.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';
	
	    var hookCallback;
	
	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }
	
	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }
	
	    function isArray(input) {
	        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isObject(input) {
	        return Object.prototype.toString.call(input) === '[object Object]';
	    }
	
	    function isObjectEmpty(obj) {
	        var k;
	        for (k in obj) {
	            // even if its not own property I'd still call it non-empty
	            return false;
	        }
	        return true;
	    }
	
	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }
	
	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }
	
	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }
	
	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }
	
	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false,
	            parsedDateParts : [],
	            meridiem        : null
	        };
	    }
	
	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }
	
	    var some;
	    if (Array.prototype.some) {
	        some = Array.prototype.some;
	    } else {
	        some = function (fun) {
	            var t = Object(this);
	            var len = t.length >>> 0;
	
	            for (var i = 0; i < len; i++) {
	                if (i in t && fun.call(this, t[i], i, t)) {
	                    return true;
	                }
	            }
	
	            return false;
	        };
	    }
	
	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            var parsedParts = some.call(flags.parsedDateParts, function (i) {
	                return i != null;
	            });
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated &&
	                (!flags.meridiem || (flags.meridiem && parsedParts));
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }
	
	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }
	
	        return m;
	    }
	
	    function isUndefined(input) {
	        return input === void 0;
	    }
	
	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = utils_hooks__hooks.momentProperties = [];
	
	    function copyConfig(to, from) {
	        var i, prop, val;
	
	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }
	
	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }
	
	        return to;
	    }
	
	    var updateInProgress = false;
	
	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }
	
	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }
	
	    function absFloor (number) {
	        if (number < 0) {
	            // -0 -> 0
	            return Math.ceil(number) || 0;
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }
	
	        return value;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }
	
	    function deprecate(msg, fn) {
	        var firstTime = true;
	
	        return extend(function () {
	            if (utils_hooks__hooks.deprecationHandler != null) {
	                utils_hooks__hooks.deprecationHandler(null, msg);
	            }
	            if (firstTime) {
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }
	
	    var deprecations = {};
	
	    function deprecateSimple(name, msg) {
	        if (utils_hooks__hooks.deprecationHandler != null) {
	            utils_hooks__hooks.deprecationHandler(name, msg);
	        }
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }
	
	    utils_hooks__hooks.suppressDeprecationWarnings = false;
	    utils_hooks__hooks.deprecationHandler = null;
	
	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }
	
	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }
	
	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig), prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        for (prop in parentConfig) {
	            if (hasOwnProp(parentConfig, prop) &&
	                    !hasOwnProp(childConfig, prop) &&
	                    isObject(parentConfig[prop])) {
	                // make sure changes to properties don't modify parent config
	                res[prop] = extend({}, res[prop]);
	            }
	        }
	        return res;
	    }
	
	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }
	
	    var keys;
	
	    if (Object.keys) {
	        keys = Object.keys;
	    } else {
	        keys = function (obj) {
	            var i, res = [];
	            for (i in obj) {
	                if (hasOwnProp(obj, i)) {
	                    res.push(i);
	                }
	            }
	            return res;
	        };
	    }
	
	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };
	
	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key] || this._calendar['sameElse'];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }
	
	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };
	
	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];
	
	        if (format || !formatUpper) {
	            return format;
	        }
	
	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });
	
	        return this._longDateFormat[key];
	    }
	
	    var defaultInvalidDate = 'Invalid date';
	
	    function invalidDate () {
	        return this._invalidDate;
	    }
	
	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;
	
	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }
	
	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };
	
	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }
	
	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }
	
	    var aliases = {};
	
	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }
	
	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    var priorities = {};
	
	    function addUnitPriority(unit, priority) {
	        priorities[unit] = priority;
	    }
	
	    function getPrioritizedUnits(unitsObj) {
	        var units = [];
	        for (var u in unitsObj) {
	            units.push({unit: u, priority: priorities[u]});
	        }
	        units.sort(function (a, b) {
	            return a.priority - b.priority;
	        });
	        return units;
	    }
	
	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }
	
	    function get_set__get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }
	
	    function get_set__set (mom, unit, value) {
	        if (mom.isValid()) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }
	
	    // MOMENTS
	
	    function stringGet (units) {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units]();
	        }
	        return this;
	    }
	
	
	    function stringSet (units, value) {
	        if (typeof units === 'object') {
	            units = normalizeObjectUnits(units);
	            var prioritized = getPrioritizedUnits(units);
	            for (var i = 0; i < prioritized.length; i++) {
	                this[prioritized[i].unit](units[prioritized[i].unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }
	
	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }
	
	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	
	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	
	    var formatFunctions = {};
	
	    var formatTokenFunctions = {};
	
	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = '', i;
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }
	
	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, locale) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
	
	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf
	
	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	
	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	
	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	
	
	    var regexes = {};
	
	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }
	
	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }
	
	        return regexes[token](config._strict, config._locale);
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }
	
	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    var tokens = {};
	
	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }
	
	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }
	
	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }
	
	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;
	
	    var indexOf;
	
	    if (Array.prototype.indexOf) {
	        indexOf = Array.prototype.indexOf;
	    } else {
	        indexOf = function (o) {
	            // I know
	            var i;
	            for (i = 0; i < this.length; ++i) {
	                if (this[i] === o) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	    }
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    // FORMATTING
	
	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });
	
	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });
	
	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });
	
	    // ALIASES
	
	    addUnitAlias('month', 'M');
	
	    // PRIORITY
	
	    addUnitPriority('month', 8);
	
	    // PARSING
	
	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });
	
	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });
	
	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });
	
	    // LOCALES
	
	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	    }
	
	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }
	
	    function units_month__handleStrictParse(monthName, format, strict) {
	        var i, ii, mom, llc = monthName.toLocaleLowerCase();
	        if (!this._monthsParse) {
	            // this is not used
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	            for (i = 0; i < 12; ++i) {
	                mom = create_utc__createUTC([2000, i]);
	                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	            }
	        }
	
	        if (strict) {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }
	
	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;
	
	        if (this._monthsParseExact) {
	            return units_month__handleStrictParse.call(this, monthName, format, strict);
	        }
	
	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }
	
	        // TODO: add sorting
	        // Sorting makes sure if one month (or abbr) is a prefix of another
	        // see sorting in computeMonthsParse
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function setMonth (mom, value) {
	        var dayOfMonth;
	
	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }
	
	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (typeof value !== 'number') {
	                    return mom;
	                }
	            }
	        }
	
	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }
	
	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }
	
	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }
	
	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsShortRegex')) {
	                this._monthsShortRegex = defaultMonthsShortRegex;
	            }
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }
	
	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                this._monthsRegex = defaultMonthsRegex;
	            }
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }
	
	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }
	
	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	        }
	        for (i = 0; i < 24; i++) {
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }
	
	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    }
	
	    // FORMATTING
	
	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });
	
	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });
	
	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
	
	    // ALIASES
	
	    addUnitAlias('year', 'y');
	
	    // PRIORITIES
	
	    addUnitPriority('year', 1);
	
	    // PARSING
	
	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);
	
	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });
	
	    // HELPERS
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    // HOOKS
	
	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };
	
	    // MOMENTS
	
	    var getSetYear = makeGetSet('FullYear', true);
	
	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }
	
	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	
	        //the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	
	        return -fwdlw + fwd - 1;
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;
	
	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }
	
	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }
	
	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;
	
	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }
	
	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }
	
	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }
	
	    // FORMATTING
	
	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
	
	    // ALIASES
	
	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');
	
	    // PRIORITIES
	
	    addUnitPriority('week', 5);
	    addUnitPriority('isoWeek', 5);
	
	    // PARSING
	
	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);
	
	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });
	
	    // HELPERS
	
	    // LOCALES
	
	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }
	
	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };
	
	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }
	
	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }
	
	    // MOMENTS
	
	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    // FORMATTING
	
	    addFormatToken('d', 0, 'do', 'day');
	
	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });
	
	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });
	
	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });
	
	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');
	
	    // ALIASES
	
	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');
	
	    // PRIORITY
	    addUnitPriority('day', 11);
	    addUnitPriority('weekday', 11);
	    addUnitPriority('isoWeekday', 11);
	
	    // PARSING
	
	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   function (isStrict, locale) {
	        return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd',   function (isStrict, locale) {
	        return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd',   function (isStrict, locale) {
	        return locale.weekdaysRegex(isStrict);
	    });
	
	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });
	
	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });
	
	    // HELPERS
	
	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }
	
	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }
	
	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }
	
	        return null;
	    }
	
	    function parseIsoWeekday(input, locale) {
	        if (typeof input === 'string') {
	            return locale.weekdaysParse(input) % 7 || 7;
	        }
	        return isNaN(input) ? null : input;
	    }
	
	    // LOCALES
	
	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        return isArray(this._weekdays) ? this._weekdays[m.day()] :
	            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	    }
	
	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }
	
	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }
	
	    function day_of_week__handleStrictParse(weekdayName, format, strict) {
	        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._minWeekdaysParse = [];
	
	            for (i = 0; i < 7; ++i) {
	                mom = create_utc__createUTC([2000, 1]).day(i);
	                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	            }
	        }
	
	        if (strict) {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }
	
	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;
	
	        if (this._weekdaysParseExact) {
	            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
	        }
	
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }
	
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	
	            mom = create_utc__createUTC([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }
	
	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }
	
	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	
	        if (input != null) {
	            var weekday = parseIsoWeekday(input, this.localeData());
	            return this.day(this.day() % 7 ? weekday : weekday - 7);
	        } else {
	            return this.day() || 7;
	        }
	    }
	
	    var defaultWeekdaysRegex = matchWord;
	    function weekdaysRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysStrictRegex;
	            } else {
	                return this._weekdaysRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                this._weekdaysRegex = defaultWeekdaysRegex;
	            }
	            return this._weekdaysStrictRegex && isStrict ?
	                this._weekdaysStrictRegex : this._weekdaysRegex;
	        }
	    }
	
	    var defaultWeekdaysShortRegex = matchWord;
	    function weekdaysShortRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysShortStrictRegex;
	            } else {
	                return this._weekdaysShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	            }
	            return this._weekdaysShortStrictRegex && isStrict ?
	                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	        }
	    }
	
	    var defaultWeekdaysMinRegex = matchWord;
	    function weekdaysMinRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysMinStrictRegex;
	            } else {
	                return this._weekdaysMinRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	            }
	            return this._weekdaysMinStrictRegex && isStrict ?
	                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	        }
	    }
	
	
	    function computeWeekdaysParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }
	
	        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom, minp, shortp, longp;
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, 1]).day(i);
	            minp = this.weekdaysMin(mom, '');
	            shortp = this.weekdaysShort(mom, '');
	            longp = this.weekdays(mom, '');
	            minPieces.push(minp);
	            shortPieces.push(shortp);
	            longPieces.push(longp);
	            mixedPieces.push(minp);
	            mixedPieces.push(shortp);
	            mixedPieces.push(longp);
	        }
	        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	        // will match the longer piece.
	        minPieces.sort(cmpLenRev);
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 7; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }
	
	        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._weekdaysShortRegex = this._weekdaysRegex;
	        this._weekdaysMinRegex = this._weekdaysRegex;
	
	        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	    }
	
	    // FORMATTING
	
	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }
	
	    function kFormat() {
	        return this.hours() || 24;
	    }
	
	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);
	
	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });
	
	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });
	
	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });
	
	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });
	
	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }
	
	    meridiem('a', true);
	    meridiem('A', false);
	
	    // ALIASES
	
	    addUnitAlias('hour', 'h');
	
	    // PRIORITY
	    addUnitPriority('hour', 13);
	
	    // PARSING
	
	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }
	
	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	
	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);
	
	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });
	
	    // LOCALES
	
	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }
	
	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }
	
	
	    // MOMENTS
	
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);
	
	    var baseConfig = {
	        calendar: defaultCalendar,
	        longDateFormat: defaultLongDateFormat,
	        invalidDate: defaultInvalidDate,
	        ordinal: defaultOrdinal,
	        ordinalParse: defaultOrdinalParse,
	        relativeTime: defaultRelativeTime,
	
	        months: defaultLocaleMonths,
	        monthsShort: defaultLocaleMonthsShort,
	
	        week: defaultLocaleWeek,
	
	        weekdays: defaultLocaleWeekdays,
	        weekdaysMin: defaultLocaleWeekdaysMin,
	        weekdaysShort: defaultLocaleWeekdaysShort,
	
	        meridiemParse: defaultLocaleMeridiemParse
	    };
	
	    // internal storage for locale config files
	    var locales = {};
	    var globalLocale;
	
	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;
	
	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }
	
	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && (typeof module !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                __webpack_require__(79)("./" + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }
	
	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }
	
	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }
	
	        return globalLocale._abbr;
	    }
	
	    function defineLocale (name, config) {
	        if (config !== null) {
	            var parentConfig = baseConfig;
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple('defineLocaleOverride',
	                        'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale ' +
	                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	                parentConfig = locales[name]._config;
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    parentConfig = locales[config.parentLocale]._config;
	                } else {
	                    // treat as if there is no base config
	                    deprecateSimple('parentLocaleUndefined',
	                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
	                }
	            }
	            locales[name] = new Locale(mergeConfigs(parentConfig, config));
	
	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	
	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }
	
	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale, parentConfig = baseConfig;
	            // MERGE
	            if (locales[name] != null) {
	                parentConfig = locales[name]._config;
	            }
	            config = mergeConfigs(parentConfig, config);
	            locale = new Locale(config);
	            locale.parentLocale = locales[name];
	            locales[name] = locale;
	
	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }
	
	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;
	
	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }
	
	        if (!key) {
	            return globalLocale;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }
	
	        return chooseLocale(key);
	    }
	
	    function locale_locales__listLocales() {
	        return keys(locales);
	    }
	
	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;
	
	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }
	
	            getParsingFlags(m).overflow = overflow;
	        }
	
	        return m;
	    }
	
	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	
	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	
	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];
	
	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];
	
	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
	
	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;
	
	        if (match) {
	            getParsingFlags(config).iso = true;
	
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }
	
	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);
	
	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }
	
	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );
	
	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }
	
	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(utils_hooks__hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }
	
	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }
	
	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }
	
	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }
	
	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	
	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;
	
	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;
	
	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);
	
	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }
	
	    // constant that refers to the ISO standard
	    utils_hooks__hooks.ISO_8601 = function () {};
	
	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	
	        config._a = [];
	        getParsingFlags(config).empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }
	
	        // clear _12h flag if hour is <= 12
	        if (config._a[HOUR] <= 12 &&
	            getParsingFlags(config).bigHour === true &&
	            config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	
	        getParsingFlags(config).parsedDateParts = config._a.slice(0);
	        getParsingFlags(config).meridiem = config._meridiem;
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	
	        configFromArray(config);
	        checkOverflow(config);
	    }
	
	
	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;
	
	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }
	
	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);
	
	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;
	
	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	
	            getParsingFlags(tempConfig).score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }
	
	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });
	
	        configFromArray(config);
	    }
	
	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }
	
	        return res;
	    }
	
	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;
	
	        config._locale = config._locale || locale_locales__getLocale(config._l);
	
	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }
	
	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else if (format) {
	            configFromStringAndFormat(config);
	        }  else {
	            configFromInput(config);
	        }
	
	        if (!valid__isValid(config)) {
	            config._d = null;
	        }
	
	        return config;
	    }
	
	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date(utils_hooks__hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(input.valueOf());
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};
	
	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	
	        if ((isObject(input) && isObjectEmpty(input)) ||
	                (isArray(input) && input.length === 0)) {
	            input = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	
	        return createFromConfig(c);
	    }
	
	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }
	
	    var prototypeMin = deprecate(
	        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other < this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );
	
	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );
	
	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }
	
	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isBefore', args);
	    }
	
	    function max () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isAfter', args);
	    }
	
	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };
	
	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;
	
	        this._data = {};
	
	        this._locale = locale_locales__getLocale();
	
	        this._bubble();
	    }
	
	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }
	
	    // FORMATTING
	
	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }
	
	    offset('Z', ':');
	    offset('ZZ', '');
	
	    // PARSING
	
	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });
	
	    // HELPERS
	
	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;
	
	    function offsetFromString(matcher, string) {
	        var matches = ((string || '').match(matcher) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? minutes : -minutes;
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(res._d.valueOf() + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }
	
	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }
	
	    // HOOKS
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};
	
	    // MOMENTS
	
	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	            } else if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }
	
	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }
	
	            this.utcOffset(input, keepLocalTime);
	
	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }
	
	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }
	
	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;
	
	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }
	
	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(matchOffset, this._i));
	        }
	        return this;
	    }
	
	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? local__createLocal(input).utcOffset() : 0;
	
	        return (this.utcOffset() - input) % 60 === 0;
	    }
	
	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }
	
	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }
	
	        var c = {};
	
	        copyConfig(c, this);
	        c = prepareConfig(c);
	
	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }
	
	        return this._isDSTShifted;
	    }
	
	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }
	
	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }
	
	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }
	
	    // ASP.NET json date format regex
	    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
	
	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day
	    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
	
	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;
	
	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                w : parseIso(match[4], sign),
	                d : parseIso(match[5], sign),
	                h : parseIso(match[6], sign),
	                m : parseIso(match[7], sign),
	                s : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
	
	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }
	
	        ret = new Duration(duration);
	
	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }
	
	        return ret;
	    }
	
	    create__createDuration.fn = Duration.prototype;
	
	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }
	
	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};
	
	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }
	
	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	        return res;
	    }
	
	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }
	
	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }
	
	        return res;
	    }
	
	    function absRound (number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }
	
	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	                tmp = val; val = period; period = tmp;
	            }
	
	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }
	
	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);
	
	        if (!mom.isValid()) {
	            // No op
	            return;
	        }
	
	        updateOffset = updateOffset == null ? true : updateOffset;
	
	        if (milliseconds) {
	            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }
	
	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');
	
	    function getCalendarFormat(myMoment, now) {
	        var diff = myMoment.diff(now, 'days', true);
	        return diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	    }
	
	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';
	
	        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
	
	        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	    }
	
	    function clone () {
	        return new Moment(this);
	    }
	
	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() > localInput.valueOf();
	        } else {
	            return localInput.valueOf() < this.clone().startOf(units).valueOf();
	        }
	    }
	
	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() < localInput.valueOf();
	        } else {
	            return this.clone().endOf(units).valueOf() < localInput.valueOf();
	        }
	    }
	
	    function isBetween (from, to, units, inclusivity) {
	        inclusivity = inclusivity || '()';
	        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	    }
	
	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() === localInput.valueOf();
	        } else {
	            inputMs = localInput.valueOf();
	            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	        }
	    }
	
	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input,units);
	    }
	
	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input,units);
	    }
	
	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            delta, output;
	
	        if (!this.isValid()) {
	            return NaN;
	        }
	
	        that = cloneWithOffset(input, this);
	
	        if (!that.isValid()) {
	            return NaN;
	        }
	
	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	
	        units = normalizeUnits(units);
	
	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }
	
	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;
	
	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }
	
	        //check for negative zero, return zero if negative zero
	        return -(wholeMonthDiff + adjust) || 0;
	    }
	
	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
	
	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }
	
	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if (isFunction(Date.prototype.toISOString)) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }
	
	    function format (inputString) {
	        if (!inputString) {
	            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
	        }
	        var output = formatMoment(this, inputString);
	        return this.localeData().postformat(output);
	    }
	
	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }
	
	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }
	
	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }
	
	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }
	
	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;
	
	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }
	
	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );
	
	    function localeData () {
	        return this._locale;
	    }
	
	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'quarter':
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	            case 'date':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	        }
	
	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }
	
	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }
	
	        return this;
	    }
	
	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	
	        // 'date' is an alias for 'day', so it should be considered as such.
	        if (units === 'date') {
	            units = 'day';
	        }
	
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }
	
	    function to_type__valueOf () {
	        return this._d.valueOf() - ((this._offset || 0) * 60000);
	    }
	
	    function unix () {
	        return Math.floor(this.valueOf() / 1000);
	    }
	
	    function toDate () {
	        return new Date(this.valueOf());
	    }
	
	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }
	
	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }
	
	    function toJSON () {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }
	
	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }
	
	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }
	
	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }
	
	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }
	
	    // FORMATTING
	
	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });
	
	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });
	
	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }
	
	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
	
	    // ALIASES
	
	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');
	
	    // PRIORITY
	
	    addUnitPriority('weekYear', 1);
	    addUnitPriority('isoWeekYear', 1);
	
	
	    // PARSING
	
	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);
	
	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });
	
	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	
	    // MOMENTS
	
	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }
	
	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }
	
	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }
	
	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }
	
	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }
	
	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	
	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }
	
	    // FORMATTING
	
	    addFormatToken('Q', 0, 'Qo', 'quarter');
	
	    // ALIASES
	
	    addUnitAlias('quarter', 'Q');
	
	    // PRIORITY
	
	    addUnitPriority('quarter', 7);
	
	    // PARSING
	
	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });
	
	    // MOMENTS
	
	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }
	
	    // FORMATTING
	
	    addFormatToken('D', ['DD', 2], 'Do', 'date');
	
	    // ALIASES
	
	    addUnitAlias('date', 'D');
	
	    // PRIOROITY
	    addUnitPriority('date', 9);
	
	    // PARSING
	
	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });
	
	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });
	
	    // MOMENTS
	
	    var getSetDayOfMonth = makeGetSet('Date', true);
	
	    // FORMATTING
	
	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
	
	    // ALIASES
	
	    addUnitAlias('dayOfYear', 'DDD');
	
	    // PRIORITY
	    addUnitPriority('dayOfYear', 4);
	
	    // PARSING
	
	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });
	
	    // HELPERS
	
	    // MOMENTS
	
	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }
	
	    // FORMATTING
	
	    addFormatToken('m', ['mm', 2], 0, 'minute');
	
	    // ALIASES
	
	    addUnitAlias('minute', 'm');
	
	    // PRIORITY
	
	    addUnitPriority('minute', 14);
	
	    // PARSING
	
	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);
	
	    // MOMENTS
	
	    var getSetMinute = makeGetSet('Minutes', false);
	
	    // FORMATTING
	
	    addFormatToken('s', ['ss', 2], 0, 'second');
	
	    // ALIASES
	
	    addUnitAlias('second', 's');
	
	    // PRIORITY
	
	    addUnitPriority('second', 15);
	
	    // PARSING
	
	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);
	
	    // MOMENTS
	
	    var getSetSecond = makeGetSet('Seconds', false);
	
	    // FORMATTING
	
	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });
	
	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });
	
	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });
	
	
	    // ALIASES
	
	    addUnitAlias('millisecond', 'ms');
	
	    // PRIORITY
	
	    addUnitPriority('millisecond', 16);
	
	    // PARSING
	
	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);
	
	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }
	
	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }
	
	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS
	
	    var getSetMillisecond = makeGetSet('Milliseconds', false);
	
	    // FORMATTING
	
	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');
	
	    // MOMENTS
	
	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }
	
	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }
	
	    var momentPrototype__proto = Moment.prototype;
	
	    momentPrototype__proto.add               = add_subtract__add;
	    momentPrototype__proto.calendar          = moment_calendar__calendar;
	    momentPrototype__proto.clone             = clone;
	    momentPrototype__proto.diff              = diff;
	    momentPrototype__proto.endOf             = endOf;
	    momentPrototype__proto.format            = format;
	    momentPrototype__proto.from              = from;
	    momentPrototype__proto.fromNow           = fromNow;
	    momentPrototype__proto.to                = to;
	    momentPrototype__proto.toNow             = toNow;
	    momentPrototype__proto.get               = stringGet;
	    momentPrototype__proto.invalidAt         = invalidAt;
	    momentPrototype__proto.isAfter           = isAfter;
	    momentPrototype__proto.isBefore          = isBefore;
	    momentPrototype__proto.isBetween         = isBetween;
	    momentPrototype__proto.isSame            = isSame;
	    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
	    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
	    momentPrototype__proto.isValid           = moment_valid__isValid;
	    momentPrototype__proto.lang              = lang;
	    momentPrototype__proto.locale            = locale;
	    momentPrototype__proto.localeData        = localeData;
	    momentPrototype__proto.max               = prototypeMax;
	    momentPrototype__proto.min               = prototypeMin;
	    momentPrototype__proto.parsingFlags      = parsingFlags;
	    momentPrototype__proto.set               = stringSet;
	    momentPrototype__proto.startOf           = startOf;
	    momentPrototype__proto.subtract          = add_subtract__subtract;
	    momentPrototype__proto.toArray           = toArray;
	    momentPrototype__proto.toObject          = toObject;
	    momentPrototype__proto.toDate            = toDate;
	    momentPrototype__proto.toISOString       = moment_format__toISOString;
	    momentPrototype__proto.toJSON            = toJSON;
	    momentPrototype__proto.toString          = toString;
	    momentPrototype__proto.unix              = unix;
	    momentPrototype__proto.valueOf           = to_type__valueOf;
	    momentPrototype__proto.creationData      = creationData;
	
	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;
	
	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
	
	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
	
	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;
	
	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
	
	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;
	
	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
	
	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
	
	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
	
	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
	
	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;
	
	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;
	
	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
	
	    var momentPrototype = momentPrototype__proto;
	
	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }
	
	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }
	
	    function preParsePostFormat (string) {
	        return string;
	    }
	
	    var prototype__proto = Locale.prototype;
	
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;
	
	    // Month
	    prototype__proto.months            =        localeMonths;
	    prototype__proto.monthsShort       =        localeMonthsShort;
	    prototype__proto.monthsParse       =        localeMonthsParse;
	    prototype__proto.monthsRegex       = monthsRegex;
	    prototype__proto.monthsShortRegex  = monthsShortRegex;
	
	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
	
	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;
	
	    prototype__proto.weekdaysRegex       =        weekdaysRegex;
	    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
	    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;
	
	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto.meridiem = localeMeridiem;
	
	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }
	
	    function listMonthsImpl (format, index, field) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	
	        if (index != null) {
	            return lists__get(format, index, field, 'month');
	        }
	
	        var i;
	        var out = [];
	        for (i = 0; i < 12; i++) {
	            out[i] = lists__get(format, i, field, 'month');
	        }
	        return out;
	    }
	
	    // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)
	    function listWeekdaysImpl (localeSorted, format, index, field) {
	        if (typeof localeSorted === 'boolean') {
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }
	
	            format = format || '';
	        } else {
	            format = localeSorted;
	            index = format;
	            localeSorted = false;
	
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }
	
	            format = format || '';
	        }
	
	        var locale = locale_locales__getLocale(),
	            shift = localeSorted ? locale._week.dow : 0;
	
	        if (index != null) {
	            return lists__get(format, (index + shift) % 7, field, 'day');
	        }
	
	        var i;
	        var out = [];
	        for (i = 0; i < 7; i++) {
	            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
	        }
	        return out;
	    }
	
	    function lists__listMonths (format, index) {
	        return listMonthsImpl(format, index, 'months');
	    }
	
	    function lists__listMonthsShort (format, index) {
	        return listMonthsImpl(format, index, 'monthsShort');
	    }
	
	    function lists__listWeekdays (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }
	
	    function lists__listWeekdaysShort (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }
	
	    function lists__listWeekdaysMin (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }
	
	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
	
	    var mathAbs = Math.abs;
	
	    function duration_abs__abs () {
	        var data           = this._data;
	
	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);
	
	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);
	
	        return this;
	    }
	
	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);
	
	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;
	
	        return duration._bubble();
	    }
	
	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }
	
	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }
	
	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }
	
	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;
	
	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }
	
	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;
	
	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;
	
	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;
	
	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;
	
	        days += absFloor(hours / 24);
	
	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));
	
	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;
	
	        data.days   = days;
	        data.months = months;
	        data.years  = years;
	
	        return this;
	    }
	
	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }
	
	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }
	
	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;
	
	        units = normalizeUnits(units);
	
	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }
	
	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }
	
	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }
	
	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');
	
	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }
	
	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }
	
	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');
	
	    function weeks () {
	        return absFloor(this.days() / 7);
	    }
	
	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));
	
	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes <= 1           && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   <= 1           && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    <= 1           && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  <= 1           && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   <= 1           && ['y']           || ['yy', years];
	
	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }
	
	    // This function allows you to set the rounding function for relative time strings
	    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
	        if (roundingFunction === undefined) {
	            return round;
	        }
	        if (typeof(roundingFunction) === 'function') {
	            round = roundingFunction;
	            return true;
	        }
	        return false;
	    }
	
	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }
	
	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
	
	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }
	
	        return locale.postformat(output);
	    }
	
	    var iso_string__abs = Math.abs;
	
	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;
	
	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;
	
	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;
	
	
	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();
	
	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }
	
	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }
	
	    var duration_prototype__proto = Duration.prototype;
	
	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;
	
	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;
	
	    // Side effect imports
	
	    // FORMATTING
	
	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');
	
	    // PARSING
	
	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });
	
	    // Side effect imports
	
	
	    utils_hooks__hooks.version = '2.14.1';
	
	    setHookCallback(local__createLocal);
	
	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.now                   = now;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.updateLocale          = updateLocale;
	    utils_hooks__hooks.locales               = locale_locales__listLocales;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
	    utils_hooks__hooks.prototype             = momentPrototype;
	
	    var _moment = utils_hooks__hooks;
	
	    return _moment;
	
	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)(module)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 80,
		"./af.js": 80,
		"./ar": 81,
		"./ar-ma": 82,
		"./ar-ma.js": 82,
		"./ar-sa": 83,
		"./ar-sa.js": 83,
		"./ar-tn": 84,
		"./ar-tn.js": 84,
		"./ar.js": 81,
		"./az": 85,
		"./az.js": 85,
		"./be": 86,
		"./be.js": 86,
		"./bg": 87,
		"./bg.js": 87,
		"./bn": 88,
		"./bn.js": 88,
		"./bo": 89,
		"./bo.js": 89,
		"./br": 90,
		"./br.js": 90,
		"./bs": 91,
		"./bs.js": 91,
		"./ca": 92,
		"./ca.js": 92,
		"./cs": 93,
		"./cs.js": 93,
		"./cv": 94,
		"./cv.js": 94,
		"./cy": 95,
		"./cy.js": 95,
		"./da": 96,
		"./da.js": 96,
		"./de": 97,
		"./de-at": 98,
		"./de-at.js": 98,
		"./de.js": 97,
		"./dv": 99,
		"./dv.js": 99,
		"./el": 100,
		"./el.js": 100,
		"./en-au": 101,
		"./en-au.js": 101,
		"./en-ca": 102,
		"./en-ca.js": 102,
		"./en-gb": 103,
		"./en-gb.js": 103,
		"./en-ie": 104,
		"./en-ie.js": 104,
		"./en-nz": 105,
		"./en-nz.js": 105,
		"./eo": 106,
		"./eo.js": 106,
		"./es": 107,
		"./es-do": 108,
		"./es-do.js": 108,
		"./es.js": 107,
		"./et": 109,
		"./et.js": 109,
		"./eu": 110,
		"./eu.js": 110,
		"./fa": 111,
		"./fa.js": 111,
		"./fi": 112,
		"./fi.js": 112,
		"./fo": 113,
		"./fo.js": 113,
		"./fr": 114,
		"./fr-ca": 115,
		"./fr-ca.js": 115,
		"./fr-ch": 116,
		"./fr-ch.js": 116,
		"./fr.js": 114,
		"./fy": 117,
		"./fy.js": 117,
		"./gd": 118,
		"./gd.js": 118,
		"./gl": 119,
		"./gl.js": 119,
		"./he": 120,
		"./he.js": 120,
		"./hi": 121,
		"./hi.js": 121,
		"./hr": 122,
		"./hr.js": 122,
		"./hu": 123,
		"./hu.js": 123,
		"./hy-am": 124,
		"./hy-am.js": 124,
		"./id": 125,
		"./id.js": 125,
		"./is": 126,
		"./is.js": 126,
		"./it": 127,
		"./it.js": 127,
		"./ja": 128,
		"./ja.js": 128,
		"./jv": 129,
		"./jv.js": 129,
		"./ka": 130,
		"./ka.js": 130,
		"./kk": 131,
		"./kk.js": 131,
		"./km": 132,
		"./km.js": 132,
		"./ko": 133,
		"./ko.js": 133,
		"./ky": 134,
		"./ky.js": 134,
		"./lb": 135,
		"./lb.js": 135,
		"./lo": 136,
		"./lo.js": 136,
		"./lt": 137,
		"./lt.js": 137,
		"./lv": 138,
		"./lv.js": 138,
		"./me": 139,
		"./me.js": 139,
		"./mk": 140,
		"./mk.js": 140,
		"./ml": 141,
		"./ml.js": 141,
		"./mr": 142,
		"./mr.js": 142,
		"./ms": 143,
		"./ms-my": 144,
		"./ms-my.js": 144,
		"./ms.js": 143,
		"./my": 145,
		"./my.js": 145,
		"./nb": 146,
		"./nb.js": 146,
		"./ne": 147,
		"./ne.js": 147,
		"./nl": 148,
		"./nl.js": 148,
		"./nn": 149,
		"./nn.js": 149,
		"./pa-in": 150,
		"./pa-in.js": 150,
		"./pl": 151,
		"./pl.js": 151,
		"./pt": 152,
		"./pt-br": 153,
		"./pt-br.js": 153,
		"./pt.js": 152,
		"./ro": 154,
		"./ro.js": 154,
		"./ru": 155,
		"./ru.js": 155,
		"./se": 156,
		"./se.js": 156,
		"./si": 157,
		"./si.js": 157,
		"./sk": 158,
		"./sk.js": 158,
		"./sl": 159,
		"./sl.js": 159,
		"./sq": 160,
		"./sq.js": 160,
		"./sr": 161,
		"./sr-cyrl": 162,
		"./sr-cyrl.js": 162,
		"./sr.js": 161,
		"./ss": 163,
		"./ss.js": 163,
		"./sv": 164,
		"./sv.js": 164,
		"./sw": 165,
		"./sw.js": 165,
		"./ta": 166,
		"./ta.js": 166,
		"./te": 167,
		"./te.js": 167,
		"./th": 168,
		"./th.js": 168,
		"./tl-ph": 169,
		"./tl-ph.js": 169,
		"./tlh": 170,
		"./tlh.js": 170,
		"./tr": 171,
		"./tr.js": 171,
		"./tzl": 172,
		"./tzl.js": 172,
		"./tzm": 173,
		"./tzm-latn": 174,
		"./tzm-latn.js": 174,
		"./tzm.js": 173,
		"./uk": 175,
		"./uk.js": 175,
		"./uz": 176,
		"./uz.js": 176,
		"./vi": 177,
		"./vi.js": 177,
		"./x-pseudo": 178,
		"./x-pseudo.js": 178,
		"./zh-cn": 179,
		"./zh-cn.js": 179,
		"./zh-tw": 180,
		"./zh-tw.js": 180
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 79;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var af = moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Môre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });
	
	    return af;
	
	}));

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! changes in months, weekdays: Ahmed Elkhatib
	//! Native plural forms: forabi https://github.com/forabi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        'كانون الثاني يناير',
	        'شباط فبراير',
	        'آذار مارس',
	        'نيسان أبريل',
	        'أيار مايو',
	        'حزيران يونيو',
	        'تموز يوليو',
	        'آب أغسطس',
	        'أيلول سبتمبر',
	        'تشرين الأول أكتوبر',
	        'تشرين الثاني نوفمبر',
	        'كانون الأول ديسمبر'
	    ];
	
	    var ar = moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم عند الساعة] LT',
	            nextDay: '[غدًا عند الساعة] LT',
	            nextWeek: 'dddd [عند الساعة] LT',
	            lastDay: '[أمس عند الساعة] LT',
	            lastWeek: 'dddd [عند الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'بعد %s',
	            past : 'منذ %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar;
	
	}));

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ar_ma = moment.defineLocale('ar-ma', {
	        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar_ma;
	
	}));

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    };
	
	    var ar_sa = moment.defineLocale('ar-sa', {
	        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        preparse: function (string) {
	            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar_sa;
	
	}));

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ar_tn = moment.defineLocale('ar-tn', {
	        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'في %s',
	            past: 'منذ %s',
	            s: 'ثوان',
	            m: 'دقيقة',
	            mm: '%d دقائق',
	            h: 'ساعة',
	            hh: '%d ساعات',
	            d: 'يوم',
	            dd: '%d أيام',
	            M: 'شهر',
	            MM: '%d أشهر',
	            y: 'سنة',
	            yy: '%d سنوات'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ar_tn;
	
	}));

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	        3: '-üncü',
	        4: '-üncü',
	        100: '-üncü',
	        6: '-ncı',
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	        60: '-ıncı',
	        90: '-ıncı'
	    };
	
	    var az = moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gələn həftə] dddd [saat] LT',
	            lastDay : '[dünən] LT',
	            lastWeek : '[keçən həftə] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s əvvəl',
	            s : 'birneçə saniyyə',
	            m : 'bir dəqiqə',
	            mm : '%d dəqiqə',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gecə|səhər|gündüz|axşam/,
	        isPM : function (input) {
	            return /^(gündüz|axşam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gecə';
	            } else if (hour < 12) {
	                return 'səhər';
	            } else if (hour < 17) {
	                return 'gündüz';
	            } else {
	                return 'axşam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return az;
	
	}));

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	            'dd': 'дзень_дні_дзён',
	            'MM': 'месяц_месяцы_месяцаў',
	            'yy': 'год_гады_гадоў'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвіліна' : 'хвіліну';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'гадзіна' : 'гадзіну';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	
	    var be = moment.defineLocale('be', {
	        months : {
	            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
	            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
	        },
	        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	        weekdays : {
	            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
	            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	            isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	        },
	        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сёння ў] LT',
	            nextDay: '[Заўтра ў] LT',
	            lastDay: '[Учора ў] LT',
	            nextWeek: function () {
	                return '[У] dddd [ў] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[У мінулую] dddd [ў] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[У мінулы] dddd [ў] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'праз %s',
	            past : '%s таму',
	            s : 'некалькі секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : 'дзень',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночы|раніцы|дня|вечара/,
	        isPM : function (input) {
	            return /^(дня|вечара)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночы';
	            } else if (hour < 12) {
	                return 'раніцы';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечара';
	            }
	        },
	        ordinalParse: /\d{1,2}-(і|ы|га)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                case 'w':
	                case 'W':
	                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	                case 'D':
	                    return number + '-га';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return be;
	
	}));

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var bg = moment.defineLocale('bg', {
	        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Днес в] LT',
	            nextDay : '[Утре в] LT',
	            nextWeek : 'dddd [в] LT',
	            lastDay : '[Вчера в] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 6:
	                        return '[В изминалата] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[В изминалия] dddd [в] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'след %s',
	            past : 'преди %s',
	            s : 'няколко секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дни',
	            M : 'месец',
	            MM : '%d месеца',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bg;
	
	}));

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '১',
	        '2': '২',
	        '3': '৩',
	        '4': '৪',
	        '5': '৫',
	        '6': '৬',
	        '7': '৭',
	        '8': '৮',
	        '9': '৯',
	        '0': '০'
	    },
	    numberMap = {
	        '১': '1',
	        '২': '2',
	        '৩': '3',
	        '৪': '4',
	        '৫': '5',
	        '৬': '6',
	        '৭': '7',
	        '৮': '8',
	        '৯': '9',
	        '০': '0'
	    };
	
	    var bn = moment.defineLocale('bn', {
	        months : 'জানুয়ারী_ফেবুয়ারী_মার্চ_এপ্রিল_মে_জুন_জুলাই_অগাস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	        monthsShort : 'জানু_ফেব_মার্চ_এপর_মে_জুন_জুল_অগ_সেপ্ট_অক্টো_নভ_ডিসেম্'.split('_'),
	        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পত্তিবার_শুক্রবার_শনিবার'.split('_'),
	        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পত্তি_শুক্র_শনি'.split('_'),
	        weekdaysMin : 'রব_সম_মঙ্গ_বু_ব্রিহ_শু_শনি'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm সময়',
	            LTS : 'A h:mm:ss সময়',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm সময়',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
	        },
	        calendar : {
	            sameDay : '[আজ] LT',
	            nextDay : '[আগামীকাল] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[গতকাল] LT',
	            lastWeek : '[গত] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s পরে',
	            past : '%s আগে',
	            s : 'কয়েক সেকেন্ড',
	            m : 'এক মিনিট',
	            mm : '%d মিনিট',
	            h : 'এক ঘন্টা',
	            hh : '%d ঘন্টা',
	            d : 'এক দিন',
	            dd : '%d দিন',
	            M : 'এক মাস',
	            MM : '%d মাস',
	            y : 'এক বছর',
	            yy : '%d বছর'
	        },
	        preparse: function (string) {
	            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === 'রাত' && hour >= 4) ||
	                    (meridiem === 'দুপুর' && hour < 5) ||
	                    meridiem === 'বিকাল') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'রাত';
	            } else if (hour < 10) {
	                return 'সকাল';
	            } else if (hour < 17) {
	                return 'দুপুর';
	            } else if (hour < 20) {
	                return 'বিকাল';
	            } else {
	                return 'রাত';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bn;
	
	}));

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '༡',
	        '2': '༢',
	        '3': '༣',
	        '4': '༤',
	        '5': '༥',
	        '6': '༦',
	        '7': '༧',
	        '8': '༨',
	        '9': '༩',
	        '0': '༠'
	    },
	    numberMap = {
	        '༡': '1',
	        '༢': '2',
	        '༣': '3',
	        '༤': '4',
	        '༥': '5',
	        '༦': '6',
	        '༧': '7',
	        '༨': '8',
	        '༩': '9',
	        '༠': '0'
	    };
	
	    var bo = moment.defineLocale('bo', {
	        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[དི་རིང] LT',
	            nextDay : '[སང་ཉིན] LT',
	            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	            lastDay : '[ཁ་སང] LT',
	            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ལ་',
	            past : '%s སྔན་ལ',
	            s : 'ལམ་སང',
	            m : 'སྐར་མ་གཅིག',
	            mm : '%d སྐར་མ',
	            h : 'ཆུ་ཚོད་གཅིག',
	            hh : '%d ཆུ་ཚོད',
	            d : 'ཉིན་གཅིག',
	            dd : '%d ཉིན་',
	            M : 'ཟླ་བ་གཅིག',
	            MM : '%d ཟླ་བ',
	            y : 'ལོ་གཅིག',
	            yy : '%d ལོ'
	        },
	        preparse: function (string) {
	            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
	                    (meridiem === 'ཉིན་གུང' && hour < 5) ||
	                    meridiem === 'དགོང་དག') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'མཚན་མོ';
	            } else if (hour < 10) {
	                return 'ཞོགས་ཀས';
	            } else if (hour < 17) {
	                return 'ཉིན་གུང';
	            } else if (hour < 20) {
	                return 'དགོང་དག';
	            } else {
	                return 'མཚན་མོ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bo;
	
	}));

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	            case 1:
	            case 3:
	            case 4:
	            case 5:
	            case 9:
	                return number + ' bloaz';
	            default:
	                return number + ' vloaz';
	        }
	    }
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }
	
	    var br = moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondennoù',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(añ|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'añ' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return br;
	
	}));

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Marković
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	            case 'mm':
	                if (number === 1) {
	                    result += 'minuta';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'minute';
	                } else {
	                    result += 'minuta';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'jedan sat' : 'jednog sata';
	            case 'hh':
	                if (number === 1) {
	                    result += 'sat';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'sata';
	                } else {
	                    result += 'sati';
	                }
	                return result;
	            case 'dd':
	                if (number === 1) {
	                    result += 'dan';
	                } else {
	                    result += 'dana';
	                }
	                return result;
	            case 'MM':
	                if (number === 1) {
	                    result += 'mjesec';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'mjeseca';
	                } else {
	                    result += 'mjeseci';
	                }
	                return result;
	            case 'yy':
	                if (number === 1) {
	                    result += 'godina';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'godine';
	                } else {
	                    result += 'godina';
	                }
	                return result;
	        }
	    }
	
	    var bs = moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                        return '[prošlu] dddd [u] LT';
	                    case 6:
	                        return '[prošle] [subote] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bs;
	
	}));

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ca = moment.defineLocale('ca', {
	        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : 'è';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ca;
	
	}));

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':  // a few seconds / in a few seconds / a few seconds ago
	                return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	            case 'm':  // a minute / in a minute / a minute ago
	                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'minuty' : 'minut');
	                } else {
	                    return result + 'minutami';
	                }
	                break;
	            case 'h':  // an hour / in an hour / an hour ago
	                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	            case 'hh': // 9 hours / in 9 hours / 9 hours ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'hodiny' : 'hodin');
	                } else {
	                    return result + 'hodinami';
	                }
	                break;
	            case 'd':  // a day / in a day / a day ago
	                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	            case 'dd': // 9 days / in 9 days / 9 days ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'dny' : 'dní');
	                } else {
	                    return result + 'dny';
	                }
	                break;
	            case 'M':  // a month / in a month / a month ago
	                return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	            case 'MM': // 9 months / in 9 months / 9 months ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'měsíce' : 'měsíců');
	                } else {
	                    return result + 'měsíci';
	                }
	                break;
	            case 'y':  // a year / in a year / a year ago
	                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	            case 'yy': // 9 years / in 9 years / 9 years ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'roky' : 'let');
	                } else {
	                    return result + 'lety';
	                }
	                break;
	        }
	    }
	
	    var cs = moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        shortMonthsParse : (function (monthsShort) {
	            var i, _shortMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	            }
	            return _shortMonthsParse;
	        }(monthsShort)),
	        longMonthsParse : (function (months) {
	            var i, _longMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	            }
	            return _longMonthsParse;
	        }(months)),
	        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm',
	            l : 'D. M. YYYY'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[zítra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v neděli v] LT';
	                    case 1:
	                    case 2:
	                        return '[v] dddd [v] LT';
	                    case 3:
	                        return '[ve středu v] LT';
	                    case 4:
	                        return '[ve čtvrtek v] LT';
	                    case 5:
	                        return '[v pátek v] LT';
	                    case 6:
	                        return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[včera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[minulou neděli v] LT';
	                    case 1:
	                    case 2:
	                        return '[minulé] dddd [v] LT';
	                    case 3:
	                        return '[minulou středu v] LT';
	                    case 4:
	                    case 5:
	                        return '[minulý] dddd [v] LT';
	                    case 6:
	                        return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'před %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return cs;
	
	}));

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var cv = moment.defineLocale('cv', {
	        months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
	        monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
	        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
	        weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
	        weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
	            LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
	            LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
	        },
	        calendar : {
	            sameDay: '[Паян] LT [сехетре]',
	            nextDay: '[Ыран] LT [сехетре]',
	            lastDay: '[Ӗнер] LT [сехетре]',
	            nextWeek: '[Ҫитес] dddd LT [сехетре]',
	            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
	                return output + affix;
	            },
	            past : '%s каялла',
	            s : 'пӗр-ик ҫеккунт',
	            m : 'пӗр минут',
	            mm : '%d минут',
	            h : 'пӗр сехет',
	            hh : '%d сехет',
	            d : 'пӗр кун',
	            dd : '%d кун',
	            M : 'пӗр уйӑх',
	            MM : '%d уйӑх',
	            y : 'пӗр ҫул',
	            yy : '%d ҫул'
	        },
	        ordinalParse: /\d{1,2}-мӗш/,
	        ordinal : '%d-мӗш',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return cv;
	
	}));

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var cy = moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        weekdaysParseExact : true,
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn ôl',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return cy;
	
	}));

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var da = moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I går kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'få sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'et år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return da;
	
	}));

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    var de = moment.defineLocale('de', {
	        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return de;
	
	}));

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    var de_at = moment.defineLocale('de-at', {
	        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return de_at;
	
	}));

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = [
	        'ޖެނުއަރީ',
	        'ފެބްރުއަރީ',
	        'މާރިޗު',
	        'އޭޕްރީލު',
	        'މޭ',
	        'ޖޫން',
	        'ޖުލައި',
	        'އޯގަސްޓު',
	        'ސެޕްޓެމްބަރު',
	        'އޮކްޓޯބަރު',
	        'ނޮވެމްބަރު',
	        'ޑިސެމްބަރު'
	    ], weekdays = [
	        'އާދިއްތަ',
	        'ހޯމަ',
	        'އަންގާރަ',
	        'ބުދަ',
	        'ބުރާސްފަތި',
	        'ހުކުރު',
	        'ހޮނިހިރު'
	    ];
	
	    var dv = moment.defineLocale('dv', {
	        months : months,
	        monthsShort : months,
	        weekdays : weekdays,
	        weekdaysShort : weekdays,
	        weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
	        longDateFormat : {
	
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/M/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /މކ|މފ/,
	        isPM : function (input) {
	            return 'މފ' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'މކ';
	            } else {
	                return 'މފ';
	            }
	        },
	        calendar : {
	            sameDay : '[މިއަދު] LT',
	            nextDay : '[މާދަމާ] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[އިއްޔެ] LT',
	            lastWeek : '[ފާއިތުވި] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ތެރޭގައި %s',
	            past : 'ކުރިން %s',
	            s : 'ސިކުންތުކޮޅެއް',
	            m : 'މިނިޓެއް',
	            mm : 'މިނިޓު %d',
	            h : 'ގަޑިއިރެއް',
	            hh : 'ގަޑިއިރު %d',
	            d : 'ދުވަހެއް',
	            dd : 'ދުވަސް %d',
	            M : 'މަހެއް',
	            MM : 'މަސް %d',
	            y : 'އަހަރެއް',
	            yy : 'އަހަރު %d'
	        },
	        preparse: function (string) {
	            return string.replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/,/g, '،');
	        },
	        week : {
	            dow : 7,  // Sunday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return dv;
	
	}));

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }
	
	
	    var el = moment.defineLocale('el', {
	        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'μμ' : 'ΜΜ';
	            } else {
	                return isLower ? 'πμ' : 'ΠΜ';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === 'μ');
	        },
	        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendarEl : {
	            sameDay : '[Σήμερα {}] LT',
	            nextDay : '[Αύριο {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[Χθες {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[το προηγούμενο] dddd [{}] LT';
	                    default:
	                        return '[την προηγούμενη] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	            if (isFunction(output)) {
	                output = output.apply(mom);
	            }
	            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	        },
	        relativeTime : {
	            future : 'σε %s',
	            past : '%s πριν',
	            s : 'λίγα δευτερόλεπτα',
	            m : 'ένα λεπτό',
	            mm : '%d λεπτά',
	            h : 'μία ώρα',
	            hh : '%d ώρες',
	            d : 'μία μέρα',
	            dd : '%d μέρες',
	            M : 'ένας μήνας',
	            MM : '%d μήνες',
	            y : 'ένας χρόνος',
	            yy : '%d χρόνια'
	        },
	        ordinalParse: /\d{1,2}η/,
	        ordinal: '%dη',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });
	
	    return el;
	
	}));

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_au = moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_au;
	
	}));

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_ca = moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY h:mm A',
	            LLLL : 'dddd, MMMM D, YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    return en_ca;
	
	}));

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_gb = moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_gb;
	
	}));

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_ie = moment.defineLocale('en-ie', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_ie;
	
	}));

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_nz = moment.defineLocale('en-nz', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_nz;
	
	}));

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var eo = moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY HH:mm',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodiaŭ je] LT',
	            nextDay : '[Morgaŭ je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hieraŭ je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'antaŭ %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return eo;
	
	}));

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napurí : https://github.com/julionc
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	    var es = moment.defineLocale('es', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return es;
	
	}));

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	    var es_do = moment.defineLocale('es-do', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY h:mm A',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return es_do;
	
	}));

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	            'm' : ['ühe minuti', 'üks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['ühe päeva', 'üks päev'],
	            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }
	
	    var et = moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'H:mm:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[Täna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Järgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pärast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d päeva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return et;
	
	}));

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var eu = moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] HH:mm',
	            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return eu;
	
	}));

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '۱',
	        '2': '۲',
	        '3': '۳',
	        '4': '۴',
	        '5': '۵',
	        '6': '۶',
	        '7': '۷',
	        '8': '۸',
	        '9': '۹',
	        '0': '۰'
	    }, numberMap = {
	        '۱': '1',
	        '۲': '2',
	        '۳': '3',
	        '۴': '4',
	        '۵': '5',
	        '۶': '6',
	        '۷': '7',
	        '۸': '8',
	        '۹': '9',
	        '۰': '0'
	    };
	
	    var fa = moment.defineLocale('fa', {
	        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /قبل از ظهر|بعد از ظهر/,
	        isPM: function (input) {
	            return /بعد از ظهر/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'قبل از ظهر';
	            } else {
	                return 'بعد از ظهر';
	            }
	        },
	        calendar : {
	            sameDay : '[امروز ساعت] LT',
	            nextDay : '[فردا ساعت] LT',
	            nextWeek : 'dddd [ساعت] LT',
	            lastDay : '[دیروز ساعت] LT',
	            lastWeek : 'dddd [پیش] [ساعت] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'در %s',
	            past : '%s پیش',
	            s : 'چندین ثانیه',
	            m : 'یک دقیقه',
	            mm : '%d دقیقه',
	            h : 'یک ساعت',
	            hh : '%d ساعت',
	            d : 'یک روز',
	            dd : '%d روز',
	            M : 'یک ماه',
	            MM : '%d ماه',
	            y : 'یک سال',
	            yy : '%d سال'
	        },
	        preparse: function (string) {
	            return string.replace(/[۰-۹]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        ordinalParse: /\d{1,2}م/,
	        ordinal : '%dم',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return fa;
	
	}));

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	            case 's':
	                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	            case 'm':
	                return isFuture ? 'minuutin' : 'minuutti';
	            case 'mm':
	                result = isFuture ? 'minuutin' : 'minuuttia';
	                break;
	            case 'h':
	                return isFuture ? 'tunnin' : 'tunti';
	            case 'hh':
	                result = isFuture ? 'tunnin' : 'tuntia';
	                break;
	            case 'd':
	                return isFuture ? 'päivän' : 'päivä';
	            case 'dd':
	                result = isFuture ? 'päivän' : 'päivää';
	                break;
	            case 'M':
	                return isFuture ? 'kuukauden' : 'kuukausi';
	            case 'MM':
	                result = isFuture ? 'kuukauden' : 'kuukautta';
	                break;
	            case 'y':
	                return isFuture ? 'vuoden' : 'vuosi';
	            case 'yy':
	                result = isFuture ? 'vuoden' : 'vuotta';
	                break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }
	
	    var fi = moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] HH.mm',
	            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	        },
	        calendar : {
	            sameDay : '[tänään] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s päästä',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fi;
	
	}));

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fo = moment.defineLocale('fo', {
	        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D. MMMM, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Í dag kl.] LT',
	            nextDay : '[Í morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[Í gjár kl.] LT',
	            lastWeek : '[síðstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s síðani',
	            s : 'fá sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tími',
	            hh : '%d tímar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mánaði',
	            MM : '%d mánaðir',
	            y : 'eitt ár',
	            yy : '%d ár'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fo;
	
	}));

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr = moment.defineLocale('fr', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fr;
	
	}));

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr_ca = moment.defineLocale('fr-ca', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        }
	    });
	
	    return fr_ca;
	
	}));

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr_ch = moment.defineLocale('fr-ch', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fr_ch;
	
	}));

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
	
	    var fy = moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[ôfrûne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien minút',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fy;
	
	}));

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = [
	        'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
	    ];
	
	    var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];
	
	    var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
	
	    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
	
	    var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];
	
	    var gd = moment.defineLocale('gd', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParseExact : true,
	        weekdays : weekdays,
	        weekdaysShort : weekdaysShort,
	        weekdaysMin : weekdaysMin,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[An-diugh aig] LT',
	            nextDay : '[A-màireach aig] LT',
	            nextWeek : 'dddd [aig] LT',
	            lastDay : '[An-dè aig] LT',
	            lastWeek : 'dddd [seo chaidh] [aig] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ann an %s',
	            past : 'bho chionn %s',
	            s : 'beagan diogan',
	            m : 'mionaid',
	            mm : '%d mionaidean',
	            h : 'uair',
	            hh : '%d uairean',
	            d : 'latha',
	            dd : '%d latha',
	            M : 'mìos',
	            MM : '%d mìosan',
	            y : 'bliadhna',
	            yy : '%d bliadhna'
	        },
	        ordinalParse : /\d{1,2}(d|na|mh)/,
	        ordinal : function (number) {
	            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return gd;
	
	}));

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var gl = moment.defineLocale('gl', {
	        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
	        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mér._Xov._Ven._Sáb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mé_Xo_Ve_Sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str === 'uns segundos') {
	                    return 'nuns segundos';
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return gl;
	
	}));

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var he = moment.defineLocale('he', {
	        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [ב]MMMM YYYY',
	            LLL : 'D [ב]MMMM YYYY HH:mm',
	            LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[היום ב־]LT',
	            nextDay : '[מחר ב־]LT',
	            nextWeek : 'dddd [בשעה] LT',
	            lastDay : '[אתמול ב־]LT',
	            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'בעוד %s',
	            past : 'לפני %s',
	            s : 'מספר שניות',
	            m : 'דקה',
	            mm : '%d דקות',
	            h : 'שעה',
	            hh : function (number) {
	                if (number === 2) {
	                    return 'שעתיים';
	                }
	                return number + ' שעות';
	            },
	            d : 'יום',
	            dd : function (number) {
	                if (number === 2) {
	                    return 'יומיים';
	                }
	                return number + ' ימים';
	            },
	            M : 'חודש',
	            MM : function (number) {
	                if (number === 2) {
	                    return 'חודשיים';
	                }
	                return number + ' חודשים';
	            },
	            y : 'שנה',
	            yy : function (number) {
	                if (number === 2) {
	                    return 'שנתיים';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' שנה';
	                }
	                return number + ' שנים';
	            }
	        },
	        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
	        isPM : function (input) {
	            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 5) {
	                return 'לפנות בוקר';
	            } else if (hour < 10) {
	                return 'בבוקר';
	            } else if (hour < 12) {
	                return isLower ? 'לפנה"צ' : 'לפני הצהריים';
	            } else if (hour < 18) {
	                return isLower ? 'אחה"צ' : 'אחרי הצהריים';
	            } else {
	                return 'בערב';
	            }
	        }
	    });
	
	    return he;
	
	}));

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var hi = moment.defineLocale('hi', {
	        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm बजे',
	            LTS : 'A h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[कल] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[कल] LT',
	            lastWeek : '[पिछले] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s में',
	            past : '%s पहले',
	            s : 'कुछ ही क्षण',
	            m : 'एक मिनट',
	            mm : '%d मिनट',
	            h : 'एक घंटा',
	            hh : '%d घंटे',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महीने',
	            MM : '%d महीने',
	            y : 'एक वर्ष',
	            yy : '%d वर्ष'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /रात|सुबह|दोपहर|शाम/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सुबह') {
	                return hour;
	            } else if (meridiem === 'दोपहर') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'शाम') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात';
	            } else if (hour < 10) {
	                return 'सुबह';
	            } else if (hour < 17) {
	                return 'दोपहर';
	            } else if (hour < 20) {
	                return 'शाम';
	            } else {
	                return 'रात';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hi;
	
	}));

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Marković : https://github.com/bmarkovic
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	            case 'mm':
	                if (number === 1) {
	                    result += 'minuta';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'minute';
	                } else {
	                    result += 'minuta';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'jedan sat' : 'jednog sata';
	            case 'hh':
	                if (number === 1) {
	                    result += 'sat';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'sata';
	                } else {
	                    result += 'sati';
	                }
	                return result;
	            case 'dd':
	                if (number === 1) {
	                    result += 'dan';
	                } else {
	                    result += 'dana';
	                }
	                return result;
	            case 'MM':
	                if (number === 1) {
	                    result += 'mjesec';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'mjeseca';
	                } else {
	                    result += 'mjeseci';
	                }
	                return result;
	            case 'yy':
	                if (number === 1) {
	                    result += 'godina';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'godine';
	                } else {
	                    result += 'godina';
	                }
	                return result;
	        }
	    }
	
	    var hr = moment.defineLocale('hr', {
	        months : {
	            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	        },
	        monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                        return '[prošlu] dddd [u] LT';
	                    case 6:
	                        return '[prošle] [subote] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hr;
	
	}));

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	        switch (key) {
	            case 's':
	                return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	            case 'm':
	                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	            case 'mm':
	                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	            case 'h':
	                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	            case 'hh':
	                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	            case 'd':
	                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	            case 'dd':
	                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	            case 'M':
	                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	            case 'MM':
	                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	            case 'y':
	                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	            case 'yy':
	                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	        }
	        return '';
	    }
	    function week(isFuture) {
	        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }
	
	    var hu = moment.defineLocale('hu', {
	        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D. H:mm',
	            LLLL : 'YYYY. MMMM D., dddd H:mm'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s múlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hu;
	
	}));

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var hy_am = moment.defineLocale('hy-am', {
	        months : {
	            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
	            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
	        },
	        monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
	        weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
	        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY թ.',
	            LLL : 'D MMMM YYYY թ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[այսօր] LT',
	            nextDay: '[վաղը] LT',
	            lastDay: '[երեկ] LT',
	            nextWeek: function () {
	                return 'dddd [օրը ժամը] LT';
	            },
	            lastWeek: function () {
	                return '[անցած] dddd [օրը ժամը] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s հետո',
	            past : '%s առաջ',
	            s : 'մի քանի վայրկյան',
	            m : 'րոպե',
	            mm : '%d րոպե',
	            h : 'ժամ',
	            hh : '%d ժամ',
	            d : 'օր',
	            dd : '%d օր',
	            M : 'ամիս',
	            MM : '%d ամիս',
	            y : 'տարի',
	            yy : '%d տարի'
	        },
	        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	        isPM: function (input) {
	            return /^(ցերեկվա|երեկոյան)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return 'գիշերվա';
	            } else if (hour < 12) {
	                return 'առավոտվա';
	            } else if (hour < 17) {
	                return 'ցերեկվա';
	            } else {
	                return 'երեկոյան';
	            }
	        },
	        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'DDD':
	                case 'w':
	                case 'W':
	                case 'DDDo':
	                    if (number === 1) {
	                        return number + '-ին';
	                    }
	                    return number + '-րդ';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hy_am;
	
	}));

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var id = moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return id;
	
	}));

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':
	                return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	            case 'm':
	                return withoutSuffix ? 'mínúta' : 'mínútu';
	            case 'mm':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	                } else if (withoutSuffix) {
	                    return result + 'mínúta';
	                }
	                return result + 'mínútu';
	            case 'hh':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	                }
	                return result + 'klukkustund';
	            case 'd':
	                if (withoutSuffix) {
	                    return 'dagur';
	                }
	                return isFuture ? 'dag' : 'degi';
	            case 'dd':
	                if (plural(number)) {
	                    if (withoutSuffix) {
	                        return result + 'dagar';
	                    }
	                    return result + (isFuture ? 'daga' : 'dögum');
	                } else if (withoutSuffix) {
	                    return result + 'dagur';
	                }
	                return result + (isFuture ? 'dag' : 'degi');
	            case 'M':
	                if (withoutSuffix) {
	                    return 'mánuður';
	                }
	                return isFuture ? 'mánuð' : 'mánuði';
	            case 'MM':
	                if (plural(number)) {
	                    if (withoutSuffix) {
	                        return result + 'mánuðir';
	                    }
	                    return result + (isFuture ? 'mánuði' : 'mánuðum');
	                } else if (withoutSuffix) {
	                    return result + 'mánuður';
	                }
	                return result + (isFuture ? 'mánuð' : 'mánuði');
	            case 'y':
	                return withoutSuffix || isFuture ? 'ár' : 'ári';
	            case 'yy':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	                }
	                return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	        }
	    }
	
	    var is = moment.defineLocale('is', {
	        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	        },
	        calendar : {
	            sameDay : '[í dag kl.] LT',
	            nextDay : '[á morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[í gær kl.] LT',
	            lastWeek : '[síðasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s síðan',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return is;
	
	}));

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var it = moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal: '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return it;
	
	}));

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ja = moment.defineLocale('ja', {
	        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	        longDateFormat : {
	            LT : 'Ah時m分',
	            LTS : 'Ah時m分s秒',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY年M月D日',
	            LLL : 'YYYY年M月D日Ah時m分',
	            LLLL : 'YYYY年M月D日Ah時m分 dddd'
	        },
	        meridiemParse: /午前|午後/i,
	        isPM : function (input) {
	            return input === '午後';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '午前';
	            } else {
	                return '午後';
	            }
	        },
	        calendar : {
	            sameDay : '[今日] LT',
	            nextDay : '[明日] LT',
	            nextWeek : '[来週]dddd LT',
	            lastDay : '[昨日] LT',
	            lastWeek : '[前週]dddd LT',
	            sameElse : 'L'
	        },
	        ordinalParse : /\d{1,2}日/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd':
	                case 'D':
	                case 'DDD':
	                    return number + '日';
	                default:
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s後',
	            past : '%s前',
	            s : '数秒',
	            m : '1分',
	            mm : '%d分',
	            h : '1時間',
	            hh : '%d時間',
	            d : '1日',
	            dd : '%d日',
	            M : '1ヶ月',
	            MM : '%dヶ月',
	            y : '1年',
	            yy : '%d年'
	        }
	    });
	
	    return ja;
	
	}));

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var jv = moment.defineLocale('jv', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /enjing|siyang|sonten|ndalu/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'enjing') {
	                return hour;
	            } else if (meridiem === 'siyang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'enjing';
	            } else if (hours < 15) {
	                return 'siyang';
	            } else if (hours < 19) {
	                return 'sonten';
	            } else {
	                return 'ndalu';
	            }
	        },
	        calendar : {
	            sameDay : '[Dinten puniko pukul] LT',
	            nextDay : '[Mbenjang pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kala wingi pukul] LT',
	            lastWeek : 'dddd [kepengker pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'wonten ing %s',
	            past : '%s ingkang kepengker',
	            s : 'sawetawis detik',
	            m : 'setunggal menit',
	            mm : '%d menit',
	            h : 'setunggal jam',
	            hh : '%d jam',
	            d : 'sedinten',
	            dd : '%d dinten',
	            M : 'sewulan',
	            MM : '%d wulan',
	            y : 'setaun',
	            yy : '%d taun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return jv;
	
	}));

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ka = moment.defineLocale('ka', {
	        months : {
	            standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	            format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	        },
	        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	        weekdays : {
	            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
	            isFormat: /(წინა|შემდეგ)/
	        },
	        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[დღეს] LT[-ზე]',
	            nextDay : '[ხვალ] LT[-ზე]',
	            lastDay : '[გუშინ] LT[-ზე]',
	            nextWeek : '[შემდეგ] dddd LT[-ზე]',
	            lastWeek : '[წინა] dddd LT-ზე',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                    s.replace(/ი$/, 'ში') :
	                    s + 'ში';
	            },
	            past : function (s) {
	                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                    return s.replace(/(ი|ე)$/, 'ის წინ');
	                }
	                if ((/წელი/).test(s)) {
	                    return s.replace(/წელი$/, 'წლის წინ');
	                }
	            },
	            s : 'რამდენიმე წამი',
	            m : 'წუთი',
	            mm : '%d წუთი',
	            h : 'საათი',
	            hh : '%d საათი',
	            d : 'დღე',
	            dd : '%d დღე',
	            M : 'თვე',
	            MM : '%d თვე',
	            y : 'წელი',
	            yy : '%d წელი'
	        },
	        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	            if (number === 1) {
	                return number + '-ლი';
	            }
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return 'მე-' + number;
	            }
	            return number + '-ე';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });
	
	    return ka;
	
	}));

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        0: '-ші',
	        1: '-ші',
	        2: '-ші',
	        3: '-ші',
	        4: '-ші',
	        5: '-ші',
	        6: '-шы',
	        7: '-ші',
	        8: '-ші',
	        9: '-шы',
	        10: '-шы',
	        20: '-шы',
	        30: '-шы',
	        40: '-шы',
	        50: '-ші',
	        60: '-шы',
	        70: '-ші',
	        80: '-ші',
	        90: '-шы',
	        100: '-ші'
	    };
	
	    var kk = moment.defineLocale('kk', {
	        months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
	        monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
	        weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
	        weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
	        weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бүгін сағат] LT',
	            nextDay : '[Ертең сағат] LT',
	            nextWeek : 'dddd [сағат] LT',
	            lastDay : '[Кеше сағат] LT',
	            lastWeek : '[Өткен аптаның] dddd [сағат] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ішінде',
	            past : '%s бұрын',
	            s : 'бірнеше секунд',
	            m : 'бір минут',
	            mm : '%d минут',
	            h : 'бір сағат',
	            hh : '%d сағат',
	            d : 'бір күн',
	            dd : '%d күн',
	            M : 'бір ай',
	            MM : '%d ай',
	            y : 'бір жыл',
	            yy : '%d жыл'
	        },
	        ordinalParse: /\d{1,2}-(ші|шы)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return kk;
	
	}));

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var km = moment.defineLocale('km', {
	        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
	            nextDay: '[ស្អែក ម៉ោង] LT',
	            nextWeek: 'dddd [ម៉ោង] LT',
	            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%sទៀត',
	            past: '%sមុន',
	            s: 'ប៉ុន្មានវិនាទី',
	            m: 'មួយនាទី',
	            mm: '%d នាទី',
	            h: 'មួយម៉ោង',
	            hh: '%d ម៉ោង',
	            d: 'មួយថ្ងៃ',
	            dd: '%d ថ្ងៃ',
	            M: 'មួយខែ',
	            MM: '%d ខែ',
	            y: 'មួយឆ្នាំ',
	            yy: '%d ឆ្នាំ'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return km;
	
	}));

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//!
	//! authors
	//!
	//! - Kyungwook, Park : https://github.com/kyungw00k
	//! - Jeeeyul Lee <jeeeyul@gmail.com>
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ko = moment.defineLocale('ko', {
	        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	        longDateFormat : {
	            LT : 'A h시 m분',
	            LTS : 'A h시 m분 s초',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY년 MMMM D일',
	            LLL : 'YYYY년 MMMM D일 A h시 m분',
	            LLLL : 'YYYY년 MMMM D일 dddd A h시 m분'
	        },
	        calendar : {
	            sameDay : '오늘 LT',
	            nextDay : '내일 LT',
	            nextWeek : 'dddd LT',
	            lastDay : '어제 LT',
	            lastWeek : '지난주 dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s 후',
	            past : '%s 전',
	            s : '몇 초',
	            ss : '%d초',
	            m : '일분',
	            mm : '%d분',
	            h : '한 시간',
	            hh : '%d시간',
	            d : '하루',
	            dd : '%d일',
	            M : '한 달',
	            MM : '%d달',
	            y : '일 년',
	            yy : '%d년'
	        },
	        ordinalParse : /\d{1,2}일/,
	        ordinal : '%d일',
	        meridiemParse : /오전|오후/,
	        isPM : function (token) {
	            return token === '오후';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '오전' : '오후';
	        }
	    });
	
	    return ko;
	
	}));

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    var suffixes = {
	        0: '-чү',
	        1: '-чи',
	        2: '-чи',
	        3: '-чү',
	        4: '-чү',
	        5: '-чи',
	        6: '-чы',
	        7: '-чи',
	        8: '-чи',
	        9: '-чу',
	        10: '-чу',
	        20: '-чы',
	        30: '-чу',
	        40: '-чы',
	        50: '-чү',
	        60: '-чы',
	        70: '-чи',
	        80: '-чи',
	        90: '-чу',
	        100: '-чү'
	    };
	
	    var ky = moment.defineLocale('ky', {
	        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	        monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
	        weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
	        weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бүгүн саат] LT',
	            nextDay : '[Эртең саат] LT',
	            nextWeek : 'dddd [саат] LT',
	            lastDay : '[Кече саат] LT',
	            lastWeek : '[Өткен аптанын] dddd [күнү] [саат] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ичинде',
	            past : '%s мурун',
	            s : 'бирнече секунд',
	            m : 'бир мүнөт',
	            mm : '%d мүнөт',
	            h : 'бир саат',
	            hh : '%d саат',
	            d : 'бир күн',
	            dd : '%d күн',
	            M : 'бир ай',
	            MM : '%d ай',
	            y : 'бир жыл',
	            yy : '%d жыл'
	        },
	        ordinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ky;
	
	}));

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }
	
	    var lb = moment.defineLocale('lb', {
	        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm [Auer]',
	            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gëschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Méint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lb;
	
	}));

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var lo = moment.defineLocale('lo', {
	        months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	        monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	        weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	        weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	        weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	        isPM: function (input) {
	            return input === 'ຕອນແລງ';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ຕອນເຊົ້າ';
	            } else {
	                return 'ຕອນແລງ';
	            }
	        },
	        calendar : {
	            sameDay : '[ມື້ນີ້ເວລາ] LT',
	            nextDay : '[ມື້ອື່ນເວລາ] LT',
	            nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
	            lastDay : '[ມື້ວານນີ້ເວລາ] LT',
	            lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ອີກ %s',
	            past : '%sຜ່ານມາ',
	            s : 'ບໍ່ເທົ່າໃດວິນາທີ',
	            m : '1 ນາທີ',
	            mm : '%d ນາທີ',
	            h : '1 ຊົ່ວໂມງ',
	            hh : '%d ຊົ່ວໂມງ',
	            d : '1 ມື້',
	            dd : '%d ມື້',
	            M : '1 ເດືອນ',
	            MM : '%d ເດືອນ',
	            y : '1 ປີ',
	            yy : '%d ປີ'
	        },
	        ordinalParse: /(ທີ່)\d{1,2}/,
	        ordinal : function (number) {
	            return 'ທີ່' + number;
	        }
	    });
	
	    return lo;
	
	}));

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozūras : https://github.com/mmozuras
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var units = {
	        'm' : 'minutė_minutės_minutę',
	        'mm': 'minutės_minučių_minutes',
	        'h' : 'valanda_valandos_valandą',
	        'hh': 'valandos_valandų_valandas',
	        'd' : 'diena_dienos_dieną',
	        'dd': 'dienos_dienų_dienas',
	        'M' : 'mėnuo_mėnesio_mėnesį',
	        'MM': 'mėnesiai_mėnesių_mėnesius',
	        'y' : 'metai_metų_metus',
	        'yy': 'metai_metų_metus'
	    };
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekundės';
	        } else {
	            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	        }
	    }
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	    function forms(key) {
	        return units[key].split('_');
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	    var lt = moment.defineLocale('lt', {
	        months : {
	            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
	            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
	            isFormat: /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?|MMMM?(\[[^\[\]]*\]|\s+)+D[oD]?/
	        },
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : {
	            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
	            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
	            isFormat: /dddd HH:mm/
	        },
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	        },
	        calendar : {
	            sameDay : '[Šiandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Praėjusį] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prieš %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lt;
	
	}));

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jānis Elmeris : https://github.com/JanisE
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var units = {
	        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'h': 'stundas_stundām_stunda_stundas'.split('_'),
	        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
	        'd': 'dienas_dienām_diena_dienas'.split('_'),
	        'dd': 'dienas_dienām_diena_dienas'.split('_'),
	        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'y': 'gada_gadiem_gads_gadi'.split('_'),
	        'yy': 'gada_gadiem_gads_gadi'.split('_')
	    };
	    /**
	     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	     */
	    function format(forms, number, withoutSuffix) {
	        if (withoutSuffix) {
	            // E.g. "21 minūte", "3 minūtes".
	            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	        } else {
	            // E.g. "21 minūtes" as in "pēc 21 minūtes".
	            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
	            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	        }
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	    function relativeTimeWithSingular(number, withoutSuffix, key) {
	        return format(units[key], number, withoutSuffix);
	    }
	    function relativeSeconds(number, withoutSuffix) {
	        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
	    }
	
	    var lv = moment.defineLocale('lv', {
	        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY.',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	        },
	        calendar : {
	            sameDay : '[Šodien pulksten] LT',
	            nextDay : '[Rīt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagājušā] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'pēc %s',
	            past : 'pirms %s',
	            s : relativeSeconds,
	            m : relativeTimeWithSingular,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithSingular,
	            hh : relativeTimeWithPlural,
	            d : relativeTimeWithSingular,
	            dd : relativeTimeWithPlural,
	            M : relativeTimeWithSingular,
	            MM : relativeTimeWithPlural,
	            y : relativeTimeWithSingular,
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lv;
	
	}));

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jednog minuta'],
	            mm: ['minut', 'minuta', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mjesec', 'mjeseca', 'mjeseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var me = moment.defineLocale('me', {
	        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact : true,
	        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sjutra u] LT',
	
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedjelje] [u] LT',
	                    '[prošlog] [ponedjeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srijede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mjesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return me;
	
	}));

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var mk = moment.defineLocale('mk', {
	        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Денес во] LT',
	            nextDay : '[Утре во] LT',
	            nextWeek : '[Во] dddd [во] LT',
	            lastDay : '[Вчера во] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 6:
	                        return '[Изминатата] dddd [во] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[Изминатиот] dddd [во] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'после %s',
	            past : 'пред %s',
	            s : 'неколку секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дена',
	            M : 'месец',
	            MM : '%d месеци',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return mk;
	
	}));

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ml = moment.defineLocale('ml', {
	        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -നു',
	            LTS : 'A h:mm:ss -നു',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm -നു',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
	        },
	        calendar : {
	            sameDay : '[ഇന്ന്] LT',
	            nextDay : '[നാളെ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ഇന്നലെ] LT',
	            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s കഴിഞ്ഞ്',
	            past : '%s മുൻപ്',
	            s : 'അൽപ നിമിഷങ്ങൾ',
	            m : 'ഒരു മിനിറ്റ്',
	            mm : '%d മിനിറ്റ്',
	            h : 'ഒരു മണിക്കൂർ',
	            hh : '%d മണിക്കൂർ',
	            d : 'ഒരു ദിവസം',
	            dd : '%d ദിവസം',
	            M : 'ഒരു മാസം',
	            MM : '%d മാസം',
	            y : 'ഒരു വർഷം',
	            yy : '%d വർഷം'
	        },
	        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === 'രാത്രി' && hour >= 4) ||
	                    meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
	                    meridiem === 'വൈകുന്നേരം') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'രാത്രി';
	            } else if (hour < 12) {
	                return 'രാവിലെ';
	            } else if (hour < 17) {
	                return 'ഉച്ച കഴിഞ്ഞ്';
	            } else if (hour < 20) {
	                return 'വൈകുന്നേരം';
	            } else {
	                return 'രാത്രി';
	            }
	        }
	    });
	
	    return ml;
	
	}));

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    function relativeTimeMr(number, withoutSuffix, string, isFuture)
	    {
	        var output = '';
	        if (withoutSuffix) {
	            switch (string) {
	                case 's': output = 'काही सेकंद'; break;
	                case 'm': output = 'एक मिनिट'; break;
	                case 'mm': output = '%d मिनिटे'; break;
	                case 'h': output = 'एक तास'; break;
	                case 'hh': output = '%d तास'; break;
	                case 'd': output = 'एक दिवस'; break;
	                case 'dd': output = '%d दिवस'; break;
	                case 'M': output = 'एक महिना'; break;
	                case 'MM': output = '%d महिने'; break;
	                case 'y': output = 'एक वर्ष'; break;
	                case 'yy': output = '%d वर्षे'; break;
	            }
	        }
	        else {
	            switch (string) {
	                case 's': output = 'काही सेकंदां'; break;
	                case 'm': output = 'एका मिनिटा'; break;
	                case 'mm': output = '%d मिनिटां'; break;
	                case 'h': output = 'एका तासा'; break;
	                case 'hh': output = '%d तासां'; break;
	                case 'd': output = 'एका दिवसा'; break;
	                case 'dd': output = '%d दिवसां'; break;
	                case 'M': output = 'एका महिन्या'; break;
	                case 'MM': output = '%d महिन्यां'; break;
	                case 'y': output = 'एका वर्षा'; break;
	                case 'yy': output = '%d वर्षां'; break;
	            }
	        }
	        return output.replace(/%d/i, number);
	    }
	
	    var mr = moment.defineLocale('mr', {
	        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm वाजता',
	            LTS : 'A h:mm:ss वाजता',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm वाजता',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[उद्या] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[काल] LT',
	            lastWeek: '[मागील] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future: '%sमध्ये',
	            past: '%sपूर्वी',
	            s: relativeTimeMr,
	            m: relativeTimeMr,
	            mm: relativeTimeMr,
	            h: relativeTimeMr,
	            hh: relativeTimeMr,
	            d: relativeTimeMr,
	            dd: relativeTimeMr,
	            M: relativeTimeMr,
	            MM: relativeTimeMr,
	            y: relativeTimeMr,
	            yy: relativeTimeMr
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात्री') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सकाळी') {
	                return hour;
	            } else if (meridiem === 'दुपारी') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'सायंकाळी') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात्री';
	            } else if (hour < 10) {
	                return 'सकाळी';
	            } else if (hour < 17) {
	                return 'दुपारी';
	            } else if (hour < 20) {
	                return 'सायंकाळी';
	            } else {
	                return 'रात्री';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return mr;
	
	}));

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ms = moment.defineLocale('ms', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ms;
	
	}));

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ms_my = moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ms_my;
	
	}));

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '၁',
	        '2': '၂',
	        '3': '၃',
	        '4': '၄',
	        '5': '၅',
	        '6': '၆',
	        '7': '၇',
	        '8': '၈',
	        '9': '၉',
	        '0': '၀'
	    }, numberMap = {
	        '၁': '1',
	        '၂': '2',
	        '၃': '3',
	        '၄': '4',
	        '၅': '5',
	        '၆': '6',
	        '၇': '7',
	        '၈': '8',
	        '၉': '9',
	        '၀': '0'
	    };
	
	    var my = moment.defineLocale('my', {
	        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ယနေ.] LT [မှာ]',
	            nextDay: '[မနက်ဖြန်] LT [မှာ]',
	            nextWeek: 'dddd LT [မှာ]',
	            lastDay: '[မနေ.က] LT [မှာ]',
	            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'လာမည့် %s မှာ',
	            past: 'လွန်ခဲ့သော %s က',
	            s: 'စက္ကန်.အနည်းငယ်',
	            m: 'တစ်မိနစ်',
	            mm: '%d မိနစ်',
	            h: 'တစ်နာရီ',
	            hh: '%d နာရီ',
	            d: 'တစ်ရက်',
	            dd: '%d ရက်',
	            M: 'တစ်လ',
	            MM: '%d လ',
	            y: 'တစ်နှစ်',
	            yy: '%d နှစ်'
	        },
	        preparse: function (string) {
	            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return my;
	
	}));

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokmål [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var nb = moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i går kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nb;
	
	}));

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var ne = moment.defineLocale('ne', {
	        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	        weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'Aको h:mm बजे',
	            LTS : 'Aको h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, Aको h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'राति') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'बिहान') {
	                return hour;
	            } else if (meridiem === 'दिउँसो') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'साँझ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return 'राति';
	            } else if (hour < 12) {
	                return 'बिहान';
	            } else if (hour < 16) {
	                return 'दिउँसो';
	            } else if (hour < 20) {
	                return 'साँझ';
	            } else {
	                return 'राति';
	            }
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[भोलि] LT',
	            nextWeek : '[आउँदो] dddd[,] LT',
	            lastDay : '[हिजो] LT',
	            lastWeek : '[गएको] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sमा',
	            past : '%s अगाडि',
	            s : 'केही क्षण',
	            m : 'एक मिनेट',
	            mm : '%d मिनेट',
	            h : 'एक घण्टा',
	            hh : '%d घण्टा',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महिना',
	            MM : '%d महिना',
	            y : 'एक बर्ष',
	            yy : '%d बर्ष'
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ne;
	
	}));

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Röling : https://github.com/jjupiter
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	    var nl = moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'één minuut',
	            mm : '%d minuten',
	            h : 'één uur',
	            hh : '%d uur',
	            d : 'één dag',
	            dd : '%d dagen',
	            M : 'één maand',
	            MM : '%d maanden',
	            y : 'één jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nl;
	
	}));

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var nn = moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I går klokka] LT',
	            lastWeek: '[Føregåande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein månad',
	            MM : '%d månader',
	            y : 'eit år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nn;
	
	}));

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '੧',
	        '2': '੨',
	        '3': '੩',
	        '4': '੪',
	        '5': '੫',
	        '6': '੬',
	        '7': '੭',
	        '8': '੮',
	        '9': '੯',
	        '0': '੦'
	    },
	    numberMap = {
	        '੧': '1',
	        '੨': '2',
	        '੩': '3',
	        '੪': '4',
	        '੫': '5',
	        '੬': '6',
	        '੭': '7',
	        '੮': '8',
	        '੯': '9',
	        '੦': '0'
	    };
	
	    var pa_in = moment.defineLocale('pa-in', {
	        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	        months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	        monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	        weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
	        weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	        weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ਵਜੇ',
	            LTS : 'A h:mm:ss ਵਜੇ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
	        },
	        calendar : {
	            sameDay : '[ਅਜ] LT',
	            nextDay : '[ਕਲ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ਕਲ] LT',
	            lastWeek : '[ਪਿਛਲੇ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ਵਿੱਚ',
	            past : '%s ਪਿਛਲੇ',
	            s : 'ਕੁਝ ਸਕਿੰਟ',
	            m : 'ਇਕ ਮਿੰਟ',
	            mm : '%d ਮਿੰਟ',
	            h : 'ਇੱਕ ਘੰਟਾ',
	            hh : '%d ਘੰਟੇ',
	            d : 'ਇੱਕ ਦਿਨ',
	            dd : '%d ਦਿਨ',
	            M : 'ਇੱਕ ਮਹੀਨਾ',
	            MM : '%d ਮਹੀਨੇ',
	            y : 'ਇੱਕ ਸਾਲ',
	            yy : '%d ਸਾਲ'
	        },
	        preparse: function (string) {
	            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'ਰਾਤ') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'ਸਵੇਰ') {
	                return hour;
	            } else if (meridiem === 'ਦੁਪਹਿਰ') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'ਸ਼ਾਮ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ਰਾਤ';
	            } else if (hour < 10) {
	                return 'ਸਵੇਰ';
	            } else if (hour < 17) {
	                return 'ਦੁਪਹਿਰ';
	            } else if (hour < 20) {
	                return 'ਸ਼ਾਮ';
	            } else {
	                return 'ਰਾਤ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return pa_in;
	
	}));

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'minuta' : 'minutę';
	            case 'mm':
	                return result + (plural(number) ? 'minuty' : 'minut');
	            case 'h':
	                return withoutSuffix  ? 'godzina'  : 'godzinę';
	            case 'hh':
	                return result + (plural(number) ? 'godziny' : 'godzin');
	            case 'MM':
	                return result + (plural(number) ? 'miesiące' : 'miesięcy');
	            case 'yy':
	                return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }
	
	    var pl = moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (format === '') {
	                // Hack: if format empty we know this is used to generate
	                // RegExp by moment. Give then back both valid forms of months
	                // in RegExp ready format.
	                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	            } else if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
	        weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Dziś o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[W zeszłą niedzielę o] LT';
	                    case 3:
	                        return '[W zeszłą środę o] LT';
	                    case 6:
	                        return '[W zeszłą sobotę o] LT';
	                    default:
	                        return '[W zeszły] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzień',
	            dd : '%d dni',
	            M : 'miesiąc',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return pl;
	
	}));

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var pt = moment.defineLocale('pt', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'há %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return pt;
	
	}));

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var pt_br = moment.defineLocale('pt-br', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrás',
	            s : 'poucos segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº'
	    });
	
	    return pt_br;
	
	}));

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	        return number + separator + format[key];
	    }
	
	    var ro = moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mâine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s în urmă',
	            s : 'câteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o oră',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lună',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ro;
	
	}));

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensúle : https://github.com/Oire
	//! author : Коренберг Марк : https://github.com/socketpair
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	            'hh': 'час_часа_часов',
	            'dd': 'день_дня_дней',
	            'MM': 'месяц_месяца_месяцев',
	            'yy': 'год_года_лет'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'минута' : 'минуту';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];
	
	    // http://new.gramota.ru/spravka/rules/139-prop : § 103
	    // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
	    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	    var ru = moment.defineLocale('ru', {
	        months : {
	            format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
	            standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
	        },
	        monthsShort : {
	            // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
	            format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
	            standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
	        },
	        weekdays : {
	            standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
	            format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
	            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	        },
	        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        monthsParse : monthsParse,
	        longMonthsParse : monthsParse,
	        shortMonthsParse : monthsParse,
	
	        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
	        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
	
	        // копия предыдущего
	        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
	
	        // полные названия с падежами
	        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
	
	        // Выражение, которое соотвествует только сокращённым формам
	        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сегодня в] LT',
	            nextDay: '[Завтра в] LT',
	            lastDay: '[Вчера в] LT',
	            nextWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                        case 0:
	                            return '[В следующее] dddd [в] LT';
	                        case 1:
	                        case 2:
	                        case 4:
	                            return '[В следующий] dddd [в] LT';
	                        case 3:
	                        case 5:
	                        case 6:
	                            return '[В следующую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                        case 0:
	                            return '[В прошлое] dddd [в] LT';
	                        case 1:
	                        case 2:
	                        case 4:
	                            return '[В прошлый] dddd [в] LT';
	                        case 3:
	                        case 5:
	                        case 6:
	                            return '[В прошлую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'через %s',
	            past : '%s назад',
	            s : 'несколько секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'час',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночи|утра|дня|вечера/i,
	        isPM : function (input) {
	            return /^(дня|вечера)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночи';
	            } else if (hour < 12) {
	                return 'утра';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечера';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го|я)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                    return number + '-й';
	                case 'D':
	                    return number + '-го';
	                case 'w':
	                case 'W':
	                    return number + '-я';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ru;
	
	}));

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Bård Rolstad Henriksen : https://github.com/karamell
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    var se = moment.defineLocale('se', {
	        months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
	        monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
	        weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
	        weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
	        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'MMMM D. [b.] YYYY',
	            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[otne ti] LT',
	            nextDay: '[ihttin ti] LT',
	            nextWeek: 'dddd [ti] LT',
	            lastDay: '[ikte ti] LT',
	            lastWeek: '[ovddit] dddd [ti] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s geažes',
	            past : 'maŋit %s',
	            s : 'moadde sekunddat',
	            m : 'okta minuhta',
	            mm : '%d minuhtat',
	            h : 'okta diimmu',
	            hh : '%d diimmut',
	            d : 'okta beaivi',
	            dd : '%d beaivvit',
	            M : 'okta mánnu',
	            MM : '%d mánut',
	            y : 'okta jahki',
	            yy : '%d jagit'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return se;
	
	}));

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    /*jshint -W100*/
	    var si = moment.defineLocale('si', {
	        months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
	        monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
	        weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
	        weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
	        weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'a h:mm',
	            LTS : 'a h:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D, a h:mm',
	            LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
	        },
	        calendar : {
	            sameDay : '[අද] LT[ට]',
	            nextDay : '[හෙට] LT[ට]',
	            nextWeek : 'dddd LT[ට]',
	            lastDay : '[ඊයේ] LT[ට]',
	            lastWeek : '[පසුගිය] dddd LT[ට]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sකින්',
	            past : '%sකට පෙර',
	            s : 'තත්පර කිහිපය',
	            m : 'මිනිත්තුව',
	            mm : 'මිනිත්තු %d',
	            h : 'පැය',
	            hh : 'පැය %d',
	            d : 'දිනය',
	            dd : 'දින %d',
	            M : 'මාසය',
	            MM : 'මාස %d',
	            y : 'වසර',
	            yy : 'වසර %d'
	        },
	        ordinalParse: /\d{1,2} වැනි/,
	        ordinal : function (number) {
	            return number + ' වැනි';
	        },
	        meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
	        isPM : function (input) {
	            return input === 'ප.ව.' || input === 'පස් වරු';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'ප.ව.' : 'පස් වරු';
	            } else {
	                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
	            }
	        }
	    });
	
	    return si;
	
	}));

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':  // a few seconds / in a few seconds / a few seconds ago
	                return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	            case 'm':  // a minute / in a minute / a minute ago
	                return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'minúty' : 'minút');
	                } else {
	                    return result + 'minútami';
	                }
	                break;
	            case 'h':  // an hour / in an hour / an hour ago
	                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	            case 'hh': // 9 hours / in 9 hours / 9 hours ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'hodiny' : 'hodín');
	                } else {
	                    return result + 'hodinami';
	                }
	                break;
	            case 'd':  // a day / in a day / a day ago
	                return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	            case 'dd': // 9 days / in 9 days / 9 days ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'dni' : 'dní');
	                } else {
	                    return result + 'dňami';
	                }
	                break;
	            case 'M':  // a month / in a month / a month ago
	                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	            case 'MM': // 9 months / in 9 months / 9 months ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
	                } else {
	                    return result + 'mesiacmi';
	                }
	                break;
	            case 'y':  // a year / in a year / a year ago
	                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	            case 'yy': // 9 years / in 9 years / 9 years ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'roky' : 'rokov');
	                } else {
	                    return result + 'rokmi';
	                }
	                break;
	        }
	    }
	
	    var sk = moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v nedeľu o] LT';
	                    case 1:
	                    case 2:
	                        return '[v] dddd [o] LT';
	                    case 3:
	                        return '[v stredu o] LT';
	                    case 4:
	                        return '[vo štvrtok o] LT';
	                    case 5:
	                        return '[v piatok o] LT';
	                    case 6:
	                        return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[včera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[minulú nedeľu o] LT';
	                    case 1:
	                    case 2:
	                        return '[minulý] dddd [o] LT';
	                    case 3:
	                        return '[minulú stredu o] LT';
	                    case 4:
	                    case 5:
	                        return '[minulý] dddd [o] LT';
	                    case 6:
	                        return '[minulú sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sk;
	
	}));

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovšek : https://github.com/sedovsek
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':
	                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	            case 'm':
	                return withoutSuffix ? 'ena minuta' : 'eno minuto';
	            case 'mm':
	                if (number === 1) {
	                    result += withoutSuffix ? 'minuta' : 'minuto';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	                } else {
	                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'ena ura' : 'eno uro';
	            case 'hh':
	                if (number === 1) {
	                    result += withoutSuffix ? 'ura' : 'uro';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
	                } else {
	                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
	                }
	                return result;
	            case 'd':
	                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	            case 'dd':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	                } else {
	                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	                }
	                return result;
	            case 'M':
	                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	            case 'MM':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	                } else {
	                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	                }
	                return result;
	            case 'y':
	                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	            case 'yy':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
	                } else {
	                    result += withoutSuffix || isFuture ? 'let' : 'leti';
	                }
	                return result;
	        }
	    }
	
	    var sl = moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',
	
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v] [nedeljo] [ob] LT';
	                    case 3:
	                        return '[v] [sredo] [ob] LT';
	                    case 6:
	                        return '[v] [soboto] [ob] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[včeraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[prejšnjo] [nedeljo] [ob] LT';
	                    case 3:
	                        return '[prejšnjo] [sredo] [ob] LT';
	                    case 6:
	                        return '[prejšnjo] [soboto] [ob] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prejšnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'čez %s',
	            past   : 'pred %s',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : processRelativeTime,
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sl;
	
	}));

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakërim Ismani : https://github.com/flakerimi
	//! author: Menelion Elensúle: https://github.com/Oire (tests)
	//! author : Oerd Cukalla : https://github.com/oerd (fixes)
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sq = moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	        weekdaysParseExact : true,
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Sot në] LT',
	            nextDay : '[Nesër në] LT',
	            nextWeek : 'dddd [në] LT',
	            lastDay : '[Dje në] LT',
	            lastWeek : 'dddd [e kaluar në] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'në %s',
	            past : '%s më parë',
	            s : 'disa sekonda',
	            m : 'një minutë',
	            mm : '%d minuta',
	            h : 'një orë',
	            hh : '%d orë',
	            d : 'një ditë',
	            dd : '%d ditë',
	            M : 'një muaj',
	            MM : '%d muaj',
	            y : 'një vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sq;
	
	}));

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var sr = moment.defineLocale('sr', {
	        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
	        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedelju] [u] LT';
	                    case 3:
	                        return '[u] [sredu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedelje] [u] LT',
	                    '[prošlog] [ponedeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sr;
	
	}));

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['један минут', 'једне минуте'],
	            mm: ['минут', 'минуте', 'минута'],
	            h: ['један сат', 'једног сата'],
	            hh: ['сат', 'сата', 'сати'],
	            dd: ['дан', 'дана', 'дана'],
	            MM: ['месец', 'месеца', 'месеци'],
	            yy: ['година', 'године', 'година']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var sr_cyrl = moment.defineLocale('sr-cyrl', {
	        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
	        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
	        monthsParseExact: true,
	        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
	        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
	        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[данас у] LT',
	            nextDay: '[сутра у] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[у] [недељу] [у] LT';
	                    case 3:
	                        return '[у] [среду] [у] LT';
	                    case 6:
	                        return '[у] [суботу] [у] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[у] dddd [у] LT';
	                }
	            },
	            lastDay  : '[јуче у] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[прошле] [недеље] [у] LT',
	                    '[прошлог] [понедељка] [у] LT',
	                    '[прошлог] [уторка] [у] LT',
	                    '[прошле] [среде] [у] LT',
	                    '[прошлог] [четвртка] [у] LT',
	                    '[прошлог] [петка] [у] LT',
	                    '[прошле] [суботе] [у] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past   : 'пре %s',
	            s      : 'неколико секунди',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'дан',
	            dd     : translator.translate,
	            M      : 'месец',
	            MM     : translator.translate,
	            y      : 'годину',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sr_cyrl;
	
	}));

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swazi [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    var ss = moment.defineLocale('ss', {
	        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Namuhla nga] LT',
	            nextDay : '[Kusasa nga] LT',
	            nextWeek : 'dddd [nga] LT',
	            lastDay : '[Itolo nga] LT',
	            lastWeek : 'dddd [leliphelile] [nga] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'nga %s',
	            past : 'wenteka nga %s',
	            s : 'emizuzwana lomcane',
	            m : 'umzuzu',
	            mm : '%d emizuzu',
	            h : 'lihora',
	            hh : '%d emahora',
	            d : 'lilanga',
	            dd : '%d emalanga',
	            M : 'inyanga',
	            MM : '%d tinyanga',
	            y : 'umnyaka',
	            yy : '%d iminyaka'
	        },
	        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'ekuseni';
	            } else if (hours < 15) {
	                return 'emini';
	            } else if (hours < 19) {
	                return 'entsambama';
	            } else {
	                return 'ebusuku';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'ekuseni') {
	                return hour;
	            } else if (meridiem === 'emini') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	                if (hour === 0) {
	                    return 0;
	                }
	                return hour + 12;
	            }
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ss;
	
	}));

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sv = moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igår] LT',
	            nextWeek: '[På] dddd LT',
	            lastWeek: '[I] dddd[s] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'för %s sedan',
	            s : 'några sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en månad',
	            MM : '%d månader',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sv;
	
	}));

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sw = moment.defineLocale('sw', {
	        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[leo saa] LT',
	            nextDay : '[kesho saa] LT',
	            nextWeek : '[wiki ijayo] dddd [saat] LT',
	            lastDay : '[jana] LT',
	            lastWeek : '[wiki iliyopita] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s baadaye',
	            past : 'tokea %s',
	            s : 'hivi punde',
	            m : 'dakika moja',
	            mm : 'dakika %d',
	            h : 'saa limoja',
	            hh : 'masaa %d',
	            d : 'siku moja',
	            dd : 'masiku %d',
	            M : 'mwezi mmoja',
	            MM : 'miezi %d',
	            y : 'mwaka mmoja',
	            yy : 'miaka %d'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sw;
	
	}));

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '௧',
	        '2': '௨',
	        '3': '௩',
	        '4': '௪',
	        '5': '௫',
	        '6': '௬',
	        '7': '௭',
	        '8': '௮',
	        '9': '௯',
	        '0': '௦'
	    }, numberMap = {
	        '௧': '1',
	        '௨': '2',
	        '௩': '3',
	        '௪': '4',
	        '௫': '5',
	        '௬': '6',
	        '௭': '7',
	        '௮': '8',
	        '௯': '9',
	        '௦': '0'
	    };
	
	    var ta = moment.defineLocale('ta', {
	        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, HH:mm',
	            LLLL : 'dddd, D MMMM YYYY, HH:mm'
	        },
	        calendar : {
	            sameDay : '[இன்று] LT',
	            nextDay : '[நாளை] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[நேற்று] LT',
	            lastWeek : '[கடந்த வாரம்] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s இல்',
	            past : '%s முன்',
	            s : 'ஒரு சில விநாடிகள்',
	            m : 'ஒரு நிமிடம்',
	            mm : '%d நிமிடங்கள்',
	            h : 'ஒரு மணி நேரம்',
	            hh : '%d மணி நேரம்',
	            d : 'ஒரு நாள்',
	            dd : '%d நாட்கள்',
	            M : 'ஒரு மாதம்',
	            MM : '%d மாதங்கள்',
	            y : 'ஒரு வருடம்',
	            yy : '%d ஆண்டுகள்'
	        },
	        ordinalParse: /\d{1,2}வது/,
	        ordinal : function (number) {
	            return number + 'வது';
	        },
	        preparse: function (string) {
	            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' யாமம்';
	            } else if (hour < 6) {
	                return ' வைகறை';  // வைகறை
	            } else if (hour < 10) {
	                return ' காலை'; // காலை
	            } else if (hour < 14) {
	                return ' நண்பகல்'; // நண்பகல்
	            } else if (hour < 18) {
	                return ' எற்பாடு'; // எற்பாடு
	            } else if (hour < 22) {
	                return ' மாலை'; // மாலை
	            } else {
	                return ' யாமம்';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'யாமம்') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	                return hour;
	            } else if (meridiem === 'நண்பகல்') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ta;
	
	}));

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var te = moment.defineLocale('te', {
	        months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
	        monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
	        weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
	        weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[నేడు] LT',
	            nextDay : '[రేపు] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[నిన్న] LT',
	            lastWeek : '[గత] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s లో',
	            past : '%s క్రితం',
	            s : 'కొన్ని క్షణాలు',
	            m : 'ఒక నిమిషం',
	            mm : '%d నిమిషాలు',
	            h : 'ఒక గంట',
	            hh : '%d గంటలు',
	            d : 'ఒక రోజు',
	            dd : '%d రోజులు',
	            M : 'ఒక నెల',
	            MM : '%d నెలలు',
	            y : 'ఒక సంవత్సరం',
	            yy : '%d సంవత్సరాలు'
	        },
	        ordinalParse : /\d{1,2}వ/,
	        ordinal : '%dవ',
	        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'రాత్రి') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'ఉదయం') {
	                return hour;
	            } else if (meridiem === 'మధ్యాహ్నం') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'సాయంత్రం') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'రాత్రి';
	            } else if (hour < 10) {
	                return 'ఉదయం';
	            } else if (hour < 17) {
	                return 'మధ్యాహ్నం';
	            } else if (hour < 20) {
	                return 'సాయంత్రం';
	            } else {
	                return 'రాత్రి';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return te;
	
	}));

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var th = moment.defineLocale('th', {
	        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	        monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H นาฬิกา m นาที',
	            LTS : 'H นาฬิกา m นาที s วินาที',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY เวลา H นาฬิกา m นาที',
	            LLLL : 'วันddddที่ D MMMM YYYY เวลา H นาฬิกา m นาที'
	        },
	        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	        isPM: function (input) {
	            return input === 'หลังเที่ยง';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ก่อนเที่ยง';
	            } else {
	                return 'หลังเที่ยง';
	            }
	        },
	        calendar : {
	            sameDay : '[วันนี้ เวลา] LT',
	            nextDay : '[พรุ่งนี้ เวลา] LT',
	            nextWeek : 'dddd[หน้า เวลา] LT',
	            lastDay : '[เมื่อวานนี้ เวลา] LT',
	            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'อีก %s',
	            past : '%sที่แล้ว',
	            s : 'ไม่กี่วินาที',
	            m : '1 นาที',
	            mm : '%d นาที',
	            h : '1 ชั่วโมง',
	            hh : '%d ชั่วโมง',
	            d : '1 วัน',
	            dd : '%d วัน',
	            M : '1 เดือน',
	            MM : '%d เดือน',
	            y : '1 ปี',
	            yy : '%d ปี'
	        }
	    });
	
	    return th;
	
	}));

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tl_ph = moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY HH:mm',
	            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return tl_ph;
	
	}));

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
	
	    function translateFuture(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	        time.slice(0, -3) + 'leS' :
	        (output.indexOf('jar') !== -1) ?
	        time.slice(0, -3) + 'waQ' :
	        (output.indexOf('DIS') !== -1) ?
	        time.slice(0, -3) + 'nem' :
	        time + ' pIq';
	        return time;
	    }
	
	    function translatePast(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	        time.slice(0, -3) + 'Hu’' :
	        (output.indexOf('jar') !== -1) ?
	        time.slice(0, -3) + 'wen' :
	        (output.indexOf('DIS') !== -1) ?
	        time.slice(0, -3) + 'ben' :
	        time + ' ret';
	        return time;
	    }
	
	    function translate(number, withoutSuffix, string, isFuture) {
	        var numberNoun = numberAsNoun(number);
	        switch (string) {
	            case 'mm':
	                return numberNoun + ' tup';
	            case 'hh':
	                return numberNoun + ' rep';
	            case 'dd':
	                return numberNoun + ' jaj';
	            case 'MM':
	                return numberNoun + ' jar';
	            case 'yy':
	                return numberNoun + ' DIS';
	        }
	    }
	
	    function numberAsNoun(number) {
	        var hundred = Math.floor((number % 1000) / 100),
	        ten = Math.floor((number % 100) / 10),
	        one = number % 10,
	        word = '';
	        if (hundred > 0) {
	            word += numbersNouns[hundred] + 'vatlh';
	        }
	        if (ten > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	        }
	        if (one > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	        }
	        return (word === '') ? 'pagh' : word;
	    }
	
	    var tlh = moment.defineLocale('tlh', {
	        months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
	        monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[DaHjaj] LT',
	            nextDay: '[wa’leS] LT',
	            nextWeek: 'LLL',
	            lastDay: '[wa’Hu’] LT',
	            lastWeek: 'LLL',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : translateFuture,
	            past : translatePast,
	            s : 'puS lup',
	            m : 'wa’ tup',
	            mm : translate,
	            h : 'wa’ rep',
	            hh : translate,
	            d : 'wa’ jaj',
	            dd : translate,
	            M : 'wa’ jar',
	            MM : translate,
	            y : 'wa’ DIS',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return tlh;
	
	}));

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiğit Kaya: https://github.com/BYK
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	        3: '\'üncü',
	        4: '\'üncü',
	        100: '\'üncü',
	        6: '\'ncı',
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	        60: '\'ıncı',
	        90: '\'ıncı'
	    };
	
	    var tr = moment.defineLocale('tr', {
	        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[yarın saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dün] LT',
	            lastWeek : '[geçen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s önce',
	            s : 'birkaç saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yıl',
	            yy : '%d yıl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tr;
	
	}));

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iustì Canun
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	    // This is currently too difficult (maybe even impossible) to add.
	    var tzl = moment.defineLocale('tzl', {
	        months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	        weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
	        weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
	        weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM [dallas] YYYY',
	            LLL : 'D. MMMM [dallas] YYYY HH.mm',
	            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	        },
	        meridiemParse: /d\'o|d\'a/i,
	        isPM : function (input) {
	            return 'd\'o' === input.toLowerCase();
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'd\'o' : 'D\'O';
	            } else {
	                return isLower ? 'd\'a' : 'D\'A';
	            }
	        },
	        calendar : {
	            sameDay : '[oxhi à] LT',
	            nextDay : '[demà à] LT',
	            nextWeek : 'dddd [à] LT',
	            lastDay : '[ieiri à] LT',
	            lastWeek : '[sür el] dddd [lasteu à] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'osprei %s',
	            past : 'ja%s',
	            s : processRelativeTime,
	            m : processRelativeTime,
	            mm : processRelativeTime,
	            h : processRelativeTime,
	            hh : processRelativeTime,
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's': ['viensas secunds', '\'iensas secunds'],
	            'm': ['\'n míut', '\'iens míut'],
	            'mm': [number + ' míuts', '' + number + ' míuts'],
	            'h': ['\'n þora', '\'iensa þora'],
	            'hh': [number + ' þoras', '' + number + ' þoras'],
	            'd': ['\'n ziua', '\'iensa ziua'],
	            'dd': [number + ' ziuas', '' + number + ' ziuas'],
	            'M': ['\'n mes', '\'iens mes'],
	            'MM': [number + ' mesen', '' + number + ' mesen'],
	            'y': ['\'n ar', '\'iens ar'],
	            'yy': [number + ' ars', '' + number + ' ars']
	        };
	        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	    }
	
	    return tzl;
	
	}));

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tzm = moment.defineLocale('tzm', {
	        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	            nextWeek: 'dddd [ⴴ] LT',
	            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	            lastWeek: 'dddd [ⴴ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	            past : 'ⵢⴰⵏ %s',
	            s : 'ⵉⵎⵉⴽ',
	            m : 'ⵎⵉⵏⵓⴺ',
	            mm : '%d ⵎⵉⵏⵓⴺ',
	            h : 'ⵙⴰⵄⴰ',
	            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	            d : 'ⴰⵙⵙ',
	            dd : '%d oⵙⵙⴰⵏ',
	            M : 'ⴰⵢoⵓⵔ',
	            MM : '%d ⵉⵢⵢⵉⵔⵏ',
	            y : 'ⴰⵙⴳⴰⵙ',
	            yy : '%d ⵉⵙⴳⴰⵙⵏ'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tzm;
	
	}));

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tzm_latn = moment.defineLocale('tzm-latn', {
	        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minuḍ',
	            mm : '%d minuḍ',
	            h : 'saɛa',
	            hh : '%d tassaɛin',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tzm_latn;
	
	}));

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
	            'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
	            'dd': 'день_дні_днів',
	            'MM': 'місяць_місяці_місяців',
	            'yy': 'рік_роки_років'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвилина' : 'хвилину';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'година' : 'годину';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	        },
	        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	        return weekdays[nounCase][m.day()];
	    }
	    function processHoursFunction(str) {
	        return function () {
	            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	        };
	    }
	
	    var uk = moment.defineLocale('uk', {
	        months : {
	            'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
	            'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
	        },
	        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY р.',
	            LLL : 'D MMMM YYYY р., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY р., HH:mm'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[Сьогодні '),
	            nextDay: processHoursFunction('[Завтра '),
	            lastDay: processHoursFunction('[Вчора '),
	            nextWeek: processHoursFunction('[У] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 5:
	                    case 6:
	                        return processHoursFunction('[Минулої] dddd [').call(this);
	                    case 1:
	                    case 2:
	                    case 4:
	                        return processHoursFunction('[Минулого] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past : '%s тому',
	            s : 'декілька секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'годину',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'місяць',
	            MM : relativeTimeWithPlural,
	            y : 'рік',
	            yy : relativeTimeWithPlural
	        },
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	        meridiemParse: /ночі|ранку|дня|вечора/,
	        isPM: function (input) {
	            return /^(дня|вечора)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночі';
	            } else if (hour < 12) {
	                return 'ранку';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечора';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                case 'w':
	                case 'W':
	                    return number + '-й';
	                case 'D':
	                    return number + '-го';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return uk;
	
	}));

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var uz = moment.defineLocale('uz', {
	        months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
	        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'D MMMM YYYY, dddd HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бугун соат] LT [да]',
	            nextDay : '[Эртага] LT [да]',
	            nextWeek : 'dddd [куни соат] LT [да]',
	            lastDay : '[Кеча соат] LT [да]',
	            lastWeek : '[Утган] dddd [куни соат] LT [да]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'Якин %s ичида',
	            past : 'Бир неча %s олдин',
	            s : 'фурсат',
	            m : 'бир дакика',
	            mm : '%d дакика',
	            h : 'бир соат',
	            hh : '%d соат',
	            d : 'бир кун',
	            dd : '%d кун',
	            M : 'бир ой',
	            MM : '%d ой',
	            y : 'бир йил',
	            yy : '%d йил'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return uz;
	
	}));

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var vi = moment.defineLocale('vi', {
	        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysParseExact : true,
	        meridiemParse: /sa|ch/i,
	        isPM : function (input) {
	            return /^ch$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'sa' : 'SA';
	            } else {
	                return isLower ? 'ch' : 'CH';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [năm] YYYY',
	            LLL : 'D MMMM [năm] YYYY HH:mm',
	            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hôm nay lúc] LT',
	            nextDay: '[Ngày mai lúc] LT',
	            nextWeek: 'dddd [tuần tới lúc] LT',
	            lastDay: '[Hôm qua lúc] LT',
	            lastWeek: 'dddd [tuần rồi lúc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s tới',
	            past : '%s trước',
	            s : 'vài giây',
	            m : 'một phút',
	            mm : '%d phút',
	            h : 'một giờ',
	            hh : '%d giờ',
	            d : 'một ngày',
	            dd : '%d ngày',
	            M : 'một tháng',
	            MM : '%d tháng',
	            y : 'một năm',
	            yy : '%d năm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return vi;
	
	}));

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var x_pseudo = moment.defineLocale('x-pseudo', {
	        months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
	        monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
	        weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
	        weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[T~ódá~ý át] LT',
	            nextDay : '[T~ómó~rró~w át] LT',
	            nextWeek : 'dddd [át] LT',
	            lastDay : '[Ý~ést~érdá~ý át] LT',
	            lastWeek : '[L~ást] dddd [át] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'í~ñ %s',
	            past : '%s á~gó',
	            s : 'á ~féw ~sécó~ñds',
	            m : 'á ~míñ~úté',
	            mm : '%d m~íñú~tés',
	            h : 'á~ñ hó~úr',
	            hh : '%d h~óúrs',
	            d : 'á ~dáý',
	            dd : '%d d~áýs',
	            M : 'á ~móñ~th',
	            MM : '%d m~óñt~hs',
	            y : 'á ~ýéár',
	            yy : '%d ý~éárs'
	        },
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return x_pseudo;
	
	}));

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var zh_cn = moment.defineLocale('zh-cn', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah点mm分',
	            LTS : 'Ah点m分s秒',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah点mm分',
	            LLLL : 'YYYY年MMMD日ddddAh点mm分',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah点mm分',
	            llll : 'YYYY年MMMD日ddddAh点mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' ||
	                    meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            } else {
	                // '中午'
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[下]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(日|月|周)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd':
	                case 'D':
	                case 'DDD':
	                    return number + '日';
	                case 'M':
	                    return number + '月';
	                case 'w':
	                case 'W':
	                    return number + '周';
	                default:
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s内',
	            past : '%s前',
	            s : '几秒',
	            m : '1 分钟',
	            mm : '%d 分钟',
	            h : '1 小时',
	            hh : '%d 小时',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 个月',
	            MM : '%d 个月',
	            y : '1 年',
	            yy : '%d 年'
	        },
	        week : {
	            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return zh_cn;
	
	}));

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(78)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var zh_tw = moment.defineLocale('zh-tw', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah點mm分',
	            LTS : 'Ah點m分s秒',
	            L : 'YYYY年MMMD日',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah點mm分',
	            LLLL : 'YYYY年MMMD日ddddAh點mm分',
	            l : 'YYYY年MMMD日',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah點mm分',
	            llll : 'YYYY年MMMD日ddddAh點mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '中午') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : '[今天]LT',
	            nextDay : '[明天]LT',
	            nextWeek : '[下]ddddLT',
	            lastDay : '[昨天]LT',
	            lastWeek : '[上]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(日|月|週)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd' :
	                case 'D' :
	                case 'DDD' :
	                    return number + '日';
	                case 'M' :
	                    return number + '月';
	                case 'w' :
	                case 'W' :
	                    return number + '週';
	                default :
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s內',
	            past : '%s前',
	            s : '幾秒',
	            m : '1 分鐘',
	            mm : '%d 分鐘',
	            h : '1 小時',
	            hh : '%d 小時',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 個月',
	            MM : '%d 個月',
	            y : '1 年',
	            yy : '%d 年'
	        }
	    });
	
	    return zh_tw;
	
	}));

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var PaginationCollection, ProjectCollection, ProjectModel, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	PaginationCollection = __webpack_require__(71);
	
	ProjectModel = __webpack_require__(182);
	
	ProjectCollection = (function(superClass) {
	  extend(ProjectCollection, superClass);
	
	  function ProjectCollection() {
	    return ProjectCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  ProjectCollection.prototype.model = ProjectModel;
	
	  ProjectCollection.prototype.url = "/api/projects";
	
	  ProjectCollection.prototype.idAttribute = "name";
	
	  ProjectCollection.prototype.sortAttribute = "name";
	
	  return ProjectCollection;
	
	})(PaginationCollection);
	
	module.exports = ProjectCollection;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var ProjectModel, _, backbone,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	backbone = __webpack_require__(3);
	
	ProjectModel = (function(superClass) {
	  extend(ProjectModel, superClass);
	
	  function ProjectModel() {
	    return ProjectModel.__super__.constructor.apply(this, arguments);
	  }
	
	  ProjectModel.prototype.urlRoot = "/api/projects";
	
	  ProjectModel.prototype["default"] = {
	    owner: {
	      firstName: "",
	      lastName: ""
	    },
	    priority: 100
	  };
	
	  ProjectModel.prototype.parse = function(response) {
	    response.owner || (response.owner = this["default"].owner);
	    return response;
	  };
	
	  ProjectModel.prototype.destroy = function(options) {
	    _.extend(options, {
	      url: "/api/projects/" + (this.get("name"))
	    });
	    return ProjectModel.__super__.destroy.call(this, options);
	  };
	
	  return ProjectModel;
	
	})(Backbone.Model);
	
	module.exports = ProjectModel;


/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = jsRoutes;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var Clipboard, Marionette, ShareModalView, Toast, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Clipboard = __webpack_require__(185);
	
	Toast = __webpack_require__(18);
	
	ShareModalView = (function(superClass) {
	  extend(ShareModalView, superClass);
	
	  function ShareModalView() {
	    return ShareModalView.__super__.constructor.apply(this, arguments);
	  }
	
	  ShareModalView.prototype.className = "modal fade";
	
	  ShareModalView.prototype.template = _.template("<div class=\"modal-dialog\">\n  <div class=\"modal-content\">\n    <div class=\"modal-header\">\n      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n      <h3>Share</h3>\n    </div>\n    <div class=\"modal-body container-fluid\">\n      <div class=\"form-group\">\n        <label for=\"task\">Shareable Link</label>\n        <div class=\"row\">\n          <div class=\"col-md-12\">\n            <div class=\"input-group\">\n              <input type=\"text\" class=\"form-control\" readonly value=\"<%- getUrl() %>\"></input>\n              <span class=\"input-group-btn\">\n                <button class=\"btn btn-default copy-btn\" type=\"button\"><i class=\"fa fa-copy\"></i>Copy</button>\n              </span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"modal-footer\">\n      <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Close</button>\n    </div>\n  </div>\n</div>");
	
	  ShareModalView.prototype.templateHelpers = {
	    getUrl: function() {
	      return ShareModalView.prototype.getUrl();
	    }
	  };
	
	  ShareModalView.prototype.events = {
	    "click input": "copyToClipboard",
	    "click .copy-btn": "copyToClipboard"
	  };
	
	  ShareModalView.prototype.getUrl = function() {
	    var loc, pathname, url;
	    loc = window.location;
	    pathname = loc.pathname;
	    pathname = pathname.replace("/readOnly", "");
	    url = loc.origin + pathname + "/readOnly" + loc.hash;
	    return url;
	  };
	
	  ShareModalView.prototype.show = function() {
	    return this.$el.modal("show");
	  };
	
	  ShareModalView.prototype.copyToClipboard = function() {
	    var url;
	    url = this.getUrl();
	    return Clipboard.copy(url).then(function() {
	      return Toast.success("Position copied to clipboard");
	    });
	  };
	
	  return ShareModalView;
	
	})(Marionette.ItemView);
	
	module.exports = ShareModalView;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd
	(function(name, definition) {
	    if (true) module.exports = definition();
	    else if (typeof define == "function" && typeof define.amd == "object") define(definition);
	    else this[name] = definition();
	}("clipboard", function() {
	
	  var clipboard = {};
	
	  clipboard.copy = (function() {
	    var _intercept = false;
	    var _data; // Map from data type (e.g. "text/html") to value.
	
	    document.addEventListener("copy", function(e){
	      if (_intercept) {
	        _intercept = false;
	        for (var key in _data) {
	          e.clipboardData.setData(key, _data[key]);
	        }
	        e.preventDefault();
	      }
	    });
	
	    return function(data) {
	      return new Promise(function(resolve, reject) {
	        _intercept = true;
	        if (typeof data === "string") {
	          _data = {"text/plain": data};
	        } else if (data instanceof Node) {
	          _data = {"text/html": new XMLSerializer().serializeToString(data)};
	        } else {
	          _data = data;
	        }
	        try {
	          if (document.execCommand("copy")) {
	            // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis
	            // So we can call resolve() back here.
	            resolve();
	          }
	          else {
	            _intercept = false;
	            reject(new Error("Unable to copy. Perhaps it's not available in your browser?"));
	          }
	        }
	        catch (e) {
	          _intercept = false;
	          reject(e);
	        }
	      });
	    };
	  }());
	
	  clipboard.paste = (function() {
	    var _intercept = false;
	    var _resolve;
	    var _dataType;
	
	    document.addEventListener("paste", function(e) {
	      if (_intercept) {
	        _intercept = false;
	        e.preventDefault();
	        _resolve(e.clipboardData.getData(_dataType));
	      }
	    });
	
	    return function(dataType) {
	      return new Promise(function(resolve, reject) {
	        _intercept = true;
	        _resolve = resolve;
	        _dataType = dataType || "text/plain";
	        try {
	          if (!document.execCommand("paste")) {
	            _intercept = false;
	            reject(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."));
	          }
	        } catch (e) {
	          _intercept = false;
	          reject(new Error(e));
	        }
	      });
	    };
	  }());
	
	  // Handle IE behaviour.
	  if (typeof ClipboardEvent === "undefined" &&
	      typeof window.clipboardData !== "undefined" &&
	      typeof window.clipboardData.setData !== "undefined") {
	
	    /*! promise-polyfill 2.0.1 */
	    (function(a){function b(a,b){return function(){a.apply(b,arguments)}}function c(a){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof a)throw new TypeError("not a function");this._state=null,this._value=null,this._deferreds=[],i(a,b(e,this),b(f,this))}function d(a){var b=this;return null===this._state?void this._deferreds.push(a):void j(function(){var c=b._state?a.onFulfilled:a.onRejected;if(null===c)return void(b._state?a.resolve:a.reject)(b._value);var d;try{d=c(b._value)}catch(e){return void a.reject(e)}a.resolve(d)})}function e(a){try{if(a===this)throw new TypeError("A promise cannot be resolved with itself.");if(a&&("object"==typeof a||"function"==typeof a)){var c=a.then;if("function"==typeof c)return void i(b(c,a),b(e,this),b(f,this))}this._state=!0,this._value=a,g.call(this)}catch(d){f.call(this,d)}}function f(a){this._state=!1,this._value=a,g.call(this)}function g(){for(var a=0,b=this._deferreds.length;b>a;a++)d.call(this,this._deferreds[a]);this._deferreds=null}function h(a,b,c,d){this.onFulfilled="function"==typeof a?a:null,this.onRejected="function"==typeof b?b:null,this.resolve=c,this.reject=d}function i(a,b,c){var d=!1;try{a(function(a){d||(d=!0,b(a))},function(a){d||(d=!0,c(a))})}catch(e){if(d)return;d=!0,c(e)}}var j=c.immediateFn||"function"==typeof setImmediate&&setImmediate||function(a){setTimeout(a,1)},k=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)};c.prototype["catch"]=function(a){return this.then(null,a)},c.prototype.then=function(a,b){var e=this;return new c(function(c,f){d.call(e,new h(a,b,c,f))})},c.all=function(){var a=Array.prototype.slice.call(1===arguments.length&&k(arguments[0])?arguments[0]:arguments);return new c(function(b,c){function d(f,g){try{if(g&&("object"==typeof g||"function"==typeof g)){var h=g.then;if("function"==typeof h)return void h.call(g,function(a){d(f,a)},c)}a[f]=g,0===--e&&b(a)}catch(i){c(i)}}if(0===a.length)return b([]);for(var e=a.length,f=0;f<a.length;f++)d(f,a[f])})},c.resolve=function(a){return a&&"object"==typeof a&&a.constructor===c?a:new c(function(b){b(a)})},c.reject=function(a){return new c(function(b,c){c(a)})},c.race=function(a){return new c(function(b,c){for(var d=0,e=a.length;e>d;d++)a[d].then(b,c)})},"undefined"!=typeof module&&module.exports?module.exports=c:a.Promise||(a.Promise=c)})(this);
	
	    clipboard.copy = function(data) {
	      return new Promise(function(resolve, reject) {
	        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx
	        // We only support the string type for now.
	        if (typeof data !== "string" && !("text/plain" in data)) {
	          throw new Error("You must provide a text/plain type.")
	        }
	
	        var strData = (typeof data === "string" ? data : data["text/plain"]);
	        var copySucceeded = window.clipboardData.setData("Text", strData);
	        copySucceeded ? resolve() : reject(new Error("Copying was rejected."));
	      });
	    };
	
	    clipboard.paste = function(data) {
	      return new Promise(function(resolve, reject) {
	        var strData = window.clipboardData.getData("Text");
	        if (strData) {
	          resolve(strData);
	        } else {
	          // The user rejected the paste request.
	          reject(new Error("Pasting was rejected."));
	        }
	      });
	    };
	  }
	
	  return clipboard;
	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(186).setImmediate))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(55).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(186).setImmediate, __webpack_require__(186).clearImmediate))

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Clipboard, DatasetPositionView, Marionette, Toast, V3, app, constants, utils,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Marionette = __webpack_require__(49);
	
	Clipboard = __webpack_require__(185);
	
	app = __webpack_require__(48);
	
	constants = __webpack_require__(61);
	
	utils = __webpack_require__(188);
	
	Toast = __webpack_require__(18);
	
	V3 = __webpack_require__(189).V3;
	
	DatasetPositionView = (function(superClass) {
	  extend(DatasetPositionView, superClass);
	
	  function DatasetPositionView() {
	    return DatasetPositionView.__super__.constructor.apply(this, arguments);
	  }
	
	  DatasetPositionView.prototype.tagName = "div";
	
	  DatasetPositionView.prototype.className = "form-inline dataset-position-view";
	
	  DatasetPositionView.prototype.template = _.template("<div class=\"form-group\">\n  <div class=\"input-group\">\n    <span class=\"input-group-btn\">\n      <button class=\"btn btn-primary\">Position</button>\n    </span>\n    <input id=\"trace-position-input\" class=\"form-control\" type=\"text\" value=\"<%- position() %>\">\n  </div>\n</div>\n<div class=\"form-group\">\n  <% if(isArbitrayMode) { %>\n    <div class=\"input-group\">\n      <span class=\"input-group-addon\">Rotation</span>\n      <input id=\"trace-rotation-input\" class=\"form-control\" type=\"text\" value=\"<%- rotation() %>\">\n    </div>\n  <% } %>\n</div>");
	
	  DatasetPositionView.prototype.templateHelpers = {
	    position: function() {
	      return V3.floor(this.flycam.getPosition()).join(", ");
	    },
	    rotation: function() {
	      return V3.round(this.flycam3d.getRotation()).join(", ");
	    }
	  };
	
	  DatasetPositionView.prototype.events = {
	    "change #trace-position-input": "changePosition",
	    "change #trace-rotation-input": "changeRotation",
	    "click button": "copyToClipboard"
	  };
	
	  DatasetPositionView.prototype.ui = {
	    "positionInput": "#trace-position-input",
	    "rotationInput": "#trace-rotation-input"
	  };
	
	  DatasetPositionView.prototype.initialize = function(options) {
	    this.viewMode = constants.MODE_PLANE_TRACING;
	    this.listenTo(this.model, "change:mode", this.updateViewMode);
	    this.listenTo(this.model.get("flycam3d"), "changed", this.render);
	    return this.listenTo(this.model.get("flycam"), "positionChanged", this.render);
	  };
	
	  DatasetPositionView.prototype.serializeData = function() {
	    var ref;
	    return _.extend(this.model, {
	      isArbitrayMode: (ref = this.viewMode, indexOf.call(constants.MODES_ARBITRARY, ref) >= 0)
	    });
	  };
	
	  DatasetPositionView.prototype.updateViewMode = function(viewMode) {
	    this.viewMode = viewMode;
	    return this.render();
	  };
	
	  DatasetPositionView.prototype.changePosition = function(event) {
	    var posArray;
	    posArray = utils.stringToNumberArray(event.target.value);
	    if (posArray.length === 3) {
	      this.model.flycam.setPosition(posArray);
	      app.vent.trigger("centerTDView");
	      this.ui.positionInput.get(0).setCustomValidity("");
	    } else {
	      this.ui.positionInput.get(0).setCustomValidity("Please supply a valid position, like 1,1,1!");
	      this.ui.positionInput.get(0).reportValidity();
	    }
	  };
	
	  DatasetPositionView.prototype.changeRotation = function(event) {
	    var rotArray;
	    rotArray = utils.stringToNumberArray(event.target.value);
	    if (rotArray.length === 3) {
	      this.model.flycam3d.setRotation(rotArray);
	      this.ui.rotationInput.get(0).setCustomValidity("");
	    } else {
	      this.ui.rotationInput.get(0).setCustomValidity("Please supply a valid rotation, like 1,1,1!");
	      this.ui.rotationInput.get(0).reportValidity();
	    }
	  };
	
	  DatasetPositionView.prototype.copyToClipboard = function(evt) {
	    var positionString;
	    evt.preventDefault();
	    positionString = this.ui.positionInput.val();
	    return Clipboard.copy(positionString).then(function() {
	      return Toast.success("Position copied to clipboard");
	    });
	  };
	
	  DatasetPositionView.prototype.onDestroy = function() {
	    this.model.flycam3d.off("changed");
	    return this.model.flycam.off("positionChanged");
	  };
	
	  return DatasetPositionView;
	
	})(Marionette.ItemView);
	
	module.exports = DatasetPositionView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {var $, Utils, _;
	
	$ = __webpack_require__(1);
	
	_ = __webpack_require__(2);
	
	Utils = {
	  clamp: function(a, x, b) {
	    return Math.max(a, Math.min(b, x));
	  },
	  zeroPad: function(num, zeros) {
	    if (zeros == null) {
	      zeros = 0;
	    }
	    num = "" + num;
	    while (num.length < zeros) {
	      num = "0" + num;
	    }
	    return num;
	  },
	  unflatten: function(array, tupleSize) {
	    var i, j, ref, ref1, results;
	    results = [];
	    for (i = j = 0, ref = array.length, ref1 = tupleSize; ref1 > 0 ? j < ref : j > ref; i = j += ref1) {
	      results.push(array.slice(i, i + tupleSize));
	    }
	    return results;
	  },
	  sum: function(array, iterator) {
	    if (_.isString(iterator) || _.isNumber(iterator)) {
	      return array.reduce((function(r, a) {
	        return r + a[iterator];
	      }), 0);
	    } else {
	      return array.reduce((function(r, a) {
	        return r + a;
	      }), 0);
	    }
	  },
	  roundTo: function(value, digits) {
	    var digitMultiplier;
	    digitMultiplier = Math.pow(10, digits);
	    return Math.round(value * digitMultiplier) / digitMultiplier;
	  },
	  intToHex: function(int, digits) {
	    if (digits == null) {
	      digits = 6;
	    }
	    return (_.repeat("0", digits) + int.toString(16)).slice(-digits);
	  },
	  rgbToHex: function(color) {
	    return "#" + color.map(function(int) {
	      return Utils.intToHex(int, 2);
	    }).join("");
	  },
	  hexToRgb: function(hex) {
	    var b, bigint, g, r;
	    bigint = parseInt(hex.slice(1), 16);
	    r = (bigint >> 16) & 255;
	    g = (bigint >> 8) & 255;
	    b = bigint & 255;
	    return [r, g, b];
	  },
	  stringToNumberArray: function(s) {
	    var e, j, len, newEl, result, stringArray;
	    s = s.trim();
	    s = s.replace(/,?\s+,?/g, ",");
	    stringArray = s.split(",");
	    result = [];
	    for (j = 0, len = stringArray.length; j < len; j++) {
	      e = stringArray[j];
	      if (!isNaN(newEl = parseFloat(e))) {
	        result.push(newEl);
	      }
	    }
	    return result;
	  },
	  loaderTemplate: function() {
	    return "<div id=\"loader-icon\">\n  <i class=\"fa fa-spinner fa-spin fa-4x\"></i>\n  <br>Loading\n</div>";
	  },
	  isElementInViewport: function(el) {
	    var rect;
	    if (typeof jQuery === "function" && el instanceof jQuery) {
	      el = el[0];
	    }
	    rect = el.getBoundingClientRect();
	    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
	  },
	  isUserAdmin: function(user) {
	    if (user == null) {
	      return false;
	    } else {
	      return _.findIndex(user.get("teams"), function(team) {
	        return team.role.name === "admin";
	      }) >= 0;
	    }
	  }
	};
	
	module.exports = Utils;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var M4x4, V2, V3, ref;
	
	ref = __webpack_require__(190)(Float32Array), M4x4 = ref.M4x4, V2 = ref.V2, V3 = ref.V3;
	
	M4x4.transformPointsAffine = function(m, points, r) {
	  var i, j, m00, m01, m02, m10, m11, m12, m20, m21, m22, m30, m31, m32, ref1, v0, v1, v2;
	  if (r == null) {
	    r = new Float32Array(points.length);
	  }
	  m00 = m[0];
	  m01 = m[1];
	  m02 = m[2];
	  m10 = m[4];
	  m11 = m[5];
	  m12 = m[6];
	  m20 = m[8];
	  m21 = m[9];
	  m22 = m[10];
	  m30 = m[12];
	  m31 = m[13];
	  m32 = m[14];
	  for (i = j = 0, ref1 = points.length; j < ref1; i = j += 3) {
	    v0 = points[i];
	    v1 = points[i + 1];
	    v2 = points[i + 2];
	    r[i] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
	    r[i + 1] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
	    r[i + 2] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
	  }
	  return r;
	};
	
	M4x4.transformPoints = function(m, points, r) {
	  var i, j, ref1, v0, v1, v2, w;
	  if (r == null) {
	    r = new Float32Array(points.length);
	  }
	  for (i = j = 0, ref1 = points.length; j < ref1; i = j += 3) {
	    v0 = points[i];
	    v1 = points[i + 1];
	    v2 = points[i + 2];
	    r[i] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12];
	    r[i + 1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13];
	    r[i + 2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14];
	    w = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15];
	    if (w !== 1.0) {
	      r[0] /= w;
	      r[1] /= w;
	      r[2] /= w;
	    }
	  }
	  return r;
	};
	
	M4x4.inverse = function(mat, dest) {
	  var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, invDet;
	  if (dest == null) {
	    dest = new Float32Array(16);
	  }
	  a00 = mat[0];
	  a01 = mat[1];
	  a02 = mat[2];
	  a03 = mat[3];
	  a10 = mat[4];
	  a11 = mat[5];
	  a12 = mat[6];
	  a13 = mat[7];
	  a20 = mat[8];
	  a21 = mat[9];
	  a22 = mat[10];
	  a23 = mat[11];
	  a30 = mat[12];
	  a31 = mat[13];
	  a32 = mat[14];
	  a33 = mat[15];
	  b00 = a00 * a11 - a01 * a10;
	  b01 = a00 * a12 - a02 * a10;
	  b02 = a00 * a13 - a03 * a10;
	  b03 = a01 * a12 - a02 * a11;
	  b04 = a01 * a13 - a03 * a11;
	  b05 = a02 * a13 - a03 * a12;
	  b06 = a20 * a31 - a21 * a30;
	  b07 = a20 * a32 - a22 * a30;
	  b08 = a20 * a33 - a23 * a30;
	  b09 = a21 * a32 - a22 * a31;
	  b10 = a21 * a33 - a23 * a31;
	  b11 = a22 * a33 - a23 * a32;
	  invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
	  dest = [];
	  dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
	  dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
	  dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
	  dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
	  dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
	  dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
	  dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
	  dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
	  dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
	  dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
	  dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
	  dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
	  dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
	  dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
	  dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
	  dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
	  return dest;
	};
	
	M4x4.extractTranslation = function(m, r) {
	  if (r == null) {
	    r = new Float32Array(3);
	  }
	  r[0] = m[12];
	  r[1] = m[13];
	  r[2] = m[14];
	  return r;
	};
	
	V3.round = function(v, r) {
	  if (r == null) {
	    r = new Float32Array(3);
	  }
	  r[0] = Math.round(v[0]);
	  r[1] = Math.round(v[1]);
	  r[2] = Math.round(v[2]);
	  return r;
	};
	
	V3.floor = function(v) {
	  return v.map(function(number) {
	    return Math.floor(number);
	  });
	};
	
	V3.toString = function(v) {
	  return v.join(", ");
	};
	
	module.exports = {
	  M4x4: M4x4,
	  V2: V2,
	  V3: V3
	};


/***/ },
/* 190 */
/***/ function(module, exports) {

	"use strict";
	
	/* -*- Mode: js2; js2-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40; -*- */
	/*
	 * Copyright (c) 2010 Mozilla Corporation
	 * Copyright (c) 2010 Vladimir Vukicevic
	 *
	 * Permission is hereby granted, free of charge, to any person
	 * obtaining a copy of this software and associated documentation
	 * files (the "Software"), to deal in the Software without
	 * restriction, including without limitation the rights to use,
	 * copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the
	 * Software is furnished to do so, subject to the following
	 * conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	 * OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	/*
	 * File: mjs
	 *
	 * Vector and Matrix math utilities for JavaScript, optimized for WebGL.
	 */
	
	module.exports = MJS;
	function MJS(MJS_FLOAT_ARRAY_TYPE) {
	
		var mJS = {};
	
		if(!MJS_FLOAT_ARRAY_TYPE) {
			if(typeof Float32Array === "undefined") {
				MJS_FLOAT_ARRAY_TYPE = Array;
			} else if(typeof WebGLFloatArray === "undefined") {
				MJS_FLOAT_ARRAY_TYPE = Float32Array;
			} else {
				MJS_FLOAT_ARRAY_TYPE = WebGLFloatArray;
			}
		}
	
		// Some hacks for running in both the shell and browser,
		// and for supporting F32 and WebGLFloat arrays
		//    try { WebGLFloatArray; } catch (x) { WebGLFloatArray = Float32Array; }
	
		/*
		 * Constant: MJS_FLOAT_ARRAY_TYPE
		 *
		 * The base float array type.  By default, WebGLFloatArray.
		 *
		 * mjs can work with any array-like elements, but if an array
		 * creation is requested, it will create an array of the type
		 * MJS_FLOAT_ARRAY_TYPE.  Also, the builtin constants such as (M4x4.I)
		 * will be of this type.
		 */
	
		/*
		 * Class: V2
		 *
		 * Methods for working with 2-element vectors.  A vector is represented by a 2-element array.
		 * Any valid JavaScript array type may be used, but if new
		 * vectors are created they are created using the configured MJS_FLOAT_ARRAY_TYPE.
		 */
	
		var V2 = { };
		mJS.V2 = V2;
	
		V2._temp1 = new MJS_FLOAT_ARRAY_TYPE(2);
		V2._temp2 = new MJS_FLOAT_ARRAY_TYPE(2);
		V2._temp3 = new MJS_FLOAT_ARRAY_TYPE(2);
	
		if (MJS_FLOAT_ARRAY_TYPE == Array) {
			V2.x = [1.0, 0.0];
			V2.y = [0.0, 1.0];
	
			V2.$ = function V2_$(x, y) {
				return [x, y];
			};
	
			V2.clone = function V2_clone(a) {
				return [a[0], a[1]];
			};
		} else {
			V2.x = new MJS_FLOAT_ARRAY_TYPE([1.0, 0.0]);
			V2.y = new MJS_FLOAT_ARRAY_TYPE([0.0, 1.0]);
	
		/*
		 * Function: V2.$
		 *
		 * Creates a new 2-element vector with the given values.
		 *
		 * Parameters:
		 *
		 *   x,y - the 2 elements of the new vector.
		 *
		 * Returns:
		 *
		 * A new vector containing with the given argument values.
		 */
	
			V2.$ = function V2_$(x, y) {
				return new MJS_FLOAT_ARRAY_TYPE([x, y]);
			};
	
		/*
		 * Function: V2.clone
		 *
		 * Clone the given 2-element vector.
		 *
		 * Parameters:
		 *
		 *   a - the 2-element vector to clone
		 *
		 * Returns:
		 *
		 * A new vector with the same values as the passed-in one.
		 */
	
			V2.clone = function V2_clone(a) {
				return new MJS_FLOAT_ARRAY_TYPE(a);
			};
		}
	
		V2.u = V2.x;
		V2.v = V2.y;
	
		/*
		 * Function: V2.add
		 *
		 * Perform r = a + b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 2-element vector with the result.
		 */
		V2.add = function V2_add(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(2);
			r[0] = a[0] + b[0];
			r[1] = a[1] + b[1];
			return r;
		};
	
		/*
		 * Function: V2.sub
		 *
		 * Perform
		 * r = a - b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 2-element vector with the result.
		 */
		V2.sub = function V2_sub(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(2);
			r[0] = a[0] - b[0];
			r[1] = a[1] - b[1];
			return r;
		};
	
		/*
		 * Function: V2.neg
		 *
		 * Perform
		 * r = - a.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 2-element vector with the result.
		 */
		V2.neg = function V2_neg(a, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(2);
			r[0] = - a[0];
			r[1] = - a[1];
			return r;
		};
	
		/*
		 * Function: V2.direction
		 *
		 * Perform
		 * r = (a - b) / |a - b|.  The result is the normalized
		 * direction from a to b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 2-element vector with the result.
		 */
		V2.direction = function V2_direction(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(2);
			return V2.normalize(V2.sub(a, b, r), r);
		};
	
		/*
		 * Function: V2.length
		 *
		 * Perform r = |a|.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *
		 * Returns:
		 *
		 *   The length of the given vector.
		 */
		V2.length = function V2_length(a) {
			return Math.sqrt(a[0]*a[0] + a[1]*a[1]);
		};
	
		/*
		 * Function: V2.lengthSquard
		 *
		 * Perform r = |a|*|a|.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *
		 * Returns:
		 *
		 *   The square of the length of the given vector.
		 */
		V2.lengthSquared = function V2_lengthSquared(a) {
			return a[0]*a[0] + a[1]*a[1];
		};
	
		/*
		 * Function: V2.normalize
		 *
		 * Perform r = a / |a|.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 2-element vector with the result.
		 */
		V2.normalize = function V2_normalize(a, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(2);
			var im = 1.0 / V2.length(a);
			r[0] = a[0] * im;
			r[1] = a[1] * im;
			return r;
		};
	
		/*
		 * Function: V2.scale
		 *
		 * Perform r = a * k.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *   k - a scalar value
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 2-element vector with the result.
		 */
		V2.scale = function V2_scale(a, k, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(2);
			r[0] = a[0] * k;
			r[1] = a[1] * k;
			return r;
		};
	
		/*
		 * Function: V2.dot
		 *
		 * Perform
		 * r = dot(a, b).
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *
		 * Returns:
		 *
		 *   The dot product of a and b.
		 */
		V2.dot = function V2_dot(a, b) {
			return a[0] * b[0] +
				a[1] * b[1];
		};
	
		/*
		 * Class: V3
		 *
		 * Methods for working with 3-element vectors.  A vector is represented by a 3-element array.
		 * Any valid JavaScript array type may be used, but if new
		 * vectors are created they are created using the configured MJS_FLOAT_ARRAY_TYPE.
		 */
	
		var V3 = { };
		mJS.V3 = V3;
	
		V3._temp1 = new MJS_FLOAT_ARRAY_TYPE(3);
		V3._temp2 = new MJS_FLOAT_ARRAY_TYPE(3);
		V3._temp3 = new MJS_FLOAT_ARRAY_TYPE(3);
	
		if (MJS_FLOAT_ARRAY_TYPE == Array) {
			V3.x = [1.0, 0.0, 0.0];
			V3.y = [0.0, 1.0, 0.0];
			V3.z = [0.0, 0.0, 1.0];
	
			V3.$ = function V3_$(x, y, z) {
				return [x, y, z];
			};
	
			V3.clone = function V3_clone(a) {
				return [a[0], a[1], a[2]];
			};
		} else {
			V3.x = new MJS_FLOAT_ARRAY_TYPE([1.0, 0.0, 0.0]);
			V3.y = new MJS_FLOAT_ARRAY_TYPE([0.0, 1.0, 0.0]);
			V3.z = new MJS_FLOAT_ARRAY_TYPE([0.0, 0.0, 1.0]);
	
		/*
		 * Function: V3.$
		 *
		 * Creates a new 3-element vector with the given values.
		 *
		 * Parameters:
		 *
		 *   x,y,z - the 3 elements of the new vector.
		 *
		 * Returns:
		 *
		 * A new vector containing with the given argument values.
		 */
	
			V3.$ = function V3_$(x, y, z) {
				return new MJS_FLOAT_ARRAY_TYPE([x, y, z]);
			};
	
		/*
		 * Function: V3.clone
		 *
		 * Clone the given 3-element vector.
		 *
		 * Parameters:
		 *
		 *   a - the 3-element vector to clone
		 *
		 * Returns:
		 *
		 * A new vector with the same values as the passed-in one.
		 */
	
			V3.clone = function V3_clone(a) {
				return new MJS_FLOAT_ARRAY_TYPE(a);
			};
		}
	
		V3.u = V3.x;
		V3.v = V3.y;
	
		/*
		 * Function: V3.add
		 *
		 * Perform r = a + b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.add = function V3_add(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			r[0] = a[0] + b[0];
			r[1] = a[1] + b[1];
			r[2] = a[2] + b[2];
			return r;
		};
	
		/*
		 * Function: V3.sub
		 *
		 * Perform
		 * r = a - b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.sub = function V3_sub(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			r[0] = a[0] - b[0];
			r[1] = a[1] - b[1];
			r[2] = a[2] - b[2];
			return r;
		};
	
		/*
		 * Function: V3.neg
		 *
		 * Perform
		 * r = - a.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.neg = function V3_neg(a, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			r[0] = - a[0];
			r[1] = - a[1];
			r[2] = - a[2];
			return r;
		};
	
		/*
		 * Function: V3.direction
		 *
		 * Perform
		 * r = (a - b) / |a - b|.  The result is the normalized
		 * direction from a to b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.direction = function V3_direction(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			return V3.normalize(V3.sub(a, b, r), r);
		};
	
		/*
		 * Function: V3.length
		 *
		 * Perform r = |a|.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *
		 * Returns:
		 *
		 *   The length of the given vector.
		 */
		V3.length = function V3_length(a) {
			return Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
		};
	
		/*
		 * Function: V3.lengthSquard
		 *
		 * Perform r = |a|*|a|.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *
		 * Returns:
		 *
		 *   The square of the length of the given vector.
		 */
		V3.lengthSquared = function V3_lengthSquared(a) {
			return a[0]*a[0] + a[1]*a[1] + a[2]*a[2];
		};
	
		/*
		 * Function: V3.normalize
		 *
		 * Perform r = a / |a|.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.normalize = function V3_normalize(a, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			var im = 1.0 / V3.length(a);
			r[0] = a[0] * im;
			r[1] = a[1] * im;
			r[2] = a[2] * im;
			return r;
		};
	
		/*
		 * Function: V3.scale
		 *
		 * Perform r = a * k.
		 *
		 * Parameters:
		 *
		 *   a - the vector operand
		 *   k - a scalar value
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.scale = function V3_scale(a, k, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			r[0] = a[0] * k;
			r[1] = a[1] * k;
			r[2] = a[2] * k;
			return r;
		};
	
		/*
		 * Function: V3.dot
		 *
		 * Perform
		 * r = dot(a, b).
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *
		 * Returns:
		 *
		 *   The dot product of a and b.
		 */
		V3.dot = function V3_dot(a, b) {
			return a[0] * b[0] +
				a[1] * b[1] +
				a[2] * b[2];
		};
	
		/*
		 * Function: V3.cross
		 *
		 * Perform r = a x b.
		 *
		 * Parameters:
		 *
		 *   a - the first vector operand
		 *   b - the second vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 */
		V3.cross = function V3_cross(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			r[0] = a[1]*b[2] - a[2]*b[1];
			r[1] = a[2]*b[0] - a[0]*b[2];
			r[2] = a[0]*b[1] - a[1]*b[0];
			return r;
		};
	
		/*
		 * Function: V3.mul4x4
		 *
		 * Perform
		 * r = m * v.
		 *
		 * Parameters:
		 *
		 *   m - the 4x4 matrix operand
		 *   v - the 3-element vector operand
		 *   r - optional vector to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3-element vector with the result.
		 *   The 4-element result vector is divided by the w component
		 *   and returned as a 3-element vector.
		 */
		V3.mul4x4 = function V3_mul4x4(m, v, r) {
			var w;
			var tmp = V3._temp1;
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
			tmp[0] = m[ 3];
			tmp[1] = m[ 7];
			tmp[2] = m[11];
			w    =  V3.dot(v, tmp) + m[15];
			tmp[0] = m[ 0];
			tmp[1] = m[ 4];
			tmp[2] = m[ 8];
			r[0] = (V3.dot(v, tmp) + m[12])/w;
			tmp[0] = m[ 1];
			tmp[1] = m[ 5];
			tmp[2] = m[ 9];
			r[1] = (V3.dot(v, tmp) + m[13])/w;
			tmp[0] = m[ 2];
			tmp[1] = m[ 6];
			tmp[2] = m[10];
			r[2] = (V3.dot(v, tmp) + m[14])/w;
			return r;
		};
	
		/*
		 * Class: M4x4
		 *
		 * Methods for working with 4x4 matrices.  A matrix is represented by a 16-element array
		 * in column-major order.  Any valid JavaScript array type may be used, but if new
		 * matrices are created they are created using the configured MJS_FLOAT_ARRAY_TYPE.
		 */
	
		var M4x4 = { };
		mJS.M4x4 = M4x4;
	
		M4x4._temp1 = new MJS_FLOAT_ARRAY_TYPE(16);
		M4x4._temp2 = new MJS_FLOAT_ARRAY_TYPE(16);
	
		if (MJS_FLOAT_ARRAY_TYPE == Array) {
			M4x4.I = [1.0, 0.0, 0.0, 0.0,
					  0.0, 1.0, 0.0, 0.0,
					  0.0, 0.0, 1.0, 0.0,
					  0.0, 0.0, 0.0, 1.0];
	
			M4x4.$ = function M4x4_$(m00, m01, m02, m03,
									 m04, m05, m06, m07,
									 m08, m09, m10, m11,
									 m12, m13, m14, m15)
			{
				return [m00, m01, m02, m03,
						m04, m05, m06, m07,
						m08, m09, m10, m11,
						m12, m13, m14, m15];
			};
	
			M4x4.clone = function M4x4_clone(m) {
				return [m[0], m[1], m[2], m[3],
						m[4], m[5], m[6], m[7],
						m[8], m[9], m[10], m[11],
						m[12], m[13], m[14], m[15]];
			};
		} else {
			M4x4.I = new MJS_FLOAT_ARRAY_TYPE([1.0, 0.0, 0.0, 0.0,
										   0.0, 1.0, 0.0, 0.0,
										   0.0, 0.0, 1.0, 0.0,
										   0.0, 0.0, 0.0, 1.0]);
	
		/*
		 * Function: M4x4.$
		 *
		 * Creates a new 4x4 matrix with the given values.
		 *
		 * Parameters:
		 *
		 *   m00..m15 - the 16 elements of the new matrix.
		 *
		 * Returns:
		 *
		 * A new matrix filled with the given argument values.
		 */
			M4x4.$ = function M4x4_$(m00, m01, m02, m03,
									 m04, m05, m06, m07,
									 m08, m09, m10, m11,
									 m12, m13, m14, m15)
			{
				return new MJS_FLOAT_ARRAY_TYPE([m00, m01, m02, m03,
												 m04, m05, m06, m07,
												 m08, m09, m10, m11,
												 m12, m13, m14, m15]);
			};
	
		/*
		 * Function: M4x4.clone
		 *
		 * Clone the given 4x4 matrix.
		 *
		 * Parameters:
		 *
		 *   m - the 4x4 matrix to clone
		 *
		 * Returns:
		 *
		 * A new matrix with the same values as the passed-in one.
		 */
			M4x4.clone = function M4x4_clone(m) {
				return new MJS_FLOAT_ARRAY_TYPE(m);
			};
		}
	
		M4x4.identity = M4x4.I;
	
		/*
		 * Function: M4x4.topLeft3x3
		 *
		 * Return the top left 3x3 matrix from the given 4x4 matrix m.
		 *
		 * Parameters:
		 *
		 *   m - the matrix
		 *   r - optional 3x3 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3x3 matrix with the result.
		 */
		M4x4.topLeft3x3 = function M4x4_topLeft3x3(m, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(9);
			r[0] = m[0]; r[1] = m[1]; r[2] = m[2];
			r[3] = m[4]; r[4] = m[5]; r[5] = m[6];
			r[6] = m[8]; r[7] = m[9]; r[8] = m[10];
			return r;
		};
	
		/*
		 * Function: M4x4.inverseOrthonormal
		 *
		 * Computes the inverse of the given matrix m, assuming that
		 * the matrix is orthonormal.
		 *
		 * Parameters:
		 *
		 *   m - the matrix
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.inverseOrthonormal = function M4x4_inverseOrthonormal(m, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
			M4x4.transpose(m, r);
			var t = [m[12], m[13], m[14]];
			r[3] = r[7] = r[11] = 0;
			r[12] = -V3.dot([r[0], r[4], r[8]], t);
			r[13] = -V3.dot([r[1], r[5], r[9]], t);
			r[14] = -V3.dot([r[2], r[6], r[10]], t);
			return r;
		};
	
		/*
		 * Function: M4x4.inverseTo3x3
		 *
		 * Computes the inverse of the given matrix m, but calculates
		 * only the top left 3x3 values of the result.
		 *
		 * Parameters:
		 *
		 *   m - the matrix
		 *   r - optional 3x3 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 3x3 matrix with the result.
		 */
		M4x4.inverseTo3x3 = function M4x4_inverseTo3x3(m, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(9);
	
			var a11 = m[10]*m[5]-m[6]*m[9],
				a21 = -m[10]*m[1]+m[2]*m[9],
				a31 = m[6]*m[1]-m[2]*m[5],
				a12 = -m[10]*m[4]+m[6]*m[8],
				a22 = m[10]*m[0]-m[2]*m[8],
				a32 = -m[6]*m[0]+m[2]*m[4],
				a13 = m[9]*m[4]-m[5]*m[8],
				a23 = -m[9]*m[0]+m[1]*m[8],
				a33 = m[5]*m[0]-m[1]*m[4];
			var det = m[0]*(a11) + m[1]*(a12) + m[2]*(a13);
			if (det == 0) // no inverse
				throw "matrix not invertible";
			var idet = 1.0 / det;
	
			r[0] = idet*a11;
			r[1] = idet*a21;
			r[2] = idet*a31;
			r[3] = idet*a12;
			r[4] = idet*a22;
			r[5] = idet*a32;
			r[6] = idet*a13;
			r[7] = idet*a23;
			r[8] = idet*a33;
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeFrustum
		 *
		 * Creates a matrix for a projection frustum with the given parameters.
		 *
		 * Parameters:
		 *
		 *   left - the left coordinate of the frustum
		 *   right- the right coordinate of the frustum
		 *   bottom - the bottom coordinate of the frustum
		 *   top - the top coordinate of the frustum
		 *   znear - the near z distance of the frustum
		 *   zfar - the far z distance of the frustum
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the projection matrix.
		 *   Otherwise, returns a new 4x4 matrix.
		 */
		M4x4.makeFrustum = function M4x4_makeFrustum(left, right, bottom, top, znear, zfar, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			var X = 2*znear/(right-left);
			var Y = 2*znear/(top-bottom);
			var A = (right+left)/(right-left);
			var B = (top+bottom)/(top-bottom);
			var C = -(zfar+znear)/(zfar-znear);
			var D = -2*zfar*znear/(zfar-znear);
	
			r[0] = 2*znear/(right-left);
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 2*znear/(top-bottom);
			r[6] = 0;
			r[7] = 0;
			r[8] = (right+left)/(right-left);
			r[9] = (top+bottom)/(top-bottom);
			r[10] = -(zfar+znear)/(zfar-znear);
			r[11] = -1;
			r[12] = 0;
			r[13] = 0;
			r[14] = -2*zfar*znear/(zfar-znear);
			r[15] = 0;
	
			return r;
		};
	
		/*
		 * Function: M4x4.makePerspective
		 *
		 * Creates a matrix for a perspective projection with the given parameters.
		 *
		 * Parameters:
		 *
		 *   fovy - field of view in the y axis, in degrees
		 *   aspect - aspect ratio
		 *   znear - the near z distance of the projection
		 *   zfar - the far z distance of the projection
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the projection matrix.
		 *   Otherwise, returns a new 4x4 matrix.
		 */
		M4x4.makePerspective = function M4x4_makePerspective (fovy, aspect, znear, zfar, r) {
			var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
			var ymin = -ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return M4x4.makeFrustum(xmin, xmax, ymin, ymax, znear, zfar, r);
		};
	
		/*
		 * Function: M4x4.makeOrtho
		 *
		 * Creates a matrix for an orthogonal frustum projection with the given parameters.
		 *
		 * Parameters:
		 *
		 *   left - the left coordinate of the frustum
		 *   right- the right coordinate of the frustum
		 *   bottom - the bottom coordinate of the frustum
		 *   top - the top coordinate of the frustum
		 *   znear - the near z distance of the frustum
		 *   zfar - the far z distance of the frustum
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the projection matrix.
		 *   Otherwise, returns a new 4x4 matrix.
		 */
		M4x4.makeOrtho = function M4x4_makeOrtho (left, right, bottom, top, znear, zfar, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			var tX = -(right+left)/(right-left);
			var tY = -(top+bottom)/(top-bottom);
			var tZ = -(zfar+znear)/(zfar-znear);
			var X = 2 / (right-left);
			var Y = 2 / (top-bottom);
			var Z = -2 / (zfar-znear);
	
			r[0] = 2 / (right-left);
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 2 / (top-bottom);
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = -2 / (zfar-znear);
			r[11] = 0;
			r[12] = -(right+left)/(right-left);
			r[13] = -(top+bottom)/(top-bottom);
			r[14] = -(zfar+znear)/(zfar-znear);
			r[15] = 1;
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeOrtho
		 *
		 * Creates a matrix for a 2D orthogonal frustum projection with the given parameters.
		 * znear and zfar are assumed to be -1 and 1, respectively.
		 *
		 * Parameters:
		 *
		 *   left - the left coordinate of the frustum
		 *   right- the right coordinate of the frustum
		 *   bottom - the bottom coordinate of the frustum
		 *   top - the top coordinate of the frustum
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the projection matrix.
		 *   Otherwise, returns a new 4x4 matrix.
		 */
		M4x4.makeOrtho2D = function M4x4_makeOrtho2D (left, right, bottom, top, r) {
			return M4x4.makeOrtho(left, right, bottom, top, -1, 1, r);
		};
	
		/*
		 * Function: M4x4.mul
		 *
		 * Performs r = a * b.
		 *
		 * Parameters:
		 *
		 *   a - the first matrix operand
		 *   b - the second matrix operand
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.mul = function M4x4_mul(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			var a11 = a[0];
			var a21 = a[1];
			var a31 = a[2];
			var a41 = a[3];
			var a12 = a[4];
			var a22 = a[5];
			var a32 = a[6];
			var a42 = a[7];
			var a13 = a[8];
			var a23 = a[9];
			var a33 = a[10];
			var a43 = a[11];
			var a14 = a[12];
			var a24 = a[13];
			var a34 = a[14];
			var a44 = a[15];
	
			var b11 = b[0];
			var b21 = b[1];
			var b31 = b[2];
			var b41 = b[3];
			var b12 = b[4];
			var b22 = b[5];
			var b32 = b[6];
			var b42 = b[7];
			var b13 = b[8];
			var b23 = b[9];
			var b33 = b[10];
			var b43 = b[11];
			var b14 = b[12];
			var b24 = b[13];
			var b34 = b[14];
			var b44 = b[15];
	
			r[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			r[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			r[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			r[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			r[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			r[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			r[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			r[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			r[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			r[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			r[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			r[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			r[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			r[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			r[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			r[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return r;
		};
	
		/*
		 * Function: M4x4.mulOffset
		 *
		 * Performs r' = a * b, where r' is the 16 elements of r starting at element o.
		 *
		 * Parameters:
		 *
		 *   a - the first matrix operand
		 *   b - the second matrix operand
		 *   r - array to store the result in
		 *   o - offset into r at which to start storing results
		 *
		 * Returns:
		 *
		 *   r
		 */
		M4x4.mulOffset = function M4x4_mulOffset(a, b, r, o) {
			var a21 = a[1];
			var a31 = a[2];
			var a41 = a[3];
			var a12 = a[4];
			var a22 = a[5];
			var a32 = a[6];
			var a42 = a[7];
			var a13 = a[8];
			var a23 = a[9];
			var a33 = a[10];
			var a43 = a[11];
			var a14 = a[12];
			var a24 = a[13];
			var a34 = a[14];
			var a44 = a[15];
	
			var b11 = b[0];
			var b21 = b[1];
			var b31 = b[2];
			var b41 = b[3];
			var b12 = b[4];
			var b22 = b[5];
			var b32 = b[6];
			var b42 = b[7];
			var b13 = b[8];
			var b23 = b[9];
			var b33 = b[10];
			var b43 = b[11];
			var b14 = b[12];
			var b24 = b[13];
			var b34 = b[14];
			var b44 = b[15];
	
			r[o+0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			r[o+1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			r[o+2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			r[o+3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			r[o+4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			r[o+5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			r[o+6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			r[o+7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			r[o+8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			r[o+9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			r[o+10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			r[o+11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			r[o+12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			r[o+13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			r[o+14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			r[o+15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return r;
		};
	
		/*
		 * Function: M4x4.mulAffine
		 *
		 * Performs r = a * b, assuming a and b are affine (elements 3,7,11,15 = 0,0,0,1)
		 *
		 * Parameters:
		 *
		 *   a - the first matrix operand
		 *   b - the second matrix operand
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.mulAffine = function M4x4_mulAffine(a, b, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
			var a11 = a[0];
			var a21 = a[1];
			var a31 = a[2];
			var a12 = a[4];
			var a22 = a[5];
			var a32 = a[6];
			var a13 = a[8];
			var a23 = a[9];
			var a33 = a[10];
			var a14 = a[12];
			var a24 = a[13];
			var a34 = a[14];
	
			var b11 = b[0];
			var b21 = b[1];
			var b31 = b[2];
			var b12 = b[4];
			var b22 = b[5];
			var b32 = b[6];
			var b13 = b[8];
			var b23 = b[9];
			var b33 = b[10];
			var b14 = b[12];
			var b24 = b[13];
			var b34 = b[14];
	
			r[0] = a11 * b11 + a12 * b21 + a13 * b31;
			r[1] = a21 * b11 + a22 * b21 + a23 * b31;
			r[2] = a31 * b11 + a32 * b21 + a33 * b31;
			r[3] = 0;
			r[4] = a11 * b12 + a12 * b22 + a13 * b32;
			r[5] = a21 * b12 + a22 * b22 + a23 * b32;
			r[6] = a31 * b12 + a32 * b22 + a33 * b32;
			r[7] = 0;
			r[8] = a11 * b13 + a12 * b23 + a13 * b33;
			r[9] = a21 * b13 + a22 * b23 + a23 * b33;
			r[10] = a31 * b13 + a32 * b23 + a33 * b33;
			r[11] = 0;
			r[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14;
			r[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24;
			r[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34;
			r[15] = 1;
	
			return r;
		};
	
		/*
		 * Function: M4x4.mulAffineOffset
		 *
		 * Performs r' = a * b, assuming a and b are affine (elements 3,7,11,15 = 0,0,0,1), where r' is the 16 elements of r starting at element o
		 *
		 * Parameters:
		 *
		 *   a - the first matrix operand
		 *   b - the second matrix operand
		 *   r - array to store the result in
		 *   o - offset into r at which to start storing results
		 *
		 * Returns:
		 *
		 *   r
		 */
		M4x4.mulAffine = function M4x4_mulAffine(a, b, r, o) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
			o = o || 0;
			var a11 = a[0];
			var a21 = a[1];
			var a31 = a[2];
			var a12 = a[4];
			var a22 = a[5];
			var a32 = a[6];
			var a13 = a[8];
			var a23 = a[9];
			var a33 = a[10];
			var a14 = a[12];
			var a24 = a[13];
			var a34 = a[14];
	
			var b11 = b[0];
			var b21 = b[1];
			var b31 = b[2];
			var b12 = b[4];
			var b22 = b[5];
			var b32 = b[6];
			var b13 = b[8];
			var b23 = b[9];
			var b33 = b[10];
			var b14 = b[12];
			var b24 = b[13];
			var b34 = b[14];
	
			r[o+0] = a11 * b11 + a12 * b21 + a13 * b31;
			r[o+1] = a21 * b11 + a22 * b21 + a23 * b31;
			r[o+2] = a31 * b11 + a32 * b21 + a33 * b31;
			r[o+3] = 0;
			r[o+4] = a11 * b12 + a12 * b22 + a13 * b32;
			r[o+5] = a21 * b12 + a22 * b22 + a23 * b32;
			r[o+6] = a31 * b12 + a32 * b22 + a33 * b32;
			r[o+7] = 0;
			r[o+8] = a11 * b13 + a12 * b23 + a13 * b33;
			r[o+9] = a21 * b13 + a22 * b23 + a23 * b33;
			r[o+10] = a31 * b13 + a32 * b23 + a33 * b33;
			r[o+11] = 0;
			r[o+12] = a11 * b14 + a12 * b24 + a13 * b34 + a14;
			r[o+13] = a21 * b14 + a22 * b24 + a23 * b34 + a24;
			r[o+14] = a31 * b14 + a32 * b24 + a33 * b34 + a34;
			r[o+15] = 1;
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeRotate
		 *
		 * Creates a transformation matrix for rotation by angle radians about the 3-element vector axis.
		 *
		 * Parameters:
		 *
		 *   angle - the angle of rotation, in radians
		 *   axis - the axis around which the rotation is performed, a 3-element vector
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the matrix.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.makeRotate = function M4x4_makeRotate(angle, axis, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			axis = V3.normalize(axis, V3._temp1);
			var x = axis[0], y = axis[1], z = axis[2];
			var c = Math.cos(angle);
			var c1 = 1-c;
			var s = Math.sin(angle);
	
			r[0] = x*x*c1+c;
			r[1] = y*x*c1+z*s;
			r[2] = z*x*c1-y*s;
			r[3] = 0;
			r[4] = x*y*c1-z*s;
			r[5] = y*y*c1+c;
			r[6] = y*z*c1+x*s;
			r[7] = 0;
			r[8] = x*z*c1+y*s;
			r[9] = y*z*c1-x*s;
			r[10] = z*z*c1+c;
			r[11] = 0;
			r[12] = 0;
			r[13] = 0;
			r[14] = 0;
			r[15] = 1;
	
			return r;
		};
	
		/*
		 * Function: M4x4.rotate
		 *
		 * Concatenates a rotation of angle radians about the axis to the give matrix m.
		 *
		 * Parameters:
		 *
		 *   angle - the angle of rotation, in radians
		 *   axis - the axis around which the rotation is performed, a 3-element vector
		 *   m - the matrix to concatenate the rotation to
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after performing the operation.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.rotate = function M4x4_rotate(angle, axis, m, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
			var a0=axis [0], a1=axis [1], a2=axis [2];
			var l = Math.sqrt(a0*a0 + a1*a1 + a2*a2);
			var x = a0, y = a1, z = a2;
			if (l != 1.0) {
				var im = 1.0 / l;
				x *= im;
				y *= im;
				z *= im;
			}
			var c = Math.cos(angle);
			var c1 = 1-c;
			var s = Math.sin(angle);
			var xs = x*s;
			var ys = y*s;
			var zs = z*s;
			var xyc1 = x * y * c1;
			var xzc1 = x * z * c1;
			var yzc1 = y * z * c1;
	
			var m11 = m[0];
			var m21 = m[1];
			var m31 = m[2];
			var m41 = m[3];
			var m12 = m[4];
			var m22 = m[5];
			var m32 = m[6];
			var m42 = m[7];
			var m13 = m[8];
			var m23 = m[9];
			var m33 = m[10];
			var m43 = m[11];
	
			var t11 = x * x * c1 + c;
			var t21 = xyc1 + zs;
			var t31 = xzc1 - ys;
			var t12 = xyc1 - zs;
			var t22 = y * y * c1 + c;
			var t32 = yzc1 + xs;
			var t13 = xzc1 + ys;
			var t23 = yzc1 - xs;
			var t33 = z * z * c1 + c;
	
			r[0] = m11 * t11 + m12 * t21 + m13 * t31;
			r[1] = m21 * t11 + m22 * t21 + m23 * t31;
			r[2] = m31 * t11 + m32 * t21 + m33 * t31;
			r[3] = m41 * t11 + m42 * t21 + m43 * t31;
			r[4] = m11 * t12 + m12 * t22 + m13 * t32;
			r[5] = m21 * t12 + m22 * t22 + m23 * t32;
			r[6] = m31 * t12 + m32 * t22 + m33 * t32;
			r[7] = m41 * t12 + m42 * t22 + m43 * t32;
			r[8] = m11 * t13 + m12 * t23 + m13 * t33;
			r[9] = m21 * t13 + m22 * t23 + m23 * t33;
			r[10] = m31 * t13 + m32 * t23 + m33 * t33;
			r[11] = m41 * t13 + m42 * t23 + m43 * t33;
			if (r != m) {
				r[12] = m[12];
				r[13] = m[13];
				r[14] = m[14];
				r[15] = m[15];
			}
			return r;
		};
	
		/*
		 * Function: M4x4.makeScale3
		 *
		 * Creates a transformation matrix for scaling by 3 scalar values, one for
		 * each of the x, y, and z directions.
		 *
		 * Parameters:
		 *
		 *   x - the scale for the x axis
		 *   y - the scale for the y axis
		 *   z - the scale for the z axis
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the matrix.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.makeScale3 = function M4x4_makeScale3(x, y, z, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			r[0] = x;
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = y;
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = z;
			r[11] = 0;
			r[12] = 0;
			r[13] = 0;
			r[14] = 0;
			r[15] = 1;
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeScale1
		 *
		 * Creates a transformation matrix for a uniform scale by a single scalar value.
		 *
		 * Parameters:
		 *
		 *   k - the scale factor
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the matrix.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.makeScale1 = function M4x4_makeScale1(k, r) {
			return M4x4.makeScale3(k, k, k, r);
		};
	
		/*
		 * Function: M4x4.makeScale
		 *
		 * Creates a transformation matrix for scaling each of the x, y, and z axes by the amount
		 * given in the corresponding element of the 3-element vector.
		 *
		 * Parameters:
		 *
		 *   v - the 3-element vector containing the scale factors
		 *   r - optional 4x4 matrix to store the result in
		 *
		 * Returns:
		 *
		 *   If r is specified, returns r after creating the matrix.
		 *   Otherwise, returns a new 4x4 matrix with the result.
		 */
		M4x4.makeScale = function M4x4_makeScale(v, r) {
			return M4x4.makeScale3(v[0], v[1], v[2], r);
		};
	
		/*
		 * Function: M4x4.scale3
		 */
		M4x4.scale3 = function M4x4_scale3(x, y, z, m, r) {
			if (r == m) {
				m[0] *= x;
				m[1] *= x;
				m[2] *= x;
				m[3] *= x;
				m[4] *= y;
				m[5] *= y;
				m[6] *= y;
				m[7] *= y;
				m[8] *= z;
				m[9] *= z;
				m[10] *= z;
				m[11] *= z;
				return m;
			}
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			r[0] = m[0] * x;
			r[1] = m[1] * x;
			r[2] = m[2] * x;
			r[3] = m[3] * x;
			r[4] = m[4] * y;
			r[5] = m[5] * y;
			r[6] = m[6] * y;
			r[7] = m[7] * y;
			r[8] = m[8] * z;
			r[9] = m[9] * z;
			r[10] = m[10] * z;
			r[11] = m[11] * z;
			r[12] = m[12];
			r[13] = m[13];
			r[14] = m[14];
			r[15] = m[15];
	
			return r;
		};
	
		/*
		 * Function: M4x4.scale1
		 */
		M4x4.scale1 = function M4x4_scale1(k, m, r) {
			if (r == m) {
				m[0] *= k;
				m[1] *= k;
				m[2] *= k;
				m[3] *= k;
				m[4] *= k;
				m[5] *= k;
				m[6] *= k;
				m[7] *= k;
				m[8] *= k;
				m[9] *= k;
				m[10] *= k;
				m[11] *= k;
				return m;
			}
	
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			r[0] = m[0] * k;
			r[1] = m[1] * k;
			r[2] = m[2] * k;
			r[3] = m[3] * k;
			r[4] = m[4] * k;
			r[5] = m[5] * k;
			r[6] = m[6] * k;
			r[7] = m[7] * k;
			r[8] = m[8] * k;
			r[9] = m[9] * k;
			r[10] = m[10] * k;
			r[11] = m[11] * k;
			r[12] = m[12];
			r[13] = m[13];
			r[14] = m[14];
			r[15] = m[15];
	
			return r;
		};
	
		/*
		 * Function: M4x4.scale1
		 */
		M4x4.scale = function M4x4_scale(v, m, r) {
			var x = v[0], y = v[1], z = v[2];
	
			if (r == m) {
				m[0] *= x;
				m[1] *= x;
				m[2] *= x;
				m[3] *= x;
				m[4] *= y;
				m[5] *= y;
				m[6] *= y;
				m[7] *= y;
				m[8] *= z;
				m[9] *= z;
				m[10] *= z;
				m[11] *= z;
				return m;
			}
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
	
			r[0] = m[0] * x;
			r[1] = m[1] * x;
			r[2] = m[2] * x;
			r[3] = m[3] * x;
			r[4] = m[4] * y;
			r[5] = m[5] * y;
			r[6] = m[6] * y;
			r[7] = m[7] * y;
			r[8] = m[8] * z;
			r[9] = m[9] * z;
			r[10] = m[10] * z;
			r[11] = m[11] * z;
			r[12] = m[12];
			r[13] = m[13];
			r[14] = m[14];
			r[15] = m[15];
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeTranslate3
		 */
		M4x4.makeTranslate3 = function M4x4_makeTranslate3(x, y, z, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			r[0] = 1;
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 1;
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = 1;
			r[11] = 0;
			r[12] = x;
			r[13] = y;
			r[14] = z;
			r[15] = 1;
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeTranslate1
		 */
		M4x4.makeTranslate1 = function M4x4_makeTranslate1 (k, r) {
			return M4x4.makeTranslate3(k, k, k, r);
		};
	
		/*
		 * Function: M4x4.makeTranslate
		 */
		M4x4.makeTranslate = function M4x4_makeTranslate (v, r) {
			return M4x4.makeTranslate3(v[0], v[1], v[2], r);
		};
	
		/*
		 * Function: M4x4.translate3Self
		 */
		M4x4.translate3Self = function M4x4_translate3Self (x, y, z, m) {
			m[12] += m[0] * x + m[4] * y + m[8] * z;
			m[13] += m[1] * x + m[5] * y + m[9] * z;
			m[14] += m[2] * x + m[6] * y + m[10] * z;
			m[15] += m[3] * x + m[7] * y + m[11] * z;
			return m;
		};
	
		/*
		 * Function: M4x4.translate3
		 */
		M4x4.translate3 = function M4x4_translate3 (x, y, z, m, r) {
			if (r == m) {
				m[12] += m[0] * x + m[4] * y + m[8] * z;
				m[13] += m[1] * x + m[5] * y + m[9] * z;
				m[14] += m[2] * x + m[6] * y + m[10] * z;
				m[15] += m[3] * x + m[7] * y + m[11] * z;
				return m;
			}
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			var m11 = m[0];
			var m21 = m[1];
			var m31 = m[2];
			var m41 = m[3];
			var m12 = m[4];
			var m22 = m[5];
			var m32 = m[6];
			var m42 = m[7];
			var m13 = m[8];
			var m23 = m[9];
			var m33 = m[10];
			var m43 = m[11];
	
	
			r[0] = m11;
			r[1] = m21;
			r[2] = m31;
			r[3] = m41;
			r[4] = m12;
			r[5] = m22;
			r[6] = m32;
			r[7] = m42;
			r[8] = m13;
			r[9] = m23;
			r[10] = m33;
			r[11] = m43;
			r[12] = m11 * x + m12 * y + m13 * z + m[12];
			r[13] = m21 * x + m22 * y + m23 * z + m[13];
			r[14] = m31 * x + m32 * y + m33 * z + m[14];
			r[15] = m41 * x + m42 * y + m43 * z + m[15];
	
			return r;
		};
	
		/*
		 * Function: M4x4.translate1
		 */
		M4x4.translate1 = function M4x4_translate1 (k, m, r) {
			return M4x4.translate3(k, k, k, m, r);
		};
		/*
		 * Function: M4x4.translateSelf
		 */
		M4x4.translateSelf = function M4x4_translateSelf (v, m) {
			var x=v[0], y=v[1], z=v[2];
			m[12] += m[0] * x + m[4] * y + m[8] * z;
			m[13] += m[1] * x + m[5] * y + m[9] * z;
			m[14] += m[2] * x + m[6] * y + m[10] * z;
			m[15] += m[3] * x + m[7] * y + m[11] * z;
			return m;
		};
		/*
		 * Function: M4x4.translate
		 */
		M4x4.translate = function M4x4_translate (v, m, r) {
			var x=v[0], y=v[1], z=v[2];
			if (r == m) {
				m[12] += m[0] * x + m[4] * y + m[8] * z;
				m[13] += m[1] * x + m[5] * y + m[9] * z;
				m[14] += m[2] * x + m[6] * y + m[10] * z;
				m[15] += m[3] * x + m[7] * y + m[11] * z;
				return m;
			}
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			var m11 = m[0];
			var m21 = m[1];
			var m31 = m[2];
			var m41 = m[3];
			var m12 = m[4];
			var m22 = m[5];
			var m32 = m[6];
			var m42 = m[7];
			var m13 = m[8];
			var m23 = m[9];
			var m33 = m[10];
			var m43 = m[11];
	
			r[0] = m11;
			r[1] = m21;
			r[2] = m31;
			r[3] = m41;
			r[4] = m12;
			r[5] = m22;
			r[6] = m32;
			r[7] = m42;
			r[8] = m13;
			r[9] = m23;
			r[10] = m33;
			r[11] = m43;
			r[12] = m11 * x + m12 * y + m13 * z + m[12];
			r[13] = m21 * x + m22 * y + m23 * z + m[13];
			r[14] = m31 * x + m32 * y + m33 * z + m[14];
			r[15] = m41 * x + m42 * y + m43 * z + m[15];
	
			return r;
		};
	
		/*
		 * Function: M4x4.makeLookAt
		 */
		M4x4.makeLookAt = function M4x4_makeLookAt (eye, center, up, r) {
			var z = V3.direction(eye, center, V3._temp1);
			var x = V3.normalize(V3.cross(up, z, V3._temp2), V3._temp2);
			var y = V3.normalize(V3.cross(z, x, V3._temp3), V3._temp3);
	
			var tm1 = M4x4._temp1;
			var tm2 = M4x4._temp2;
	
			tm1[0] = x[0];
			tm1[1] = y[0];
			tm1[2] = z[0];
			tm1[3] = 0;
			tm1[4] = x[1];
			tm1[5] = y[1];
			tm1[6] = z[1];
			tm1[7] = 0;
			tm1[8] = x[2];
			tm1[9] = y[2];
			tm1[10] = z[2];
			tm1[11] = 0;
			tm1[12] = 0;
			tm1[13] = 0;
			tm1[14] = 0;
			tm1[15] = 1;
	
			tm2[0] = 1; tm2[1] = 0; tm2[2] = 0; tm2[3] = 0;
			tm2[4] = 0; tm2[5] = 1; tm2[6] = 0; tm2[7] = 0;
			tm2[8] = 0; tm2[9] = 0; tm2[10] = 1; tm2[11] = 0;
			tm2[12] = -eye[0]; tm2[13] = -eye[1]; tm2[14] = -eye[2]; tm2[15] = 1;
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
			return M4x4.mul(tm1, tm2, r);
		};
	
		/*
		 * Function: M4x4.transposeSelf
		 */
		M4x4.transposeSelf = function M4x4_transposeSelf (m) {
			var tmp = m[1]; m[1] = m[4]; m[4] = tmp;
			tmp = m[2]; m[2] = m[8]; m[8] = tmp;
			tmp = m[3]; m[3] = m[12]; m[12] = tmp;
			tmp = m[6]; m[6] = m[9]; m[9] = tmp;
			tmp = m[7]; m[7] = m[13]; m[13] = tmp;
			tmp = m[11]; m[11] = m[14]; m[14] = tmp;
			return m;
		};
		/*
		 * Function: M4x4.transpose
		 */
		M4x4.transpose = function M4x4_transpose (m, r) {
			if (m == r) {
				var tmp = 0.0;
				tmp = m[1]; m[1] = m[4]; m[4] = tmp;
				tmp = m[2]; m[2] = m[8]; m[8] = tmp;
				tmp = m[3]; m[3] = m[12]; m[12] = tmp;
				tmp = m[6]; m[6] = m[9]; m[9] = tmp;
				tmp = m[7]; m[7] = m[13]; m[13] = tmp;
				tmp = m[11]; m[11] = m[14]; m[14] = tmp;
				return m;
			}
	
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(16);
	
			r[0] = m[0]; r[1] = m[4]; r[2] = m[8]; r[3] = m[12];
			r[4] = m[1]; r[5] = m[5]; r[6] = m[9]; r[7] = m[13];
			r[8] = m[2]; r[9] = m[6]; r[10] = m[10]; r[11] = m[14];
			r[12] = m[3]; r[13] = m[7]; r[14] = m[11]; r[15] = m[15];
	
			return r;
		};
	
	
		/*
		 * Function: M4x4.transformPoint
		 */
		M4x4.transformPoint = function M4x4_transformPoint (m, v, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
	
			var v0 = v[0], v1 = v[1], v2 = v[2];
	
			r[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12];
			r[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13];
			r[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14];
			var w = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15];
	
			if (w != 1.0) {
				r[0] /= w;
				r[1] /= w;
				r[2] /= w;
			}
	
			return r;
		};
	
		/*
		 * Function: M4x4.transformLine
		 */
		M4x4.transformLine = function M4x4_transformLine(m, v, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
	
			var v0 = v[0], v1 = v[1], v2 = v[2];
			r[0] = m[0] * v0 + m[4] * v1 + m[8] * v2;
			r[1] = m[1] * v0 + m[5] * v1 + m[9] * v2;
			r[2] = m[2] * v0 + m[6] * v1 + m[10] * v2;
			var w = m[3] * v0 + m[7] * v1 + m[11] * v2;
	
			if (w != 1.0) {
				r[0] /= w;
				r[1] /= w;
				r[2] /= w;
			}
	
			return r;
		};
	
	
		/*
		 * Function: M4x4.transformPointAffine
		 */
		M4x4.transformPointAffine = function M4x4_transformPointAffine (m, v, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
	
			var v0 = v[0], v1 = v[1], v2 = v[2];
	
			r[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12];
			r[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13];
			r[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14];
	
			return r;
		};
	
		/*
		 * Function: M4x4.transformLineAffine
		 */
		M4x4.transformLineAffine = function M4x4_transformLineAffine(m, v, r) {
			if (r == undefined)
				r = new MJS_FLOAT_ARRAY_TYPE(3);
	
			var v0 = v[0], v1 = v[1], v2 = v[2];
			r[0] = m[0] * v0 + m[4] * v1 + m[8] * v2;
			r[1] = m[1] * v0 + m[5] * v1 + m[9] * v2;
			r[2] = m[2] * v0 + m[6] * v1 + m[10] * v2;
	
			return r;
		};
	
		return mJS;
	}

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_, $) {var Marionette, ViewModesView, app, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Marionette = __webpack_require__(49);
	
	app = __webpack_require__(48);
	
	constants = __webpack_require__(61);
	
	ViewModesView = (function(superClass) {
	  extend(ViewModesView, superClass);
	
	  function ViewModesView() {
	    return ViewModesView.__super__.constructor.apply(this, arguments);
	  }
	
	  ViewModesView.prototype.template = _.template("<div class=\"btn-group btn-group\">\n  <div class=\"btn-group\">\n    <button type=\"button\" class=\"btn btn-default\" id=\"mode-3planes\">Orthogonal</button>\n  </div>\n  <div class=\"btn-group\">\n    <button type=\"button\" class=\"btn btn-default\" id=\"mode-sphere\">Flight</button>\n  </div>\n  <div class=\"btn-group\">\n    <button type=\"button\" class=\"btn btn-default\" id=\"mode-arbitraryplane\">Oblique</button>\n  </div>\n</div>");
	
	  ViewModesView.prototype.modeMapping = {
	    "mode-3planes": constants.MODE_PLANE_TRACING,
	    "mode-sphere": constants.MODE_ARBITRARY,
	    "mode-arbitraryplane": constants.MODE_ARBITRARY_PLANE
	  };
	
	  ViewModesView.prototype.events = {
	    "click button": "changeMode"
	  };
	
	  ViewModesView.prototype.initialize = function(options) {
	    this.listenTo(this.model, "change:mode", this.updateForMode);
	    return this.listenTo(this, "attach", this.afterAttach);
	  };
	
	  ViewModesView.prototype.afterAttach = function() {
	    var mode, modeValue, ref;
	    ref = this.modeMapping;
	    for (mode in ref) {
	      modeValue = ref[mode];
	      $("#" + mode).attr("disabled", indexOf.call(this.model.get("allowedModes"), modeValue) < 0);
	    }
	    this.updateForMode(this.model.get("mode"));
	  };
	
	  ViewModesView.prototype.changeMode = function(evt) {
	    var mode;
	    mode = this.modeMapping[evt.target.id];
	    return this.model.setMode(mode);
	  };
	
	  ViewModesView.prototype.updateForMode = function(mode) {
	    var buttonId;
	    this.$("button").removeClass("btn-primary");
	    buttonId = _.invert(this.modeMapping)[mode];
	    return this.$("#" + buttonId).addClass("btn-primary");
	  };
	
	  return ViewModesView;
	
	})(Marionette.ItemView);
	
	module.exports = ViewModesView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(1)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var Constants, Marionette, VolumeActionsView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Constants = __webpack_require__(61);
	
	VolumeActionsView = (function(superClass) {
	  extend(VolumeActionsView, superClass);
	
	  function VolumeActionsView() {
	    return VolumeActionsView.__super__.constructor.apply(this, arguments);
	  }
	
	  VolumeActionsView.prototype.template = _.template("<div class=\"btn-group\">\n  <button\n    type=\"button\"\n    class=\"btn btn-default <% if (isMoveMode) { %> btn-primary <% } %>\"\n    id=\"mode-move\">\n      Move\n  </button>\n  <button\n    type=\"button\"\n    class=\"btn btn-default <% if (!isMoveMode) { %> btn-primary <% } %>\"\n    id=\"mode-trace\">\n      Trace\n  </button>\n</div>\n<div class=\"btn-group\">\n  <button type=\"button\" class=\"btn btn-default\" id=\"create-cell\">Create new cell (C)</button>\n</div>");
	
	  VolumeActionsView.prototype.modeMapping = {
	    "mode-trace": Constants.VOLUME_MODE_TRACE,
	    "mode-move": Constants.VOLUME_MODE_MOVE
	  };
	
	  VolumeActionsView.prototype.events = {
	    "click [id^=mode]": "changeMode",
	    "click #create-cell": "createCell"
	  };
	
	  VolumeActionsView.prototype.initialize = function(options) {
	    return this.listenTo(this.model.volumeTracing, "change:mode", this.render);
	  };
	
	  VolumeActionsView.prototype.createCell = function() {
	    return this.model.volumeTracing.createCell();
	  };
	
	  VolumeActionsView.prototype.changeMode = function(evt) {
	    var mode;
	    mode = this.modeMapping[evt.target.id];
	    return this.model.volumeTracing.setMode(mode);
	  };
	
	  VolumeActionsView.prototype.serializeData = function() {
	    return {
	      isMoveMode: this.model.volumeTracing.mode === Constants.VOLUME_MODE_MOVE
	    };
	  };
	
	  return VolumeActionsView;
	
	})(Marionette.ItemView);
	
	module.exports = VolumeActionsView;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var Constants, Marionette, SkeletonActionsView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Constants = __webpack_require__(61);
	
	SkeletonActionsView = (function(superClass) {
	  extend(SkeletonActionsView, superClass);
	
	  function SkeletonActionsView() {
	    return SkeletonActionsView.__super__.constructor.apply(this, arguments);
	  }
	
	  SkeletonActionsView.prototype.template = _.template("<div class=\"btn-group\">\n  <button type=\"button\" class=\"btn btn-default\" id=\"add-node\">Add Node (Right-Click) </button>\n</div>");
	
	  SkeletonActionsView.prototype.events = {
	    "click #add-node": "addNode"
	  };
	
	  SkeletonActionsView.prototype.addNode = function() {
	    var datasetConfig, position;
	    position = this.model.flycam.getPosition();
	    position[0] = position[0] + Math.pow(2, this.model.flycam.getIntegerZoomStep());
	    position[1] = position[1] + Math.pow(2, this.model.flycam.getIntegerZoomStep());
	    datasetConfig = this.model.get("datasetConfiguration");
	    return this.model.skeletonTracing.addNode(position, this.model.flycam.getRotation(Constants.PLANE_XY), Constants.TYPE_USUAL, Constants.PLANE_XY, this.model.flycam.getIntegerZoomStep(), datasetConfig.get("fourBit") ? 4 : 8, datasetConfig.get("interpolation"));
	  };
	
	  return SkeletonActionsView;
	
	})(Marionette.ItemView);
	
	module.exports = SkeletonActionsView;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, BackboneToOxalisAdapterModel, DatasetSettingsView, PlaneUserSettingsView, SkeletonPlaneTabView, SkeletonTracingSettingsView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	SkeletonTracingSettingsView = __webpack_require__(196);
	
	PlaneUserSettingsView = __webpack_require__(209);
	
	DatasetSettingsView = __webpack_require__(217);
	
	BackboneToOxalisAdapterModel = __webpack_require__(222);
	
	SkeletonPlaneTabView = (function(superClass) {
	  extend(SkeletonPlaneTabView, superClass);
	
	  function SkeletonPlaneTabView() {
	    return SkeletonPlaneTabView.__super__.constructor.apply(this, arguments);
	  }
	
	  SkeletonPlaneTabView.prototype.getTabs = function() {
	    return [
	      {
	        id: "tracing-settings-tab",
	        name: "Tracing",
	        iconClass: "fa fa-cogs",
	        viewClass: SkeletonTracingSettingsView,
	        options: {
	          model: this.adapterModel
	        }
	      }, {
	        id: "dataset-settings-tab",
	        name: "Dataset",
	        iconClass: "fa fa-cogs",
	        active: true,
	        viewClass: DatasetSettingsView
	      }, {
	        id: "user-settings-tab",
	        name: "User",
	        iconClass: "fa fa-cogs",
	        viewClass: PlaneUserSettingsView
	      }
	    ];
	  };
	
	  return SkeletonPlaneTabView;
	
	})(AbstractTabView);
	
	module.exports = SkeletonPlaneTabView;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {var AbstractTabView, Marionette, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Marionette = __webpack_require__(49);
	
	_ = __webpack_require__(2);
	
	AbstractTabView = (function(superClass) {
	  extend(AbstractTabView, superClass);
	
	  function AbstractTabView() {
	    return AbstractTabView.__super__.constructor.apply(this, arguments);
	  }
	
	  AbstractTabView.prototype.MARGIN = 40;
	
	  AbstractTabView.prototype.className = "flex-column";
	
	  AbstractTabView.prototype.template = _.template("<ul class=\"nav nav-tabs\">\n  <% tabs.forEach(function(tab) { %>\n    <li>\n      <a href=\"#<%- tab.id %>\" data-toggle=\"tab\" data-tab-id=\"<%- tab.id %>\"> <%= tab.iconString %> <%- tab.name %></a>\n    </li>\n  <% }) %>\n</ul>\n<div class=\"tab-content flex-column\">\n  <% tabs.forEach(function(tab) { %>\n    <div class=\"tab-pane\" id=\"<%- tab.id %>\"></div>\n  <% }) %>\n</div>");
	
	  AbstractTabView.prototype.ui = {
	    "tabContentContainer": ".tab-content",
	    "tabNavbarContainer": ".nav-tabs"
	  };
	
	  AbstractTabView.prototype.initialize = function(options) {
	    var regions;
	    this.listenTo(this, "render", this.afterRender);
	    this.adapterModel = options.adapterModel;
	    regions = {};
	    this.activeTabIndex = 0;
	    this.tabs = this.getTabs();
	    this.tabs.forEach((function(_this) {
	      return function(tab, index) {
	        if (tab.active) {
	          _this.activeTabIndex = index;
	        }
	        tab.view = new tab.viewClass(tab.options || options);
	        tab.iconString = tab.iconClass ? "<i class=\"" + tab.iconClass + "\"></i>" : "";
	        return regions[tab.id] = "#" + tab.id;
	      };
	    })(this));
	    return this.addRegions(regions);
	  };
	
	  AbstractTabView.prototype.getTabs = function() {
	    return [];
	  };
	
	  AbstractTabView.prototype.afterRender = function() {
	    this.$(this.ui.tabContentContainer.children()[this.activeTabIndex]).addClass("active");
	    this.$(this.ui.tabNavbarContainer.children()[this.activeTabIndex]).addClass("active");
	    this.tabs.forEach((function(_this) {
	      return function(tab) {
	        return _this[tab.id].show(tab.view);
	      };
	    })(this));
	    return this.$('a[data-toggle="tab"]').on('shown.bs.tab', (function(_this) {
	      return function(e) {
	        var tab, tabId;
	        tabId = $(e.target).data("tab-id");
	        tab = _.find(_this.tabs, function(t) {
	          return t.id === tabId;
	        });
	        return tab.view.render();
	      };
	    })(this));
	  };
	
	  AbstractTabView.prototype.serializeData = function() {
	    return {
	      tabs: this.tabs
	    };
	  };
	
	  return AbstractTabView;
	
	})(Marionette.LayoutView);
	
	module.exports = AbstractTabView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var BoundingBoxCategory, Marionette, NodeCategoryView, SettingsView, SkeletonTracingSettingsView, TreeCategoryView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Marionette = __webpack_require__(49);
	
	_ = __webpack_require__(2);
	
	SettingsView = __webpack_require__(197);
	
	TreeCategoryView = __webpack_require__(199);
	
	NodeCategoryView = __webpack_require__(204);
	
	BoundingBoxCategory = __webpack_require__(207);
	
	SkeletonTracingSettingsView = (function(superClass) {
	  extend(SkeletonTracingSettingsView, superClass);
	
	  function SkeletonTracingSettingsView() {
	    return SkeletonTracingSettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  SkeletonTracingSettingsView.prototype.id = "tracing-settings";
	
	  SkeletonTracingSettingsView.prototype.className = "flex-column";
	
	  SkeletonTracingSettingsView.prototype.modelName = "skeletonTracingAdapter";
	
	  SkeletonTracingSettingsView.prototype.subviewCreatorsList = [
	    [
	      "tree-category", function() {
	        return new TreeCategoryView({
	          model: this.model
	        });
	      }
	    ], [
	      "node-category", function() {
	        return new NodeCategoryView({
	          model: this.model
	        });
	      }
	    ], [
	      "boundingBox-category", function() {
	        return new BoundingBoxCategory({
	          model: this.model
	        });
	      }
	    ]
	  ];
	
	  return SkeletonTracingSettingsView;
	
	})(SettingsView);
	
	module.exports = SkeletonTracingSettingsView;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, SettingsView, Subviews, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Utils = __webpack_require__(188);
	
	Marionette = __webpack_require__(49);
	
	Subviews = __webpack_require__(198);
	
	SettingsView = (function(superClass) {
	  extend(SettingsView, superClass);
	
	  function SettingsView() {
	    return SettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  SettingsView.prototype.template = _.template("<div class=\"panel-group flex-overflow\">\n\n  <% _.forEach(subviewCreatorsList, function (key_value_pair) { %>\n    <div data-subview=\"<%- key_value_pair[0] %>\"></div>\n  <% }) %>\n\n</div>");
	
	  SettingsView.prototype.modelName = null;
	
	  SettingsView.prototype.initialize = function() {
	    if (this.modelName != null) {
	      this.model = this.model[this.modelName];
	    }
	    if (this.subviewCreatorsList == null) {
	      throw new Error("Subclasses of CategoryView must specify subviewCreatorsList");
	    }
	    this.subviewCreators = _.transform(this.subviewCreatorsList, function(result, arg) {
	      var key, value;
	      key = arg[0], value = arg[1];
	      return result[key] = value;
	    }, {});
	    return Subviews.add(this);
	  };
	
	  SettingsView.prototype.render = function() {
	    if (this.model) {
	      return SettingsView.__super__.render.call(this);
	    } else {
	      return this.$el.html(Utils.loaderTemplate());
	    }
	  };
	
	  SettingsView.prototype.serializeData = function() {
	    return {
	      subviewCreatorsList: this.subviewCreatorsList
	    };
	  };
	
	  return SettingsView;
	
	})(Marionette.ItemView);
	
	module.exports = SettingsView;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Backbone.Subviews, v0.7.4
	 * Copyright (c)2013-2014 Rotunda Software, LLC.
	 * Distributed under MIT license
	 * http://github.com/rotundasoftware/backbone.subviews
	*/
	( function( root, factory ) {
		// UMD wrapper
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(4), __webpack_require__(3), __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if ( typeof exports !== 'undefined' ) {
			// Node/CommonJS
			module.exports = factory( require('underscore' ), require( 'backbone' ), require( 'backbone' ).$ );
		} else {
			// Browser globals
			factory( root._, root.Backbone, ( root.jQuery || root.Zepto || root.$ ) );
		}
	}( this, function( _, Backbone, $ ) {
		Backbone.Subviews = {};
	
		Backbone.Subviews.add = function( view ) {
			var overriddenViewMethods = {
				render : view.render,
				remove : view.remove
			};
	
			// ****************** Overridden Backbone.View methods ****************** 
	
			view.render = function() {
				var args = Array.prototype.slice.call( arguments );
	
				_prerender.call( this );
				var returnValue = overriddenViewMethods.render.apply( this, args );
				_postrender.call( this );
	
				return returnValue;
			};
	
			view.remove = function() {
				this.removeSubviews();
				return overriddenViewMethods.remove.call( this );
			};
	
			// ****************** Additional public methods ****************** 
	
			view.removeSubviews = function() {
				// Removes all subviews and cleans up references in this.subviews.
	
				if( this.subviews ) {
					_.each( this.subviews, function( thisSubview ) {
						thisSubview.remove();
					} );
	
					delete this.subviews;
				}
			};
	
			// ****************** Additional private methods ****************** 
	
			view._createSubview = function( subviewName, placeHolderDiv ) {
				// Return a new subview instance given a subview name and its placeHolderDiv.
				// Implemented as instance method so that this behavior may be customized / overridden.
				var subviewCreator = this.subviewCreators[ subviewName ];
				if( _.isUndefined( subviewCreator ) ) throw new Error( "Can not find subview creator for subview named: " + subviewName );
	
				return subviewCreator.apply( this );
			};
		};
	
		// ****************** Private utility functions ****************** 
	
		function _prerender() {
			if( ! this.subviews ) this.subviews = {};
	
			// Detach each of our subviews that we have already created during previous
			// renders from the DOM, so that they do not loose their DOM events when
			// we re-render the contents of this view's DOM element.
			_.each( this.subviews, function( thisSubview ) {
				thisSubview.$el.detach();
			} );
		}
	
		function _postrender() {
			var _this = this;
			this.subviewCreators = this.subviewCreators || {};
	
			// Support subviewCreators as both objects and functions.
			this.subviewCreators = _.result( this, "subviewCreators" );
			
			this.$( "[data-subview]" ).each( function() {
				var thisPlaceHolderDiv = $( this );
				var subviewName = thisPlaceHolderDiv.attr( "data-subview" );
				var newSubview;
	
				if( _.isUndefined( _this.subviews[ subviewName ] ) ) {
					newSubview = _this._createSubview( subviewName, thisPlaceHolderDiv );
					if( newSubview === null ) return;  // subview creators can return null to indicate that the subview should not be created
					_this.subviews[ subviewName ] = newSubview;
				}
				else {
					// If the subview is already defined, then use the existing subview instead
					// of creating a new one. This allows us to re-render a parent view without
					// loosing any dynamic state data on the existing subview objects. To force
					// re-initialization of subviews, call view.removeSubviews before re-rendering.
	
					newSubview = _this.subviews[ subviewName ];
				}
	
				thisPlaceHolderDiv.replaceWith( newSubview.$el );
			} );
	
			// Now that all subviews have been created, render them one at a time, in the
			// order they occur in the DOM.
			_.each( this.subviews, function( thisSubview ) {
				thisSubview.render();
			} );
	
			// Call this.onSubviewsRendered after everything is done (hook for application defined logic)
			if( _.isFunction( this.onSubviewsRendered ) ) this.onSubviewsRendered.call( this );
			if( _.isFunction( this._onSubviewsRendered ) ) this._onSubviewsRendered.call( this ); // depreciated. backwards compatibility for versions < 0.6.
		}
	
		return Backbone.Subviews;
	} ) );


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, NumberSettingView, TreeCategoryView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	NumberSettingView = __webpack_require__(200);
	
	CheckboxSettingView = __webpack_require__(202);
	
	CategoryView = __webpack_require__(203);
	
	TreeCategoryView = (function(superClass) {
	  extend(TreeCategoryView, superClass);
	
	  function TreeCategoryView() {
	    return TreeCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  TreeCategoryView.prototype.caption = "Trees";
	
	  TreeCategoryView.prototype.subviewCreatorsList = [
	    [
	      "activeTree", function() {
	        return new NumberSettingView({
	          model: this.model,
	          options: {
	            name: "activeTreeId",
	            displayName: "Active Tree ID"
	          }
	        });
	      }
	    ], [
	      "somaClicking", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "somaClicking",
	            displayName: "Soma Clicking"
	          }
	        });
	      }
	    ]
	  ];
	
	  return TreeCategoryView;
	
	})(CategoryView);
	
	module.exports = TreeCategoryView;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, Marionette, NumberSettingView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = __webpack_require__(201);
	
	NumberSettingView = (function(superClass) {
	  extend(NumberSettingView, superClass);
	
	  function NumberSettingView() {
	    return NumberSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  NumberSettingView.prototype.className = "number-setting-view row";
	
	  NumberSettingView.prototype.template = _.template("<div class=\"col-sm-5\">\n  <%- displayName %>\n</div>\n<div class=\"col-sm-7\">\n  <input class=\"form-control\" type=\"number\" min=\"<%- min %>\" max=\"<%- max %>\" step=\"<%- step %>\" value=\"<%- value %>\">\n</div>");
	
	  NumberSettingView.prototype.ui = {
	    number: "input[type=number]"
	  };
	
	  NumberSettingView.prototype.events = {
	    "change @ui.number": "handleChange"
	  };
	
	  NumberSettingView.prototype.initialize = function(options) {
	    NumberSettingView.__super__.initialize.call(this, options);
	    return _.defaults(this.options, {
	      min: "",
	      max: "",
	      step: 1
	    });
	  };
	
	  NumberSettingView.prototype.handleChange = function(evt) {
	    return this.model.set(this.options.name, Number(evt.target.value));
	  };
	
	  NumberSettingView.prototype.update = function(model, value) {
	    return this.ui.number.val(value);
	  };
	
	  return NumberSettingView;
	
	})(AbstractSettingView);
	
	module.exports = NumberSettingView;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, Marionette, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = (function(superClass) {
	  extend(AbstractSettingView, superClass);
	
	  function AbstractSettingView() {
	    return AbstractSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  AbstractSettingView.prototype.initialize = function(arg) {
	    this.model = arg.model, this.options = arg.options;
	    return this.listenTo(this.model, "change:" + this.options.name, this.update);
	  };
	
	  AbstractSettingView.prototype.serializeData = function() {
	    return _.extend(this.options, {
	      value: this.model.get(this.options.name)
	    });
	  };
	
	  return AbstractSettingView;
	
	})(Marionette.ItemView);
	
	module.exports = AbstractSettingView;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, CheckboxSettingView, Marionette, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = __webpack_require__(201);
	
	CheckboxSettingView = (function(superClass) {
	  extend(CheckboxSettingView, superClass);
	
	  function CheckboxSettingView() {
	    return CheckboxSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  CheckboxSettingView.prototype.className = "checkbox-setting-view row";
	
	  CheckboxSettingView.prototype.template = _.template("<div class=\"col-sm-5\">\n  <%- displayName %>\n</div>\n<div class=\"col-sm-1\">\n  <input type=\"checkbox\" <%- boolToChecked(value) %>>\n</div>\n<div class=\"col-sm-6\"><div>");
	
	  CheckboxSettingView.prototype.ui = {
	    checkbox: "input[type=checkbox]"
	  };
	
	  CheckboxSettingView.prototype.templateHelpers = {
	    boolToChecked: function(bool) {
	      if (bool) {
	        return "checked";
	      } else {
	        return "";
	      }
	    }
	  };
	
	  CheckboxSettingView.prototype.events = {
	    "change @ui.checkbox": "handleChange"
	  };
	
	  CheckboxSettingView.prototype.handleChange = function(evt) {
	    return this.model.set(this.options.name, evt.target.checked);
	  };
	
	  CheckboxSettingView.prototype.update = function(model, value) {
	    return this.ui.checkbox.prop("checked", value);
	  };
	
	  return CheckboxSettingView;
	
	})(AbstractSettingView);
	
	module.exports = CheckboxSettingView;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, Marionette, Subviews, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Subviews = __webpack_require__(198);
	
	CategoryView = (function(superClass) {
	  extend(CategoryView, superClass);
	
	  function CategoryView() {
	    return CategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  CategoryView.prototype.template = _.template("<div class=\"panel panel-default\">\n  <div class=\"panel-heading\" data-toggle=\"collapse\" data-target=\"#user-settings-<%- tabId %>\">\n    <h4 class=\"panel-title\">\n      <a>\n        <i class=\"caret-down\"></i>\n        <i class=\"caret-right\"></i>\n        <%- caption %>\n      </a>\n    </h4>\n  </div>\n  <div id=\"user-settings-<%- tabId %>\" class=\"panel-collapse collapse in\">\n    <div class=\"panel-body\">\n\n      <% _.forEach(subviewCreatorsList, function (key_value_pair) { %>\n        <div data-subview=\"<%- key_value_pair[0] %>\"></div>\n      <% }) %>\n\n    </div>\n  </div>\n</div>");
	
	  CategoryView.prototype.initialize = function() {
	    if (this.subviewCreatorsList == null) {
	      throw new Error("Subclasses of CategoryView must specify subviewCreatorsList");
	    }
	    this.subviewCreators = _.transform(this.subviewCreatorsList, function(result, arg) {
	      var key, value;
	      key = arg[0], value = arg[1];
	      return result[key] = value;
	    }, {});
	    return Subviews.add(this);
	  };
	
	  CategoryView.prototype.serializeData = function() {
	    return {
	      subviewCreatorsList: this.subviewCreatorsList,
	      caption: this.caption,
	      tabId: _.uniqueId()
	    };
	  };
	
	  CategoryView.prototype.hide = function() {
	    return this.$el.hide();
	  };
	
	  CategoryView.prototype.show = function() {
	    return this.$el.show();
	  };
	
	  return CategoryView;
	
	})(Marionette.ItemView);
	
	module.exports = CategoryView;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var ButtonSettingView, CategoryView, CheckboxSettingView, Constants, NodeCategoryView, NumberSettingView, SliderSettingView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	NumberSettingView = __webpack_require__(200);
	
	CheckboxSettingView = __webpack_require__(202);
	
	SliderSettingView = __webpack_require__(205);
	
	ButtonSettingView = __webpack_require__(206);
	
	CategoryView = __webpack_require__(203);
	
	Constants = __webpack_require__(61);
	
	NodeCategoryView = (function(superClass) {
	  extend(NodeCategoryView, superClass);
	
	  function NodeCategoryView() {
	    return NodeCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  NodeCategoryView.prototype.caption = "Nodes";
	
	  NodeCategoryView.prototype.subviewCreatorsList = [
	    [
	      "activeNode", function() {
	        return new NumberSettingView({
	          model: this.model,
	          options: {
	            name: "activeNodeId",
	            displayName: "Active Node ID"
	          }
	        });
	      }
	    ], [
	      "radius", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "radius",
	            displayName: "Radius",
	            min: 1,
	            max: 5000,
	            step: 1
	          }
	        });
	      }
	    ], [
	      "particleSize", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "particleSize",
	            displayName: "Particle Size",
	            min: Constants.MIN_PARTICLE_SIZE,
	            max: Constants.MAX_PARTICLE_SIZE,
	            step: 0.1
	          }
	        });
	      }
	    ], [
	      "overrideNodeRadius", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "overrideNodeRadius",
	            displayName: "Override Radius"
	          }
	        });
	      }
	    ], [
	      "deleteActiveNode", function() {
	        return new ButtonSettingView({
	          model: this.model,
	          options: {
	            displayName: "Delete Active Node",
	            callbackName: "deleteActiveNode"
	          }
	        });
	      }
	    ]
	  ];
	
	  return NodeCategoryView;
	
	})(CategoryView);
	
	module.exports = NodeCategoryView;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, Marionette, SliderSettingView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = __webpack_require__(201);
	
	SliderSettingView = (function(superClass) {
	  extend(SliderSettingView, superClass);
	
	  function SliderSettingView() {
	    return SliderSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  SliderSettingView.prototype.className = "slider-setting-view row";
	
	  SliderSettingView.prototype.template = _.template("<div class=\"col-sm-5\">\n  <%- displayName %>\n</div>\n<div class=\"col-sm-3 no-gutter v-center\">\n  <div class=\"v-center-agent\">\n    <input type=\"range\" min=\"<%- min %>\" max=\"<%- max %>\" step=\"<%- step %>\" value=\"<%- typeof logScaleBase != \"undefined\" ? Math.log(value) / Math.log(logScaleBase) : value %>\">\n  </div>\n</div>\n<div class=\"col-sm-4\">\n  <input class=\"form-control\" type=\"number\" min=\"<%- min %>\" max=\"<%- max %>\" step=\"<%- step %>\" value=\"<%- value %>\">\n</div>");
	
	  SliderSettingView.prototype.ui = {
	    slider: "input[type=range]",
	    text: "input[type=number]"
	  };
	
	  SliderSettingView.prototype.events = {
	    "input @ui.slider": "handleSliderChange",
	    "change @ui.slider": "handleSliderChange",
	    "change @ui.text": "handleTextboxChange",
	    "dblclick @ui.slider": "resetValue"
	  };
	
	  SliderSettingView.prototype.handleSliderChange = function(evt) {
	    var value;
	    value = this.getSliderValue();
	    this.ui.text.val(value);
	    return this.model.set(this.options.name, value);
	  };
	
	  SliderSettingView.prototype.handleTextboxChange = function(evt) {
	    var value;
	    value = parseFloat(evt.target.value);
	    if ((this.options.min <= value && value <= this.options.max)) {
	      return this.model.set(this.options.name, value);
	    } else {
	      return this.update(this.model, this.getSliderValue());
	    }
	  };
	
	  SliderSettingView.prototype.update = function(model, value) {
	    value = parseFloat(value);
	    this.ui.text.val(value);
	    if (this.options.logScaleBase) {
	      value = Math.log(value) / Math.log(this.options.logScaleBase);
	    }
	    return this.ui.slider.val(value);
	  };
	
	  SliderSettingView.prototype.getSliderValue = function() {
	    var value;
	    value = parseFloat(this.ui.slider.val());
	    if (this.options.logScaleBase != null) {
	      value = Math.pow(this.options.logScaleBase, value);
	    }
	    return value;
	  };
	
	  SliderSettingView.prototype.resetValue = function(evt) {
	    var reset;
	    if (this.model) {
	      if (reset = this.model.reset) {
	        return reset();
	      }
	    }
	  };
	
	  return SliderSettingView;
	
	})(AbstractSettingView);
	
	module.exports = SliderSettingView;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, ButtonSettingView, Marionette, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = __webpack_require__(201);
	
	ButtonSettingView = (function(superClass) {
	  extend(ButtonSettingView, superClass);
	
	  function ButtonSettingView() {
	    return ButtonSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  ButtonSettingView.prototype.className = "button-setting-view row";
	
	  ButtonSettingView.prototype.template = _.template("<div class=\"col-sm-12\">\n  <button type=\"button\" class=\"btn btn-block btn-default\"><%- displayName %></button>\n</div>");
	
	  ButtonSettingView.prototype.events = {
	    "click button": "handleClick"
	  };
	
	  ButtonSettingView.prototype.initialize = function(arg) {
	    this.model = arg.model, this.options = arg.options;
	  };
	
	  ButtonSettingView.prototype.serializeData = function() {
	    return this.options;
	  };
	
	  ButtonSettingView.prototype.handleClick = function() {
	    return this.model[this.options.callbackName]();
	  };
	
	  return ButtonSettingView;
	
	})(Marionette.ItemView);
	
	module.exports = ButtonSettingView;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var BoundingBoxCategory, CategoryView, TextInputSettingView, Toast, Utils,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	CategoryView = __webpack_require__(203);
	
	TextInputSettingView = __webpack_require__(208);
	
	Utils = __webpack_require__(188);
	
	Toast = __webpack_require__(18);
	
	BoundingBoxCategory = (function(superClass) {
	  extend(BoundingBoxCategory, superClass);
	
	  function BoundingBoxCategory() {
	    return BoundingBoxCategory.__super__.constructor.apply(this, arguments);
	  }
	
	  BoundingBoxCategory.prototype.caption = "Bounding Box";
	
	  BoundingBoxCategory.prototype.subviewCreatorsList = [
	    [
	      "boundingbox", function() {
	        return new TextInputSettingView({
	          model: this.model,
	          options: {
	            name: "boundingBox",
	            displayName: "Bounding Box",
	            pattern: "(\\d+\\s*,\\s*){5}\\d+",
	            title: "Format: minX, minY, minZ, maxX, maxY, maxZ",
	            validate: this.validate
	          }
	        });
	      }
	    ]
	  ];
	
	  BoundingBoxCategory.prototype.validate = function(value) {
	    var isValid, maxX, maxY, maxZ, minX, minY, minZ, ref;
	    ref = Utils.stringToNumberArray(value), minX = ref[0], minY = ref[1], minZ = ref[2], maxX = ref[3], maxY = ref[4], maxZ = ref[5];
	    if (isValid = minX > maxX || minY > maxY || minZ > maxZ) {
	      Toast.error("Bounding Box: Max value must be bigger than min value.", false);
	      this.ui.text[0].setCustomValidity("Max value must be bigger than min value.");
	    } else {
	      this.ui.text[0].setCustomValidity("");
	    }
	    return isValid;
	  };
	
	  return BoundingBoxCategory;
	
	})(CategoryView);
	
	module.exports = BoundingBoxCategory;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, Marionette, TextInputSettingView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = __webpack_require__(201);
	
	TextInputSettingView = (function(superClass) {
	  extend(TextInputSettingView, superClass);
	
	  function TextInputSettingView() {
	    return TextInputSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  TextInputSettingView.prototype.className = "text-setting-view row";
	
	  TextInputSettingView.prototype.template = _.template("<div class=\"col-sm-5\">\n  <%- displayName %>\n</div>\n<div class=\"col-sm-7\">\n  <input class=\"form-control\" type=\"text\" pattern=\"<%- pattern %>\" title=\"<%- title %>\" value=\"<%- value %>\">\n</div>");
	
	  TextInputSettingView.prototype.ui = {
	    text: "input[type=text]"
	  };
	
	  TextInputSettingView.prototype.events = {
	    "change @ui.text": "handleChange"
	  };
	
	  TextInputSettingView.prototype.initialize = function(options) {
	    TextInputSettingView.__super__.initialize.call(this, options);
	    return _.defaults(this.options, {
	      pattern: "",
	      title: ""
	    });
	  };
	
	  TextInputSettingView.prototype.handleChange = function(evt) {
	    var value;
	    value = evt.target.value;
	    if (this.options.validate) {
	      if (!this.options.validate.call(this, value)) {
	        return;
	      }
	    }
	    return this.model.set(this.options.name, value);
	  };
	
	  TextInputSettingView.prototype.update = function(model, value) {
	    return this.ui.text.val(value);
	  };
	
	  return TextInputSettingView;
	
	})(AbstractSettingView);
	
	module.exports = TextInputSettingView;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTreeCategoryView, ControlsCategoryView, IsosurfaceCategoryView, PlaneUserSettingsView, SegmentationCategoryView, SettingsView, TDViewCategoryView, ViewportCategoryView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	SettingsView = __webpack_require__(197);
	
	ControlsCategoryView = __webpack_require__(210);
	
	ViewportCategoryView = __webpack_require__(211);
	
	TDViewCategoryView = __webpack_require__(213);
	
	IsosurfaceCategoryView = __webpack_require__(214);
	
	SegmentationCategoryView = __webpack_require__(215);
	
	AbstractTreeCategoryView = __webpack_require__(216);
	
	PlaneUserSettingsView = (function(superClass) {
	  extend(PlaneUserSettingsView, superClass);
	
	  function PlaneUserSettingsView() {
	    return PlaneUserSettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  PlaneUserSettingsView.prototype.id = "user-settings";
	
	  PlaneUserSettingsView.prototype.className = "flex-column";
	
	  PlaneUserSettingsView.prototype.subviewCreatorsList = [
	    [
	      "controls-category", function() {
	        return new ControlsCategoryView({
	          model: this.model.get("user")
	        });
	      }
	    ], [
	      "viewport-category", function() {
	        return new ViewportCategoryView({
	          model: this.model
	        });
	      }
	    ], [
	      "tdview-category", function() {
	        return new TDViewCategoryView({
	          model: this.model.get("user")
	        });
	      }
	    ], [
	      "isosurface-category", function() {
	        return new IsosurfaceCategoryView({
	          model: this.model.get("user")
	        });
	      }
	    ], [
	      "segmentation-category", function() {
	        return new SegmentationCategoryView({
	          model: this.model.get("user")
	        });
	      }
	    ], [
	      "abstracttree-category", function() {
	        return new AbstractTreeCategoryView({
	          model: this.model.get("user")
	        });
	      }
	    ]
	  ];
	
	  return PlaneUserSettingsView;
	
	})(SettingsView);
	
	module.exports = PlaneUserSettingsView;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, ControlsCategoryView, SliderSettingView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	CheckboxSettingView = __webpack_require__(202);
	
	SliderSettingView = __webpack_require__(205);
	
	CategoryView = __webpack_require__(203);
	
	ControlsCategoryView = (function(superClass) {
	  extend(ControlsCategoryView, superClass);
	
	  function ControlsCategoryView() {
	    return ControlsCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  ControlsCategoryView.prototype.caption = "Controls";
	
	  ControlsCategoryView.prototype.subviewCreatorsList = [
	    [
	      "inverseX", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "inverseX",
	            displayName: "Inverse X"
	          }
	        });
	      }
	    ], [
	      "inverseY", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "inverseY",
	            displayName: "Inverse Y"
	          }
	        });
	      }
	    ], [
	      "keyboardDelay", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "keyboardDelay",
	            displayName: "Keyboard delay (ms)",
	            min: 0,
	            max: 500,
	            step: 1
	          }
	        });
	      }
	    ]
	  ];
	
	  return ControlsCategoryView;
	
	})(CategoryView);
	
	module.exports = ControlsCategoryView;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, DropdownSettingView, SliderSettingView, ViewportCategoryView, app, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	app = __webpack_require__(48);
	
	CheckboxSettingView = __webpack_require__(202);
	
	SliderSettingView = __webpack_require__(205);
	
	DropdownSettingView = __webpack_require__(212);
	
	CategoryView = __webpack_require__(203);
	
	constants = __webpack_require__(61);
	
	ViewportCategoryView = (function(superClass) {
	  extend(ViewportCategoryView, superClass);
	
	  function ViewportCategoryView() {
	    return ViewportCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  ViewportCategoryView.prototype.caption = "Viewport Options";
	
	  ViewportCategoryView.prototype.subviewCreatorsList = [
	    [
	      "moveValue", function() {
	        return new SliderSettingView({
	          model: this.model.get("user"),
	          options: {
	            name: "moveValue",
	            displayName: "Move Value (nm/s)",
	            min: constants.MIN_MOVE_VALUE,
	            max: constants.MAX_MOVE_VALUE,
	            step: 10
	          }
	        });
	      }
	    ], [
	      "zoom", function() {
	        return new SliderSettingView({
	          model: this.model.get("user"),
	          options: {
	            name: "zoom",
	            displayName: "Zoom",
	            min: -100,
	            max: 100,
	            step: 1,
	            logScaleBase: Math.pow(this.model.flycam.getMaxZoomStep(), 0.01)
	          }
	        });
	      }
	    ], [
	      "scale", function() {
	        return new SliderSettingView({
	          model: this.model.get("user"),
	          options: {
	            name: "scale",
	            displayName: "Viewport Scale",
	            min: constants.MIN_SCALE,
	            max: constants.MAX_SCALE,
	            step: 0.1
	          }
	        });
	      }
	    ], [
	      "clippingDistance", function() {
	        return new SliderSettingView({
	          model: this.model.get("user"),
	          options: {
	            name: "clippingDistance",
	            displayName: "Clipping Distance",
	            min: 1,
	            max: 1000 * app.scaleInfo.baseVoxel,
	            step: 1
	          }
	        });
	      }
	    ], [
	      "dynamicSpaceDirection", function() {
	        return new CheckboxSettingView({
	          model: this.model.get("user"),
	          options: {
	            name: "dynamicSpaceDirection",
	            displayName: "d/f-Switching"
	          }
	        });
	      }
	    ], [
	      "displayCrosshair", function() {
	        return new CheckboxSettingView({
	          model: this.model.get("user"),
	          options: {
	            name: "displayCrosshair",
	            displayName: "Show Crosshairs"
	          }
	        });
	      }
	    ]
	  ];
	
	  return ViewportCategoryView;
	
	})(CategoryView);
	
	module.exports = ViewportCategoryView;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, DropdownSettingView, Marionette, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	AbstractSettingView = __webpack_require__(201);
	
	DropdownSettingView = (function(superClass) {
	  extend(DropdownSettingView, superClass);
	
	  function DropdownSettingView() {
	    return DropdownSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  DropdownSettingView.prototype.className = "dropdown-setting-view row";
	
	  DropdownSettingView.prototype.template = _.template("<div class=\"col-sm-5\">\n  <%- displayName %>\n</div>\n<div class=\"col-sm-7\">\n  <select class=\"form-control\">\n    <% _.forEach(options, function (name, index) { %>\n      <option value=\"<%- index %>\" <%- isSelected(value, index) %>><%- name %></option>\n    <% }) %>\n  </select>\n</div>");
	
	  DropdownSettingView.prototype.templateHelpers = {
	    isSelected: function(value, index) {
	      if (value === index) {
	        return "selected";
	      } else {
	        return "";
	      }
	    }
	  };
	
	  DropdownSettingView.prototype.ui = {
	    select: "select"
	  };
	
	  DropdownSettingView.prototype.events = {
	    "change @ui.select": "handleChange"
	  };
	
	  DropdownSettingView.prototype.handleChange = function(evt) {
	    return this.model.set(this.options.name, parseInt(evt.target.value, 10));
	  };
	
	  DropdownSettingView.prototype.update = function(model, value) {
	    return this.ui.select.val(parseInt(value, 10));
	  };
	
	  return DropdownSettingView;
	
	})(AbstractSettingView);
	
	module.exports = DropdownSettingView;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, TDViewCategoryView, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	CheckboxSettingView = __webpack_require__(202);
	
	CategoryView = __webpack_require__(203);
	
	constants = __webpack_require__(61);
	
	TDViewCategoryView = (function(superClass) {
	  extend(TDViewCategoryView, superClass);
	
	  function TDViewCategoryView() {
	    return TDViewCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  TDViewCategoryView.prototype.caption = "3D View";
	
	  TDViewCategoryView.prototype.subviewCreatorsList = [
	    [
	      "tdViewDisplayPlanes", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "tdViewDisplayPlanes",
	            displayName: "Display Planes"
	          }
	        });
	      }
	    ]
	  ];
	
	  return TDViewCategoryView;
	
	})(CategoryView);
	
	module.exports = TDViewCategoryView;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, IsosurfaceCategoryView, SliderSettingView, app, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	CategoryView = __webpack_require__(203);
	
	CheckboxSettingView = __webpack_require__(202);
	
	SliderSettingView = __webpack_require__(205);
	
	constants = __webpack_require__(61);
	
	app = __webpack_require__(48);
	
	IsosurfaceCategoryView = (function(superClass) {
	  extend(IsosurfaceCategoryView, superClass);
	
	  function IsosurfaceCategoryView() {
	    return IsosurfaceCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  IsosurfaceCategoryView.prototype.caption = "Isosurface View";
	
	  IsosurfaceCategoryView.prototype.subviewCreatorsList = [
	    [
	      "displayIso", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "isosurfaceDisplay",
	            displayName: "Turn On"
	          }
	        });
	      }
	    ], [
	      "boundingBox", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "isosurfaceBBsize",
	            displayName: "Bounding Box Size",
	            min: 1,
	            max: 10,
	            step: 0.1
	          }
	        });
	      }
	    ], [
	      "resolution", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "isosurfaceResolution",
	            displayName: "Resolution",
	            min: 40,
	            max: 400,
	            step: 1
	          }
	        });
	      }
	    ]
	  ];
	
	  IsosurfaceCategoryView.prototype.initialize = function() {
	    IsosurfaceCategoryView.__super__.initialize.call(this);
	    if (app.oxalis.model.volumeTracing == null) {
	      return this.hide();
	    }
	  };
	
	  return IsosurfaceCategoryView;
	
	})(CategoryView);
	
	module.exports = IsosurfaceCategoryView;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, SegementationCategoryView, SliderSettingView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	SliderSettingView = __webpack_require__(205);
	
	CategoryView = __webpack_require__(203);
	
	SegementationCategoryView = (function(superClass) {
	  extend(SegementationCategoryView, superClass);
	
	  function SegementationCategoryView() {
	    return SegementationCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  SegementationCategoryView.prototype.caption = "Segmentation";
	
	  SegementationCategoryView.prototype.subviewCreatorsList = [
	    [
	      "segmentOpacity", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "segmentationOpacity",
	            displayName: "Segement Opacity",
	            min: 0,
	            max: 100,
	            step: 1
	          }
	        });
	      }
	    ]
	  ];
	
	  SegementationCategoryView.prototype.initialize = function() {
	    SegementationCategoryView.__super__.initialize.call(this);
	    if (app.oxalis.model.getSegmentationBinary() == null) {
	      return this.hide();
	    }
	  };
	
	  return SegementationCategoryView;
	
	})(CategoryView);
	
	module.exports = SegementationCategoryView;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTreeCategoryView, CategoryView, CheckboxSettingView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	CheckboxSettingView = __webpack_require__(202);
	
	CategoryView = __webpack_require__(203);
	
	AbstractTreeCategoryView = (function(superClass) {
	  extend(AbstractTreeCategoryView, superClass);
	
	  function AbstractTreeCategoryView() {
	    return AbstractTreeCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  AbstractTreeCategoryView.prototype.caption = "Abstract Tree";
	
	  AbstractTreeCategoryView.prototype.subviewCreatorsList = [
	    [
	      "renderComments", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "renderComments",
	            displayName: "Render Comments"
	          }
	        });
	      }
	    ]
	  ];
	
	  return AbstractTreeCategoryView;
	
	})(CategoryView);
	
	module.exports = AbstractTreeCategoryView;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var ColorsCategoryView, DatasetSettingsView, QualityCategoryView, SettingsView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	SettingsView = __webpack_require__(197);
	
	ColorsCategoryView = __webpack_require__(218);
	
	QualityCategoryView = __webpack_require__(221);
	
	DatasetSettingsView = (function(superClass) {
	  extend(DatasetSettingsView, superClass);
	
	  function DatasetSettingsView() {
	    return DatasetSettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  DatasetSettingsView.prototype.id = "dataset-settings";
	
	  DatasetSettingsView.prototype.className = "flex-column";
	
	  DatasetSettingsView.prototype.modelName = "datasetConfiguration";
	
	  DatasetSettingsView.prototype.subviewCreatorsList = [
	    [
	      "colors-category", function() {
	        return new ColorsCategoryView({
	          model: this.model
	        });
	      }
	    ], [
	      "quality-category", function() {
	        return new QualityCategoryView({
	          model: this.model
	        });
	      }
	    ]
	  ];
	
	  return DatasetSettingsView;
	
	})(SettingsView);
	
	module.exports = DatasetSettingsView;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var ButtonSettingView, CategoryView, ColorsCategoryView, LayerColorSettingsView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	LayerColorSettingsView = __webpack_require__(219);
	
	ButtonSettingView = __webpack_require__(206);
	
	CategoryView = __webpack_require__(203);
	
	ColorsCategoryView = (function(superClass) {
	  extend(ColorsCategoryView, superClass);
	
	  function ColorsCategoryView() {
	    return ColorsCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  ColorsCategoryView.prototype.caption = "Colors";
	
	  ColorsCategoryView.prototype.subviewCreatorsList = [
	    [
	      "reset", function() {
	        return new ButtonSettingView({
	          model: this.model,
	          options: {
	            displayName: "Reset Color Settings",
	            callbackName: "reset"
	          }
	        });
	      }
	    ]
	  ];
	
	  ColorsCategoryView.prototype.initialize = function() {
	    var fn, i, key, len, ref;
	    ref = this.model.get("dataLayerNames");
	    fn = (function(_this) {
	      return function(key) {
	        return _this.subviewCreatorsList.push([
	          key, function() {
	            return new LayerColorSettingsView({
	              model: this.model,
	              options: {
	                name: "layers." + key,
	                displayName: "Layer: " + key
	              }
	            });
	          }
	        ]);
	      };
	    })(this);
	    for (i = 0, len = ref.length; i < len; i++) {
	      key = ref[i];
	      fn(key);
	    }
	    return ColorsCategoryView.__super__.initialize.call(this);
	  };
	
	  return ColorsCategoryView;
	
	})(CategoryView);
	
	module.exports = ColorsCategoryView;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var ColorSettingView, LayerColorSettingsView, Marionette, SliderSettingView, Subviews, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Subviews = __webpack_require__(198);
	
	SliderSettingView = __webpack_require__(205);
	
	ColorSettingView = __webpack_require__(220);
	
	LayerColorSettingsView = (function(superClass) {
	  extend(LayerColorSettingsView, superClass);
	
	  function LayerColorSettingsView() {
	    return LayerColorSettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  LayerColorSettingsView.prototype.template = _.template("<p><%- displayName %></p>\n<% _.forEach(subviewCreatorsList, function (key_value_pair) { %>\n  <div data-subview=\"<%- key_value_pair[0] %>\"></div>\n<% }) %>");
	
	  LayerColorSettingsView.prototype.subviewCreatorsList = [
	    [
	      "brightness", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: this.options.name + ".brightness",
	            displayName: "Brightness",
	            min: -256,
	            max: 256,
	            step: 5
	          }
	        });
	      }
	    ], [
	      "contrast", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: this.options.name + ".contrast",
	            displayName: "Contrast",
	            min: 0.5,
	            max: 5,
	            step: 0.1
	          }
	        });
	      }
	    ], [
	      "color", function() {
	        return new ColorSettingView({
	          model: this.model,
	          options: {
	            name: this.options.name + ".color",
	            displayName: "Color"
	          }
	        });
	      }
	    ]
	  ];
	
	  LayerColorSettingsView.prototype.serializeData = function() {
	    return _.extend(this.options, {
	      subviewCreatorsList: this.subviewCreatorsList
	    });
	  };
	
	  LayerColorSettingsView.prototype.initialize = function(arg) {
	    this.model = arg.model, this.options = arg.options;
	    if (this.subviewCreatorsList == null) {
	      throw new Error("Subclasses of CategoryView must specify subviewCreatorsList");
	    }
	    this.subviewCreators = _.transform(this.subviewCreatorsList, function(result, arg1) {
	      var key, value;
	      key = arg1[0], value = arg1[1];
	      return result[key] = value;
	    }, {});
	    return Subviews.add(this);
	  };
	
	  return LayerColorSettingsView;
	
	})(Marionette.ItemView);
	
	module.exports = LayerColorSettingsView;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractSettingView, ColorSettingView, Marionette, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	Utils = __webpack_require__(188);
	
	AbstractSettingView = __webpack_require__(201);
	
	ColorSettingView = (function(superClass) {
	  extend(ColorSettingView, superClass);
	
	  function ColorSettingView() {
	    return ColorSettingView.__super__.constructor.apply(this, arguments);
	  }
	
	  ColorSettingView.prototype.className = "color-setting-view row";
	
	  ColorSettingView.prototype.template = _.template("<div class=\"col-sm-5\">\n  <%- displayName %>\n</div>\n<div class=\"col-sm-4 col-sm-offset-3\">\n  <input class=\"form-control\" type=\"color\" value=\"<%- rgbToHex(value) %>\">\n</div>");
	
	  ColorSettingView.prototype.templateHelpers = {
	    rgbToHex: Utils.rgbToHex
	  };
	
	  ColorSettingView.prototype.ui = {
	    colorpicker: "input[type=color]"
	  };
	
	  ColorSettingView.prototype.events = {
	    "change @ui.colorpicker": "handleChange"
	  };
	
	  ColorSettingView.prototype.handleChange = function(evt) {
	    return this.model.set(this.options.name, Utils.hexToRgb(evt.target.value));
	  };
	
	  ColorSettingView.prototype.update = function(model, value) {
	    return this.ui.colorpicker.val(Utils.rgbToHex(value));
	  };
	
	  return ColorSettingView;
	
	})(AbstractSettingView);
	
	module.exports = ColorSettingView;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, DropdownSettingView, QualityCategoryView, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	CheckboxSettingView = __webpack_require__(202);
	
	DropdownSettingView = __webpack_require__(212);
	
	CategoryView = __webpack_require__(203);
	
	constants = __webpack_require__(61);
	
	QualityCategoryView = (function(superClass) {
	  extend(QualityCategoryView, superClass);
	
	  function QualityCategoryView() {
	    return QualityCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  QualityCategoryView.prototype.caption = "Quality";
	
	  QualityCategoryView.prototype.subviewCreatorsList = [
	    [
	      "fourBit", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "fourBit",
	            displayName: "4 Bit"
	          }
	        });
	      }
	    ], [
	      "interpolation", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "interpolation",
	            displayName: "Interpolation"
	          }
	        });
	      }
	    ], [
	      "quality", function() {
	        return new DropdownSettingView({
	          model: this.model,
	          options: {
	            name: "quality",
	            displayName: "Quality",
	            options: ["high", "medium", "low"]
	          }
	        });
	      }
	    ]
	  ];
	
	  return QualityCategoryView;
	
	})(CategoryView);
	
	module.exports = QualityCategoryView;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, BackboneToOxalisAdapterModel, Utils, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Backbone = __webpack_require__(3);
	
	app = __webpack_require__(48);
	
	Utils = __webpack_require__(188);
	
	BackboneToOxalisAdapterModel = (function(superClass) {
	  extend(BackboneToOxalisAdapterModel, superClass);
	
	  function BackboneToOxalisAdapterModel() {
	    return BackboneToOxalisAdapterModel.__super__.constructor.apply(this, arguments);
	  }
	
	  BackboneToOxalisAdapterModel.prototype.initialize = function(oxalisModel) {
	    this.oxalisModel = oxalisModel;
	    this.skeletonTracingAdapter = new Backbone.Model({
	      activeTreeId: 0,
	      somaClicking: false,
	      activeNodeId: 0,
	      radius: 0,
	      particleSize: 0,
	      overrideNodeRadius: true,
	      boundingBox: "0, 0, 0, 0, 0, 0"
	    });
	    this.volumeTracingAdapter = new Backbone.Model({
	      activeCellId: 0
	    });
	    return this.listenTo(this.oxalisModel, "sync", this.bind);
	  };
	
	  BackboneToOxalisAdapterModel.prototype.bind = function() {
	    if (this.oxalisModel.skeletonTracing) {
	      this.skeletonTracingModel = this.oxalisModel.skeletonTracing;
	      this.skeletonTracingAdapter.set("activeTreeId", this.skeletonTracingModel.getActiveTreeId());
	      this.skeletonTracingAdapter.set("activeNodeId", this.skeletonTracingModel.getActiveNodeId());
	      this.skeletonTracingAdapter.set("radius", this.skeletonTracingModel.getActiveNodeRadius());
	      this.skeletonTracingAdapter.set("overrideNodeRadius", this.oxalisModel.user.get("overrideNodeRadius"));
	      this.skeletonTracingAdapter.set("particleSize", this.oxalisModel.user.get("particleSize"));
	      this.skeletonTracingAdapter.deleteActiveNode = this.skeletonTracingModel.deleteActiveNode.bind(this.skeletonTracingModel);
	      if (this.oxalisModel.settings.somaClickingAllowed) {
	        this.skeletonTracingAdapter.set("somaClicking", this.oxalisModel.user.get("newNodeNewTree"));
	      }
	      this.listenTo(this.skeletonTracingModel, "newTree", function(id) {
	        return this.skeletonTracingAdapter.set("activeTreeId", id, {
	          triggeredByModel: true
	        });
	      });
	      this.listenTo(this.skeletonTracingModel, "newActiveTree", function(id) {
	        return this.skeletonTracingAdapter.set("activeTreeId", id, {
	          triggeredByModel: true
	        });
	      });
	      this.listenTo(this.skeletonTracingModel, "newActiveNode", function(id) {
	        this.skeletonTracingAdapter.set("activeNodeId", id, {
	          triggeredByModel: true
	        });
	        return this.skeletonTracingAdapter.set("radius", this.skeletonTracingModel.getActiveNodeRadius(), {
	          triggeredByModel: true
	        });
	      });
	      this.listenTo(this.skeletonTracingModel, "newActiveNodeRadius", function(id) {
	        return this.skeletonTracingAdapter.set("radius", id, {
	          triggeredByModel: true
	        });
	      });
	      this.listenTo(this.skeletonTracingAdapter, "change:activeTreeId", function(model, id, options) {
	        if (!options.triggeredByModel) {
	          return _.defer((function(_this) {
	            return function() {
	              return _this.skeletonTracingModel.setActiveTree(id);
	            };
	          })(this));
	        }
	      });
	      this.listenTo(this.skeletonTracingAdapter, "change:somaClicking", function(model, bool) {
	        return this.oxalisModel.user.set("newNodeNewTree", bool);
	      });
	      this.listenTo(this.skeletonTracingAdapter, "change:activeNodeId", function(model, id, options) {
	        if (!options.triggeredByModel) {
	          return _.defer((function(_this) {
	            return function() {
	              return _this.skeletonTracingModel.setActiveNode(id);
	            };
	          })(this));
	        }
	      });
	      this.listenTo(this.skeletonTracingAdapter, "change:particleSize", function(model, size) {
	        return _.defer((function(_this) {
	          return function() {
	            return _this.oxalisModel.user.set("particleSize", size);
	          };
	        })(this));
	      });
	      this.listenTo(this.skeletonTracingAdapter, "change:overrideNodeRadius", function(model, bool) {
	        return this.oxalisModel.user.set("overrideNodeRadius", bool);
	      });
	      this.listenTo(this.skeletonTracingAdapter, "change:radius", function(model, radius, options) {
	        if (!options.triggeredByModel) {
	          return _.defer((function(_this) {
	            return function() {
	              return _this.skeletonTracingModel.setActiveNodeRadius(radius);
	            };
	          })(this));
	        }
	      });
	      return this.listenTo(this.skeletonTracingAdapter, "change:boundingBox", function(model, string) {
	        var bbArray;
	        bbArray = Utils.stringToNumberArray(string);
	        if ((bbArray != null ? bbArray.length : void 0) === 6) {
	          this.oxalisModel.boundingBox = bbArray;
	          return this.oxalisModel.trigger("newBoundingBox", bbArray);
	        }
	      });
	    } else if (this.oxalisModel.volumeTracing) {
	      this.volumeTracingModel = this.oxalisModel.volumeTracing;
	      this.volumeTracingAdapter.set("mappedActiveCellId", this.volumeTracingModel.getMappedActiveCellId());
	      this.volumeTracingAdapter.createCell = this.volumeTracingModel.createCell.bind(this.volumeTracingModel);
	      this.listenTo(this.volumeTracingModel, "newActiveCell", function() {
	        return this.volumeTracingAdapter.set("mappedActiveCellId", this.volumeTracingModel.getMappedActiveCellId());
	      });
	      return this.listenTo(this.volumeTracingAdapter, "change:activeCellId", function(model, id) {
	        return this.volumeTracingModel.setActiveCell(id);
	      });
	    }
	  };
	
	  return BackboneToOxalisAdapterModel;
	
	})(Backbone.Model);
	
	module.exports = BackboneToOxalisAdapterModel;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, ArbitraryUserSettingsView, DatasetSettingsView, SkeletonArbitraryTabView, SkeletonTracingSettingsView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	SkeletonTracingSettingsView = __webpack_require__(196);
	
	ArbitraryUserSettingsView = __webpack_require__(224);
	
	DatasetSettingsView = __webpack_require__(217);
	
	SkeletonArbitraryTabView = (function(superClass) {
	  extend(SkeletonArbitraryTabView, superClass);
	
	  function SkeletonArbitraryTabView() {
	    return SkeletonArbitraryTabView.__super__.constructor.apply(this, arguments);
	  }
	
	  SkeletonArbitraryTabView.prototype.getTabs = function() {
	    return [
	      {
	        id: "tracing-settings-tab",
	        name: "Tracing",
	        iconClass: "fa fa-cogs",
	        viewClass: SkeletonTracingSettingsView,
	        options: {
	          model: this.adapterModel
	        }
	      }, {
	        id: "dataset-settings-tab",
	        name: "Dataset",
	        iconClass: "fa fa-cogs",
	        active: true,
	        viewClass: DatasetSettingsView
	      }, {
	        id: "user-settings-tab",
	        name: "User",
	        iconClass: "fa fa-cogs",
	        viewClass: ArbitraryUserSettingsView
	      }
	    ];
	  };
	
	  return SkeletonArbitraryTabView;
	
	})(AbstractTabView);
	
	module.exports = SkeletonArbitraryTabView;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var ArbitraryUserSettingsView, ControlsCategoryView, FlightCategoryView, SettingsView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	SettingsView = __webpack_require__(197);
	
	ControlsCategoryView = __webpack_require__(210);
	
	FlightCategoryView = __webpack_require__(225);
	
	ArbitraryUserSettingsView = (function(superClass) {
	  extend(ArbitraryUserSettingsView, superClass);
	
	  function ArbitraryUserSettingsView() {
	    return ArbitraryUserSettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  ArbitraryUserSettingsView.prototype.id = "user-settings";
	
	  ArbitraryUserSettingsView.prototype.className = "flex-column";
	
	  ArbitraryUserSettingsView.prototype.modelName = "user";
	
	  ArbitraryUserSettingsView.prototype.subviewCreatorsList = [
	    [
	      "controls-category", function() {
	        return new ControlsCategoryView({
	          model: this.model
	        });
	      }
	    ], [
	      "flight-category", function() {
	        return new FlightCategoryView({
	          model: this.model
	        });
	      }
	    ]
	  ];
	
	  return ArbitraryUserSettingsView;
	
	})(SettingsView);
	
	module.exports = ArbitraryUserSettingsView;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var CategoryView, CheckboxSettingView, FlightCategoryView, SliderSettingView, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	SliderSettingView = __webpack_require__(205);
	
	CheckboxSettingView = __webpack_require__(202);
	
	CategoryView = __webpack_require__(203);
	
	constants = __webpack_require__(61);
	
	FlightCategoryView = (function(superClass) {
	  extend(FlightCategoryView, superClass);
	
	  function FlightCategoryView() {
	    return FlightCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  FlightCategoryView.prototype.caption = "Flightoptions";
	
	  FlightCategoryView.prototype.subviewCreatorsList = [
	    [
	      "mouseRotateValue", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "mouseRotateValue",
	            displayName: "Mouse Rotation",
	            min: 0.001,
	            max: 0.02,
	            step: 0.001
	          }
	        });
	      }
	    ], [
	      "rotateValue", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "rotateValue",
	            displayName: "Keyboard Rotation Value",
	            min: 0.001,
	            max: 0.08,
	            step: 0.001
	          }
	        });
	      }
	    ], [
	      "moveValue3d", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "moveValue3d",
	            displayName: "Move Value (nm/s)",
	            min: constants.MIN_MOVE_VALUE,
	            max: constants.MAX_MOVE_VALUE,
	            step: 10
	          }
	        });
	      }
	    ], [
	      "crosshairSize", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "crosshairSize",
	            displayName: "Crosshair Size",
	            min: 0.05,
	            max: 0.5,
	            step: 0.01
	          }
	        });
	      }
	    ], [
	      "sphericalCapRadius", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "sphericalCapRadius",
	            displayName: "Sphere Radius",
	            min: 50,
	            max: 500,
	            step: 1
	          }
	        });
	      }
	    ], [
	      "clippingDistanceArbitrary", function() {
	        return new SliderSettingView({
	          model: this.model,
	          options: {
	            name: "clippingDistanceArbitrary",
	            displayName: "Clipping Distance",
	            min: 1,
	            max: 127,
	            step: 1
	          }
	        });
	      }
	    ], [
	      "displayCrosshair", function() {
	        return new CheckboxSettingView({
	          model: this.model,
	          options: {
	            name: "displayCrosshair",
	            displayName: "Show Crosshair"
	          }
	        });
	      }
	    ]
	  ];
	
	  return FlightCategoryView;
	
	})(CategoryView);
	
	module.exports = FlightCategoryView;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, BackboneToOxalisAdapterModel, DatasetSettingsView, PlaneUserSettingsView, VolumeTabView, VolumeTracingSettingsView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	VolumeTracingSettingsView = __webpack_require__(227);
	
	PlaneUserSettingsView = __webpack_require__(209);
	
	DatasetSettingsView = __webpack_require__(217);
	
	BackboneToOxalisAdapterModel = __webpack_require__(222);
	
	VolumeTabView = (function(superClass) {
	  extend(VolumeTabView, superClass);
	
	  function VolumeTabView() {
	    return VolumeTabView.__super__.constructor.apply(this, arguments);
	  }
	
	  VolumeTabView.prototype.getTabs = function() {
	    return [
	      {
	        id: "tracing-settings-tab",
	        name: "Tracing",
	        iconClass: "fa fa-cogs",
	        viewClass: VolumeTracingSettingsView,
	        options: {
	          model: this.adapterModel
	        }
	      }, {
	        id: "dataset-settings-tab",
	        name: "Dataset",
	        iconClass: "fa fa-cogs",
	        active: true,
	        viewClass: DatasetSettingsView
	      }, {
	        id: "user-settings-tab",
	        name: "User",
	        iconClass: "fa fa-cogs",
	        viewClass: PlaneUserSettingsView
	      }
	    ];
	  };
	
	  return VolumeTabView;
	
	})(AbstractTabView);
	
	module.exports = VolumeTabView;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var CellCategoryView, Marionette, SettingsView, VolumeTracingSettingsView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Marionette = __webpack_require__(49);
	
	_ = __webpack_require__(2);
	
	SettingsView = __webpack_require__(197);
	
	CellCategoryView = __webpack_require__(228);
	
	VolumeTracingSettingsView = (function(superClass) {
	  extend(VolumeTracingSettingsView, superClass);
	
	  function VolumeTracingSettingsView() {
	    return VolumeTracingSettingsView.__super__.constructor.apply(this, arguments);
	  }
	
	  VolumeTracingSettingsView.prototype.id = "tracing-settings";
	
	  VolumeTracingSettingsView.prototype.className = "flex-column";
	
	  VolumeTracingSettingsView.prototype.modelName = "volumeTracingAdapter";
	
	  VolumeTracingSettingsView.prototype.subviewCreatorsList = [
	    [
	      "cell-category", function() {
	        return new CellCategoryView({
	          model: this.model
	        });
	      }
	    ]
	  ];
	
	  return VolumeTracingSettingsView;
	
	})(SettingsView);
	
	module.exports = VolumeTracingSettingsView;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var ButtonSettingView, CategoryView, CellCategoryView, NumberSettingView, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	constants = __webpack_require__(61);
	
	CategoryView = __webpack_require__(203);
	
	NumberSettingView = __webpack_require__(200);
	
	ButtonSettingView = __webpack_require__(206);
	
	CellCategoryView = (function(superClass) {
	  extend(CellCategoryView, superClass);
	
	  function CellCategoryView() {
	    return CellCategoryView.__super__.constructor.apply(this, arguments);
	  }
	
	  CellCategoryView.prototype.caption = "Cells";
	
	  CellCategoryView.prototype.subviewCreatorsList = [
	    [
	      "mappedActiveCellId", function() {
	        return new NumberSettingView({
	          model: this.model,
	          options: {
	            name: "mappedActiveCellId",
	            displayName: "Active Cell ID"
	          }
	        });
	      }
	    ], [
	      "createCell", function() {
	        return new ButtonSettingView({
	          model: this.model,
	          options: {
	            displayName: "Create new Cell",
	            callbackName: "createCell"
	          }
	        });
	      }
	    ]
	  ];
	
	  return CellCategoryView;
	
	})(CategoryView);
	
	module.exports = CellCategoryView;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, DatasetSettingsView, HelpLogoView, PlaneUserSettingsView, ViewmodeTabView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	HelpLogoView = __webpack_require__(230);
	
	PlaneUserSettingsView = __webpack_require__(209);
	
	DatasetSettingsView = __webpack_require__(217);
	
	ViewmodeTabView = (function(superClass) {
	  extend(ViewmodeTabView, superClass);
	
	  function ViewmodeTabView() {
	    return ViewmodeTabView.__super__.constructor.apply(this, arguments);
	  }
	
	  ViewmodeTabView.prototype.getTabs = function() {
	    return [
	      {
	        id: "help-tab",
	        name: "Help",
	        active: true,
	        viewClass: HelpLogoView
	      }, {
	        id: "dataset-settings-tab",
	        name: "Dataset",
	        iconClass: "fa fa-cogs",
	        viewClass: DatasetSettingsView
	      }, {
	        id: "user-settings-tab",
	        name: "User",
	        iconClass: "fa fa-cogs",
	        viewClass: PlaneUserSettingsView
	      }
	    ];
	  };
	
	  return ViewmodeTabView;
	
	})(AbstractTabView);
	
	module.exports = ViewmodeTabView;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var HelpLogoView, Marionette, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	HelpLogoView = (function(superClass) {
	  extend(HelpLogoView, superClass);
	
	  function HelpLogoView() {
	    return HelpLogoView.__super__.constructor.apply(this, arguments);
	  }
	
	  HelpLogoView.prototype.className = "help-logo-view flex-column";
	
	  HelpLogoView.prototype.template = _.template("<div class=\"flex-overflow\">\n  <table class=\"table table-condensed table-nohead table-bordered\">\n    <tbody>\n      <tr><th colspan=\"2\">Controls</th></tr>\n      <tr><td>I,O or Alt + Mousewheel</td><td>Zoom in/out</td></tr>\n      <tr><td>Mousewheel or D and F</td><td>Move along 3rd axis</td></tr>\n      <tr><td>Left Mouse drag or Arrow keys</td><td>Move</td></tr>\n      <tr><td>Right click drag in 3D View</td><td>Rotate 3D View</td></tr>\n      <tr><td>K,L</td><td>Scale up/down viewports</td></tr>\n    </tbody>\n  </table>\n  <div>\n    <img class=\"img-responsive\" src=\"/assets/images/Max-Planck-Gesellschaft.svg\")\">\n  </div>\n  <div>\n    <img class=\"img-responsive\" src=\"/assets/images/Logo_MPI_cut.svg\")\">\n  </div>\n</div>");
	
	  return HelpLogoView;
	
	})(Marionette.ItemView);
	
	module.exports = HelpLogoView;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, AbstractTreeView, CommentTabView, DatasetInfoView, ListTreeView, SkeletonTracingRightMenuView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	CommentTabView = __webpack_require__(232);
	
	AbstractTreeView = __webpack_require__(240);
	
	ListTreeView = __webpack_require__(242);
	
	DatasetInfoView = __webpack_require__(246);
	
	SkeletonTracingRightMenuView = (function(superClass) {
	  extend(SkeletonTracingRightMenuView, superClass);
	
	  function SkeletonTracingRightMenuView() {
	    return SkeletonTracingRightMenuView.__super__.constructor.apply(this, arguments);
	  }
	
	  SkeletonTracingRightMenuView.prototype.getTabs = function() {
	    return [
	      {
	        id: "tab-info",
	        name: "Info",
	        viewClass: DatasetInfoView
	      }, {
	        id: "tab-abstract-tree",
	        name: "Tree Viewer",
	        viewClass: AbstractTreeView
	      }, {
	        id: "tab-trees",
	        name: "Trees",
	        viewClass: ListTreeView
	      }, {
	        id: "tab-comments",
	        name: "Comments",
	        viewClass: CommentTabView,
	        active: true
	      }
	    ];
	  };
	
	  return SkeletonTracingRightMenuView;
	
	})(AbstractTabView);
	
	module.exports = SkeletonTracingRightMenuView;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_, $) {var CommentTabItemView, CommentTabView, Input, Marionette, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	app = __webpack_require__(48);
	
	Marionette = __webpack_require__(49);
	
	Input = __webpack_require__(233);
	
	CommentTabItemView = __webpack_require__(239);
	
	CommentTabView = (function(superClass) {
	  extend(CommentTabView, superClass);
	
	  function CommentTabView() {
	    return CommentTabView.__super__.constructor.apply(this, arguments);
	  }
	
	  CommentTabView.prototype.className = "flex-column";
	
	  CommentTabView.prototype.template = _.template("<div class=\"input-group\" id=\"comment-navbar\">\n  <div class=\"input-group-btn\">\n    <button class=\"btn btn-default\" id=\"comment-previous\"><i class=\"fa fa-arrow-left\"></i></button>\n  </div>\n  <input class=\"form-control\" id=\"comment-input\" type=\"text\" value=\"<%- activeComment.get(\"content\") %>\" placeholder=\"Add comment\">\n  <div class=\"input-group-btn\">\n    <button class=\"btn btn-default\" id=\"comment-next\"><i class=\"fa fa-arrow-right\"></i></button>\n    <button class=\"btn btn-default\" id=\"comment-sort\" title=\"sort\">\n      <% if(isSortedAscending){ %>\n        <i class=\"fa fa-sort-alpha-asc\"></i>\n      <% } else { %>\n        <i class=\"fa fa-sort-alpha-desc\"></i>\n      <% } %>\n    </button>\n  </div>\n</div>\n<ul id=\"comment-list\" class=\"flex-overflow\"></ul>");
	
	  CommentTabView.prototype.childView = CommentTabItemView;
	
	  CommentTabView.prototype.childViewContainer = "#comment-list";
	
	  CommentTabView.prototype.childViewOptions = function() {
	    return {
	      parent: this,
	      activeComment: this.activeComment
	    };
	  };
	
	  CommentTabView.prototype.templateHelpers = function() {
	    return {
	      activeComment: this.activeComment,
	      isSortedAscending: this.isSortedAscending
	    };
	  };
	
	  CommentTabView.prototype.ui = {
	    "commentInput": "input"
	  };
	
	  CommentTabView.prototype.events = {
	    "click #comment-sort": "sortComments",
	    "change input": "handleInput",
	    "click #comment-list li": "setActive",
	    "click #comment-next": "nextComment",
	    "click #comment-previous": "previousComment"
	  };
	
	  CommentTabView.prototype.initialize = function() {
	    var comment;
	    this.activeComment = new Backbone.Model();
	    this.isSortedAscending = true;
	    this.collection = this.model.skeletonTracing.comments;
	    this._initialEvents();
	    if (comment = this.collection.findWhere({
	      "node": this.getActiveNodeId()
	    })) {
	      this.activeComment = comment;
	    } else if (comment = this.collection.first()) {
	      this.activeComment = comment;
	    }
	    this.listenTo(this.model.skeletonTracing, "newActiveNode", this.updateInputElement);
	    this.listenTo(this.model.skeletonTracing, "deleteComment", this.deleteComment);
	    this.listenTo(this.collection, "sort", this.render);
	    return new Input.KeyboardNoLoop({
	      "n": (function(_this) {
	        return function() {
	          return _this.nextComment();
	        };
	      })(this),
	      "p": (function(_this) {
	        return function() {
	          return _this.previousComment();
	        };
	      })(this)
	    });
	  };
	
	  CommentTabView.prototype.getActiveNodeId = function() {
	    return this.model.skeletonTracing.getActiveNodeId();
	  };
	
	  CommentTabView.prototype.setActiveNode = function(activeComment) {
	    var nodeId;
	    this.activeComment = activeComment;
	    nodeId = activeComment.get("node");
	    this.model.skeletonTracing.setActiveNode(nodeId);
	    return this.model.skeletonTracing.centerActiveNode();
	  };
	
	  CommentTabView.prototype.updateInputElement = function(nodeId) {
	    var comment, content;
	    content = "";
	    if (comment = this.collection.findWhere({
	      node: nodeId
	    })) {
	      this.activeComment = comment;
	      content = comment.get("content");
	    }
	    return this.ui.commentInput.val(content);
	  };
	
	  CommentTabView.prototype.handleInput = function(evt) {
	    var comment, commentText, newComment, nodeId;
	    nodeId = this.getActiveNodeId();
	    commentText = $(evt.target).val();
	    if (comment = this.collection.findWhere({
	      node: nodeId
	    })) {
	      if (commentText !== "") {
	        return comment.set("content", commentText);
	      } else {
	        return this.collection.remove(comment);
	      }
	    } else {
	      if (commentText !== "") {
	        newComment = this.collection.add({
	          node: nodeId,
	          content: commentText
	        });
	        return this.setActiveNode(newComment);
	      }
	    }
	  };
	
	  CommentTabView.prototype.nextComment = function() {
	    var activeComment, nextComment;
	    activeComment = this.activeComment;
	    nextComment = this.collection.find((function(model) {
	      return this.comparator(model) > this.comparator(activeComment);
	    }), this.collection);
	    if (!nextComment) {
	      nextComment = this.collection.at(0);
	    }
	    if (nextComment) {
	      return this.setActiveNode(nextComment);
	    }
	  };
	
	  CommentTabView.prototype.previousComment = function() {
	    var activeComment, previousComment;
	    activeComment = this.activeComment;
	    previousComment = _.findLast(this.collection.models, (function(model) {
	      return this.comparator(model) < this.comparator(activeComment);
	    }), this.collection);
	    if (!previousComment) {
	      previousComment = this.collection.at(this.collection.length - 1);
	    }
	    if (previousComment) {
	      return this.setActiveNode(previousComment);
	    }
	  };
	
	  CommentTabView.prototype.sortComments = function(evt) {
	    this.isSortedAscending = !this.isSortedAscending;
	    return this.collection.sort(this.isSortedAscending);
	  };
	
	  CommentTabView.prototype.deleteComment = function(nodeID) {
	    var comment;
	    comment = this.collection.findWhere({
	      "node": nodeID
	    });
	    if (comment) {
	      this.collection.remove(comment);
	      return this.trigger("updateComments");
	    }
	  };
	
	  return CommentTabView;
	
	})(Marionette.CompositeView);
	
	module.exports = CommentTabView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(1)))

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, _) {var Backbone, Input, KeyboardJS, constants,
	  hasProp = {}.hasOwnProperty,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  slice = [].slice;
	
	Backbone = __webpack_require__(3);
	
	constants = __webpack_require__(61);
	
	KeyboardJS = __webpack_require__(234);
	
	Input = {};
	
	Input.KeyboardNoLoop = (function() {
	  function KeyboardNoLoop(initialBindings) {
	    var callback, key;
	    this.bindings = [];
	    for (key in initialBindings) {
	      if (!hasProp.call(initialBindings, key)) continue;
	      callback = initialBindings[key];
	      this.attach(key, callback);
	    }
	  }
	
	  KeyboardNoLoop.prototype.attach = function(key, callback) {
	    var binding, shouldIgnore;
	    shouldIgnore = function(event) {
	      var bindingHasCtrl, bindingHasShift, eventHasCtrl, eventHasShift;
	      bindingHasCtrl = key.toLowerCase().indexOf("ctrl") !== -1;
	      bindingHasShift = key.toLowerCase().indexOf("shift") !== -1;
	      eventHasCtrl = event.ctrl || event.metaKey;
	      eventHasShift = event.shiftKey;
	      return (eventHasCtrl && !bindingHasCtrl) || (eventHasShift && !bindingHasShift);
	    };
	    binding = [
	      key, (function(_this) {
	        return function(event) {
	          if (!($(":focus").length || shouldIgnore(event))) {
	            callback(event);
	          }
	        };
	      })(this)
	    ];
	    KeyboardJS.bind.apply(KeyboardJS, binding);
	    return this.bindings.push(binding);
	  };
	
	  KeyboardNoLoop.prototype.unbind = function() {
	    var binding, i, len, ref;
	    ref = this.bindings;
	    for (i = 0, len = ref.length; i < len; i++) {
	      binding = ref[i];
	      KeyboardJS.unbind.apply(KeyboardJS, binding);
	    }
	  };
	
	  return KeyboardNoLoop;
	
	})();
	
	Input.Keyboard = (function() {
	  Keyboard.prototype.DELAY = 1000 / constants.FPS;
	
	  function Keyboard(initialBindings, delay) {
	    var callback, key;
	    this.delay = delay != null ? delay : 0;
	    this.keyCallbackMap = {};
	    this.keyPressedCount = 0;
	    this.bindings = [];
	    for (key in initialBindings) {
	      if (!hasProp.call(initialBindings, key)) continue;
	      callback = initialBindings[key];
	      this.attach(key, callback);
	    }
	  }
	
	  Keyboard.prototype.attach = function(key, callback) {
	    var binding, shouldIgnore;
	    shouldIgnore = function(event) {
	      var bindingHasCtrl, bindingHasShift, eventHasCtrl, eventHasShift;
	      bindingHasCtrl = key.toLowerCase().indexOf("ctrl") !== -1;
	      bindingHasShift = key.toLowerCase().indexOf("shift") !== -1;
	      eventHasCtrl = event.ctrl || event.metaKey;
	      eventHasShift = event.shiftKey;
	      return (eventHasCtrl && !bindingHasCtrl) || (eventHasShift && !bindingHasShift);
	    };
	    binding = [
	      key, (function(_this) {
	        return function(event) {
	          var returnValue;
	          returnValue = void 0;
	          if (!((_this.keyCallbackMap[key] != null) || $(":focus").length || shouldIgnore(event))) {
	            callback(1, true);
	            callback._lastTime = null;
	            callback._delayed = true;
	            _this.keyCallbackMap[key] = callback;
	            _this.keyPressedCount++;
	            if (_this.keyPressedCount === 1) {
	              _this.buttonLoop();
	            }
	          }
	          if (_this.delay >= 0) {
	            setTimeout((function() {
	              return callback._delayed = false;
	            }), _this.delay);
	          }
	          return returnValue;
	        };
	      })(this), (function(_this) {
	        return function() {
	          if (_this.keyCallbackMap[key] != null) {
	            _this.keyPressedCount--;
	            delete _this.keyCallbackMap[key];
	          }
	        };
	      })(this)
	    ];
	    KeyboardJS.bind.apply(KeyboardJS, binding);
	    return this.bindings.push(binding);
	  };
	
	  Keyboard.prototype.buttonLoop = function() {
	    var callback, curTime, elapsed, key, lastTime, ref;
	    if (this.keyPressedCount > 0) {
	      ref = this.keyCallbackMap;
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        callback = ref[key];
	        if (!callback._delayed) {
	          curTime = (new Date()).getTime();
	          lastTime = callback._lastTime || (curTime - 1000 / constants.FPS);
	          elapsed = curTime - lastTime;
	          callback._lastTime = curTime;
	          callback(elapsed / 1000 * constants.FPS, false);
	        }
	      }
	      return setTimeout(((function(_this) {
	        return function() {
	          return _this.buttonLoop();
	        };
	      })(this)), this.DELAY);
	    }
	  };
	
	  Keyboard.prototype.unbind = function() {
	    var binding, i, len, ref;
	    ref = this.bindings;
	    for (i = 0, len = ref.length; i < len; i++) {
	      binding = ref[i];
	      KeyboardJS.unbind.apply(KeyboardJS, binding);
	    }
	  };
	
	  return Keyboard;
	
	})();
	
	Input.Mouse = (function() {
	  var MouseButton;
	
	  MouseButton = (function() {
	    MouseButton.prototype.MOVE_DELTA_THRESHOLD = 30;
	
	    function MouseButton(name, which, mouse, id) {
	      this.name = name;
	      this.which = which;
	      this.mouse = mouse;
	      this.id = id;
	      this.down = false;
	      this.drag = false;
	      this.moveDelta = 0;
	    }
	
	    MouseButton.prototype.handleMouseDown = function(event) {
	      if (event.which === this.which) {
	        $(":focus").blur();
	        this.down = true;
	        this.moveDelta = 0;
	        return this.mouse.trigger(this.name + "MouseDown", this.mouse.lastPosition, this.id, event);
	      }
	    };
	
	    MouseButton.prototype.handleMouseUp = function(event) {
	      if (event.which === this.which && this.down) {
	        this.mouse.trigger(this.name + "MouseUp", event);
	        if (this.moveDelta <= this.MOVE_DELTA_THRESHOLD) {
	          this.mouse.trigger(this.name + "Click", this.mouse.lastPosition, this.id, event);
	        }
	        return this.down = false;
	      }
	    };
	
	    MouseButton.prototype.handleMouseMove = function(event, delta) {
	      if (this.down) {
	        this.moveDelta += Math.abs(delta.x) + Math.abs(delta.y);
	        return this.mouse.trigger(this.name + "DownMove", delta, this.mouse.position, this.id, event);
	      }
	    };
	
	    return MouseButton;
	
	  })();
	
	  function Mouse($target, initialBindings, id) {
	    this.$target = $target;
	    this.id = id;
	    this.mouseWheel = bind(this.mouseWheel, this);
	    this.mouseLeave = bind(this.mouseLeave, this);
	    this.mouseEnter = bind(this.mouseEnter, this);
	    this.mouseMove = bind(this.mouseMove, this);
	    this.mouseUp = bind(this.mouseUp, this);
	    this.mouseDown = bind(this.mouseDown, this);
	    _.extend(this, Backbone.Events);
	    this.leftMouseButton = new MouseButton("left", 1, this, this.id);
	    this.rightMouseButton = new MouseButton("right", 3, this, this.id);
	    this.isMouseOver = false;
	    this.lastPosition = null;
	    $(document).on({
	      "mousemove": this.mouseMove,
	      "mouseup": this.mouseUp
	    });
	    this.$target.on({
	      "mousedown": this.mouseDown,
	      "mouseenter": this.mouseEnter,
	      "mouseleave": this.mouseLeave,
	      "wheel": this.mouseWheel
	    });
	    this.on(initialBindings);
	    this.attach = this.on;
	  }
	
	  Mouse.prototype.unbind = function() {
	    $(document).off({
	      "mousemove": this.mouseMove,
	      "mouseup": this.mouseUp
	    });
	    return this.$target.off({
	      "mousedown": this.mouseDown,
	      "mouseenter": this.mouseEnter,
	      "mouseleave": this.mouseLeave,
	      "wheel": this.mouseWheel
	    });
	  };
	
	  Mouse.prototype.isHit = function(event) {
	    var left, pageX, pageY, ref, top;
	    pageX = event.pageX, pageY = event.pageY;
	    ref = this.$target.offset(), left = ref.left, top = ref.top;
	    return (left <= pageX && pageX <= left + this.$target.width()) && (top <= pageY && pageY <= top + this.$target.height());
	  };
	
	  Mouse.prototype.handle = function() {
	    var args, button, eventName, i, len, ref, results;
	    eventName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    ref = [this.leftMouseButton, this.rightMouseButton];
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      button = ref[i];
	      results.push(button["handle" + eventName].apply(button, args));
	    }
	    return results;
	  };
	
	  Mouse.prototype.mouseDown = function(event) {
	    event.preventDefault();
	    this.lastPosition = {
	      x: event.pageX - this.$target.offset().left,
	      y: event.pageY - this.$target.offset().top
	    };
	    return this.handle("MouseDown", event);
	  };
	
	  Mouse.prototype.mouseUp = function(event) {
	    if (this.isMouseOver) {
	      if (!this.isHit(event)) {
	        this.mouseLeave({
	          which: 0
	        });
	      }
	    } else {
	      if (this.isHit(event)) {
	        this.mouseEnter({
	          which: 0
	        });
	      }
	    }
	    return this.handle("MouseUp", event);
	  };
	
	  Mouse.prototype.mouseMove = function(event) {
	    var delta;
	    this.position = {
	      x: event.pageX - this.$target.offset().left,
	      y: event.pageY - this.$target.offset().top
	    };
	    if (this.lastPosition != null) {
	      delta = {
	        x: this.position.x - this.lastPosition.x,
	        y: this.position.y - this.lastPosition.y
	      };
	    }
	    if ((delta != null ? delta.x : void 0) !== 0 || (delta != null ? delta.y : void 0) !== 0) {
	      this.handle("MouseMove", event, delta);
	      this.lastPosition = this.position;
	    }
	  };
	
	  Mouse.prototype.mouseEnter = function(event) {
	    if (!this.isButtonPressed(event)) {
	      this.isMouseOver = true;
	      this.trigger("over");
	    }
	  };
	
	  Mouse.prototype.mouseLeave = function(event) {
	    if (!this.isButtonPressed(event)) {
	      this.isMouseOver = false;
	      this.trigger("out");
	    }
	  };
	
	  Mouse.prototype.isButtonPressed = function(event) {
	    var b, ref;
	    if ((b = (ref = event.originalEvent) != null ? ref.buttons : void 0) != null) {
	      return b !== 0;
	    }
	    return event.which !== 0;
	  };
	
	  Mouse.prototype.mouseWheel = function(event) {
	    var delta;
	    event.preventDefault();
	    delta = event.originalEvent.wheelDeltaY;
	    if (event.shiftKey) {
	      this.trigger("scroll", delta, "shift");
	    } else if (event.altKey) {
	      this.trigger("scroll", delta, "alt");
	    } else if (event.ctrlKey) {
	      this.trigger("scroll", delta, "ctrl");
	    } else {
	      this.trigger("scroll", delta, null);
	    }
	  };
	
	  return Mouse;
	
	})();
	
	Input.Deviceorientation = (function() {
	  var SLOWDOWN_FACTOR, THRESHOLD;
	
	  THRESHOLD = 10;
	
	  SLOWDOWN_FACTOR = 500;
	
	  Deviceorientation.prototype.keyPressedCallbacks = {};
	
	  Deviceorientation.prototype.keyBindings = {};
	
	  Deviceorientation.prototype.keyPressedCount = 0;
	
	  Deviceorientation.prototype.delay = 1000 / 30;
	
	  function Deviceorientation(bindings) {
	    var callback, key;
	    for (key in bindings) {
	      if (!hasProp.call(bindings, key)) continue;
	      callback = bindings[key];
	      this.attach(key, callback);
	    }
	    $(window).on("deviceorientation", this.eventHandler = (function(_this) {
	      return function(arg) {
	        var beta, event, gamma;
	        event = arg.originalEvent;
	        gamma = event.gamma, beta = event.beta;
	        if (gamma < -THRESHOLD || gamma > THRESHOLD) {
	          _this.fire("x", -gamma);
	        } else {
	          _this.unfire("x");
	        }
	        if (beta < -THRESHOLD || beta > THRESHOLD) {
	          return _this.fire("y", beta);
	        } else {
	          return _this.unfire("y");
	        }
	      };
	    })(this));
	  }
	
	  Deviceorientation.prototype.attach = function(key, callback) {
	    return this.keyBindings[key] = callback;
	  };
	
	  Deviceorientation.prototype.unbind = function() {
	    return $(window).off("deviceorientation", this.eventHandler, this.unfire("x"), this.unfire("y"));
	  };
	
	  Deviceorientation.prototype.fire = function(key, dist) {
	    if (this.keyPressedCallbacks[key] == null) {
	      this.keyPressedCount++;
	      this.keyPressedCallbacks[key] = {
	        callback: this.keyBindings[key],
	        distance: (dist - THRESHOLD) / SLOWDOWN_FACTOR
	      };
	      if (this.keyPressedCount === 1) {
	        return this.buttonLoop();
	      }
	    }
	  };
	
	  Deviceorientation.prototype.unfire = function(key) {
	    if (this.keyPressedCallbacks[key]) {
	      this.keyPressedCount--;
	      delete this.keyPressedCallbacks[key];
	    }
	  };
	
	  Deviceorientation.prototype.buttonLoop = function() {
	    var callback, distance, key, ref, ref1;
	    if (this.keyPressedCount > 0) {
	      ref = this.keyPressedCallbacks;
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        ref1 = ref[key], callback = ref1.callback, distance = ref1.distance;
	        if (typeof callback === "function") {
	          callback(distance);
	        }
	      }
	      return setTimeout(((function(_this) {
	        return function() {
	          return _this.buttonLoop();
	        };
	      })(this)), this.delay);
	    }
	  };
	
	  return Deviceorientation;
	
	})();
	
	module.exports = Input;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2)))

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	
	var Keyboard = __webpack_require__(235);
	var Locale   = __webpack_require__(236);
	var KeyCombo = __webpack_require__(237);
	
	var keyboard = new Keyboard();
	
	keyboard.setLocale('us', __webpack_require__(238));
	
	exports          = module.exports = keyboard;
	exports.Keyboard = Keyboard;
	exports.Locale   = Locale;
	exports.KeyCombo = KeyCombo;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var Locale = __webpack_require__(236);
	var KeyCombo = __webpack_require__(237);
	
	
	function Keyboard(targetWindow, targetElement, platform, userAgent) {
	  this._locale               = null;
	  this._currentContext       = null;
	  this._contexts             = {};
	  this._listeners            = [];
	  this._appliedListeners     = [];
	  this._locales              = {};
	  this._targetElement        = null;
	  this._targetWindow         = null;
	  this._targetPlatform       = '';
	  this._targetUserAgent      = '';
	  this._isModernBrowser      = false;
	  this._targetKeyDownBinding = null;
	  this._targetKeyUpBinding   = null;
	  this._targetResetBinding   = null;
	  this._paused               = false;
	
	  this.setContext('global');
	  this.watch(targetWindow, targetElement, platform, userAgent);
	}
	
	Keyboard.prototype.setLocale = function(localeName, localeBuilder) {
	  var locale = null;
	  if (typeof localeName === 'string') {
	
	    if (localeBuilder) {
	      locale = new Locale(localeName);
	      localeBuilder(locale, this._targetPlatform, this._targetUserAgent);
	    } else {
	      locale = this._locales[localeName] || null;
	    }
	  } else {
	    locale     = localeName;
	    localeName = locale._localeName;
	  }
	
	  this._locale              = locale;
	  this._locales[localeName] = locale;
	  if (locale) {
	    this._locale.pressedKeys = locale.pressedKeys;
	  }
	};
	
	Keyboard.prototype.getLocale = function(localName) {
	  localName || (localName = this._locale.localeName);
	  return this._locales[localName] || null;
	};
	
	Keyboard.prototype.bind = function(keyComboStr, pressHandler, releaseHandler, preventRepeatByDefault) {
	  if (keyComboStr === null || typeof keyComboStr === 'function') {
	    preventRepeatByDefault = releaseHandler;
	    releaseHandler         = pressHandler;
	    pressHandler           = keyComboStr;
	    keyComboStr            = null;
	  }
	
	  if (
	    keyComboStr &&
	    typeof keyComboStr === 'object' &&
	    typeof keyComboStr.length === 'number'
	  ) {
	    for (var i = 0; i < keyComboStr.length; i += 1) {
	      this.bind(keyComboStr[i], pressHandler, releaseHandler);
	    }
	    return;
	  }
	
	  this._listeners.push({
	    keyCombo               : keyComboStr ? new KeyCombo(keyComboStr) : null,
	    pressHandler           : pressHandler           || null,
	    releaseHandler         : releaseHandler         || null,
	    preventRepeat          : preventRepeatByDefault || false,
	    preventRepeatByDefault : preventRepeatByDefault || false
	  });
	};
	Keyboard.prototype.addListener = Keyboard.prototype.bind;
	Keyboard.prototype.on          = Keyboard.prototype.bind;
	
	Keyboard.prototype.unbind = function(keyComboStr, pressHandler, releaseHandler) {
	  if (keyComboStr === null || typeof keyComboStr === 'function') {
	    releaseHandler = pressHandler;
	    pressHandler   = keyComboStr;
	    keyComboStr = null;
	  }
	
	  if (
	    keyComboStr &&
	    typeof keyComboStr === 'object' &&
	    typeof keyComboStr.length === 'number'
	  ) {
	    for (var i = 0; i < keyComboStr.length; i += 1) {
	      this.unbind(keyComboStr[i], pressHandler, releaseHandler);
	    }
	    return;
	  }
	
	  for (var i = 0; i < this._listeners.length; i += 1) {
	    var listener = this._listeners[i];
	
	    var comboMatches          = !keyComboStr && !listener.keyCombo ||
	                                listener.keyCombo.isEqual(keyComboStr);
	    var pressHandlerMatches   = !pressHandler && !releaseHandler ||
	                                !pressHandler && !listener.pressHandler ||
	                                pressHandler === listener.pressHandler;
	    var releaseHandlerMatches = !pressHandler && !releaseHandler ||
	                                !releaseHandler && !listener.releaseHandler ||
	                                releaseHandler === listener.releaseHandler;
	
	    if (comboMatches && pressHandlerMatches && releaseHandlerMatches) {
	      this._listeners.splice(i, 1);
	      i -= 1;
	    }
	  }
	};
	Keyboard.prototype.removeListener = Keyboard.prototype.unbind;
	Keyboard.prototype.off            = Keyboard.prototype.unbind;
	
	Keyboard.prototype.setContext = function(contextName) {
	  if(this._locale) { this.releaseAllKeys(); }
	
	  if (!this._contexts[contextName]) {
	    this._contexts[contextName] = [];
	  }
	  this._listeners      = this._contexts[contextName];
	  this._currentContext = contextName;
	};
	
	Keyboard.prototype.getContext = function() {
	  return this._currentContext;
	};
	
	Keyboard.prototype.withContext = function(contextName, callback) {
	  var previousContextName = this.getContext();
	  this.setContext(contextName);
	
	  callback();
	
	  this.setContext(previousContextName);
	};
	
	Keyboard.prototype.watch = function(targetWindow, targetElement, targetPlatform, targetUserAgent) {
	  var _this = this;
	
	  this.stop();
	
	  if (!targetWindow) {
	    if (!global.addEventListener && !global.attachEvent) {
	      throw new Error('Cannot find global functions addEventListener or attachEvent.');
	    }
	    targetWindow = global;
	  }
	
	  if (typeof targetWindow.nodeType === 'number') {
	    targetUserAgent = targetPlatform;
	    targetPlatform  = targetElement;
	    targetElement   = targetWindow;
	    targetWindow    = global;
	  }
	  
	  if (!targetWindow.addEventListener && !targetWindow.attachEvent) {
	    throw new Error('Cannot find addEventListener or attachEvent methods on targetWindow.');
	  }
	  
	  this._isModernBrowser = !!targetWindow.addEventListener;
	
	  var userAgent = targetWindow.navigator && targetWindow.navigator.userAgent || '';
	  var platform  = targetWindow.navigator && targetWindow.navigator.platform  || '';
	
	  targetElement   && targetElement   !== null || (targetElement   = targetWindow.document);
	  targetPlatform  && targetPlatform  !== null || (targetPlatform  = platform);
	  targetUserAgent && targetUserAgent !== null || (targetUserAgent = userAgent);
	
	  this._targetKeyDownBinding = function(event) {
	    _this.pressKey(event.keyCode, event);
	  };
	  this._targetKeyUpBinding = function(event) {
	    _this.releaseKey(event.keyCode, event);
	  };
	  this._targetResetBinding = function(event) {
	    _this.releaseAllKeys(event)
	  };
	
	  this._bindEvent(targetElement, 'keydown', this._targetKeyDownBinding);
	  this._bindEvent(targetElement, 'keyup',   this._targetKeyUpBinding);
	  this._bindEvent(targetWindow,  'focus',   this._targetResetBinding);
	  this._bindEvent(targetWindow,  'blur',    this._targetResetBinding);
	
	  this._targetElement   = targetElement;
	  this._targetWindow    = targetWindow;
	  this._targetPlatform  = targetPlatform;
	  this._targetUserAgent = targetUserAgent;
	};
	
	Keyboard.prototype.stop = function() {
	  var _this = this;
	
	  if (!this._targetElement || !this._targetWindow) { return; }
	
	  this._unbindEvent(this._targetElement, 'keydown', this._targetKeyDownBinding);
	  this._unbindEvent(this._targetElement, 'keyup',   this._targetKeyUpBinding);
	  this._unbindEvent(this._targetWindow,  'focus',   this._targetResetBinding);
	  this._unbindEvent(this._targetWindow,  'blur',    this._targetResetBinding);
	
	  this._targetWindow  = null;
	  this._targetElement = null;
	};
	
	Keyboard.prototype.pressKey = function(keyCode, event) {
	  if (this._paused) { return; }
	  if (!this._locale) { throw new Error('Locale not set'); }
	
	  this._locale.pressKey(keyCode);
	  this._applyBindings(event);
	};
	
	Keyboard.prototype.releaseKey = function(keyCode, event) {
	  if (this._paused) { return; }
	  if (!this._locale) { throw new Error('Locale not set'); }
	
	  this._locale.releaseKey(keyCode);
	  this._clearBindings(event);
	};
	
	Keyboard.prototype.releaseAllKeys = function(event) {
	  if (this._paused) { return; }
	  if (!this._locale) { throw new Error('Locale not set'); }
	
	  this._locale.pressedKeys.length = 0;
	  this._clearBindings(event);
	};
	
	Keyboard.prototype.pause = function() {
	  if (this._paused) { return; }
	  if (this._locale) { this.releaseAllKeys(); }
	  this._paused = true;
	};
	
	Keyboard.prototype.resume = function() {
	  this._paused = false;
	};
	
	Keyboard.prototype.reset = function() {
	  this.releaseAllKeys();
	  this._listeners.length = 0;
	};
	
	Keyboard.prototype._bindEvent = function(targetElement, eventName, handler) {
	  return this._isModernBrowser ?
	    targetElement.addEventListener(eventName, handler, false) :
	    targetElement.attachEvent('on' + eventName, handler);
	};
	
	Keyboard.prototype._unbindEvent = function(targetElement, eventName, handler) {
	  return this._isModernBrowser ?
	    targetElement.removeEventListener(eventName, handler, false) :
	    targetElement.detachEvent('on' + eventName, handler);
	};
	
	Keyboard.prototype._getGroupedListeners = function() {
	  var listenerGroups   = [];
	  var listenerGroupMap = [];
	
	  var listeners = this._listeners;
	  if (this._currentContext !== 'global') {
	    listeners = [].concat(listeners, this._contexts.global);
	  }
	
	  listeners.sort(function(a, b) {
	    return a.keyCombo.keyNames.length < b.keyCombo.keyNames.length;
	  }).forEach(function(l) {
	    var mapIndex = -1;
	    for (var i = 0; i < listenerGroupMap.length; i += 1) {
	      if (listenerGroupMap[i].isEqual(l.keyCombo)) {
	        mapIndex = i;
	      }
	    }
	    if (mapIndex === -1) {
	      mapIndex = listenerGroupMap.length;
	      listenerGroupMap.push(l.keyCombo);
	    }
	    if (!listenerGroups[mapIndex]) {
	      listenerGroups[mapIndex] = [];
	    }
	    listenerGroups[mapIndex].push(l);
	  });
	  return listenerGroups;
	};
	
	Keyboard.prototype._applyBindings = function(event) {
	  var preventRepeat = false;
	
	  event || (event = {});
	  event.preventRepeat = function() { preventRepeat = true; };
	  event.pressedKeys   = this._locale.pressedKeys.slice(0);
	
	  var pressedKeys    = this._locale.pressedKeys.slice(0);
	  var listenerGroups = this._getGroupedListeners();
	
	
	  for (var i = 0; i < listenerGroups.length; i += 1) {
	    var listeners = listenerGroups[i];
	    var keyCombo  = listeners[0].keyCombo;
	
	    if (keyCombo === null || keyCombo.check(pressedKeys)) {
	      for (var j = 0; j < listeners.length; j += 1) {
	        var listener = listeners[j];
	
	        if (keyCombo === null) {
	          listener = {
	            keyCombo               : new KeyCombo(pressedKeys.join('+')),
	            pressHandler           : listener.pressHandler,
	            releaseHandler         : listener.releaseHandler,
	            preventRepeat          : listener.preventRepeat,
	            preventRepeatByDefault : listener.preventRepeatByDefault
	          };
	        }
	
	        if (listener.pressHandler && !listener.preventRepeat) {
	          listener.pressHandler.call(this, event);
	          if (preventRepeat) {
	            listener.preventRepeat = preventRepeat;
	            preventRepeat          = false;
	          }
	        }
	
	        if (listener.releaseHandler && this._appliedListeners.indexOf(listener) === -1) {
	          this._appliedListeners.push(listener);
	        }
	      }
	
	      if (keyCombo) {
	        for (var j = 0; j < keyCombo.keyNames.length; j += 1) {
	          var index = pressedKeys.indexOf(keyCombo.keyNames[j]);
	          if (index !== -1) {
	            pressedKeys.splice(index, 1);
	            j -= 1;
	          }
	        }
	      }
	    }
	  }
	};
	
	Keyboard.prototype._clearBindings = function(event) {
	  event || (event = {});
	
	  for (var i = 0; i < this._appliedListeners.length; i += 1) {
	    var listener = this._appliedListeners[i];
	    var keyCombo = listener.keyCombo;
	    if (keyCombo === null || !keyCombo.check(this._locale.pressedKeys)) {
	      listener.preventRepeat = listener.preventRepeatByDefault;
	      listener.releaseHandler.call(this, event);
	      this._appliedListeners.splice(i, 1);
	      i -= 1;
	    }
	  }
	};
	
	module.exports = Keyboard;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	
	var KeyCombo = __webpack_require__(237);
	
	
	function Locale(name) {
	  this.localeName     = name;
	  this.pressedKeys    = [];
	  this._appliedMacros = [];
	  this._keyMap        = {};
	  this._killKeyCodes  = [];
	  this._macros        = [];
	}
	
	Locale.prototype.bindKeyCode = function(keyCode, keyNames) {
	  if (typeof keyNames === 'string') {
	    keyNames = [keyNames];
	  }
	
	  this._keyMap[keyCode] = keyNames;
	};
	
	Locale.prototype.bindMacro = function(keyComboStr, keyNames) {
	  if (typeof keyNames === 'string') {
	    keyNames = [ keyNames ];
	  }
	
	  var handler = null;
	  if (typeof keyNames === 'function') {
	    handler = keyNames;
	    keyNames = null;
	  }
	
	  var macro = {
	    keyCombo : new KeyCombo(keyComboStr),
	    keyNames : keyNames,
	    handler  : handler
	  };
	
	  this._macros.push(macro);
	};
	
	Locale.prototype.getKeyCodes = function(keyName) {
	  var keyCodes = [];
	  for (var keyCode in this._keyMap) {
	    var index = this._keyMap[keyCode].indexOf(keyName);
	    if (index > -1) { keyCodes.push(keyCode|0); }
	  }
	  return keyCodes;
	};
	
	Locale.prototype.getKeyNames = function(keyCode) {
	  return this._keyMap[keyCode] || [];
	};
	
	Locale.prototype.setKillKey = function(keyCode) {
	  if (typeof keyCode === 'string') {
	    var keyCodes = this.getKeyCodes(keyCode);
	    for (var i = 0; i < keyCodes.length; i += 1) {
	      this.setKillKey(keyCodes[i]);
	    }
	    return;
	  }
	
	  this._killKeyCodes.push(keyCode);
	};
	
	Locale.prototype.pressKey = function(keyCode) {
	  if (typeof keyCode === 'string') {
	    var keyCodes = this.getKeyCodes(keyCode);
	    for (var i = 0; i < keyCodes.length; i += 1) {
	      this.pressKey(keyCodes[i]);
	    }
	    return;
	  }
	
	  var keyNames = this.getKeyNames(keyCode);
	  for (var i = 0; i < keyNames.length; i += 1) {
	    if (this.pressedKeys.indexOf(keyNames[i]) === -1) {
	      this.pressedKeys.push(keyNames[i]);
	    }
	  }
	
	  this._applyMacros();
	};
	
	Locale.prototype.releaseKey = function(keyCode) {
	  if (typeof keyCode === 'string') {
	    var keyCodes = this.getKeyCodes(keyCode);
	    for (var i = 0; i < keyCodes.length; i += 1) {
	      this.releaseKey(keyCodes[i]);
	    }
	  }
	
	  else {
	    var keyNames         = this.getKeyNames(keyCode);
	    var killKeyCodeIndex = this._killKeyCodes.indexOf(keyCode);
	    
	    if (killKeyCodeIndex > -1) {
	      this.pressedKeys.length = 0;
	    } else {
	      for (var i = 0; i < keyNames.length; i += 1) {
	        var index = this.pressedKeys.indexOf(keyNames[i]);
	        if (index > -1) {
	          this.pressedKeys.splice(index, 1);
	        }
	      }
	    }
	
	    this._clearMacros();
	  }
	};
	
	Locale.prototype._applyMacros = function() {
	  var macros = this._macros.slice(0);
	  for (var i = 0; i < macros.length; i += 1) {
	    var macro = macros[i];
	    if (macro.keyCombo.check(this.pressedKeys)) {
	      if (macro.handler) {
	        macro.keyNames = macro.handler(this.pressedKeys);
	      }
	      for (var j = 0; j < macro.keyNames.length; j += 1) {
	        if (this.pressedKeys.indexOf(macro.keyNames[j]) === -1) {
	          this.pressedKeys.push(macro.keyNames[j]);
	        }
	      }
	      this._appliedMacros.push(macro);
	    }
	  }
	};
	
	Locale.prototype._clearMacros = function() {
	  for (var i = 0; i < this._appliedMacros.length; i += 1) {
	    var macro = this._appliedMacros[i];
	    if (!macro.keyCombo.check(this.pressedKeys)) {
	      for (var j = 0; j < macro.keyNames.length; j += 1) {
	        var index = this.pressedKeys.indexOf(macro.keyNames[j]);
	        if (index > -1) {
	          this.pressedKeys.splice(index, 1);
	        }
	      }
	      if (macro.handler) {
	        macro.keyNames = null;
	      }
	      this._appliedMacros.splice(i, 1);
	      i -= 1;
	    }
	  }
	};
	
	
	module.exports = Locale;


/***/ },
/* 237 */
/***/ function(module, exports) {

	
	function KeyCombo(keyComboStr) {
	  this.sourceStr = keyComboStr;
	  this.subCombos = KeyCombo.parseComboStr(keyComboStr);
	  this.keyNames  = this.subCombos.reduce(function(memo, nextSubCombo) {
	    return memo.concat(nextSubCombo);
	  });
	}
	
	// TODO: Add support for key combo sequences
	KeyCombo.sequenceDeliminator = '>>';
	KeyCombo.comboDeliminator    = '>';
	KeyCombo.keyDeliminator      = '+';
	
	KeyCombo.parseComboStr = function(keyComboStr) {
	  var subComboStrs = KeyCombo._splitStr(keyComboStr, KeyCombo.comboDeliminator);
	  var combo        = [];
	
	  for (var i = 0 ; i < subComboStrs.length; i += 1) {
	    combo.push(KeyCombo._splitStr(subComboStrs[i], KeyCombo.keyDeliminator));
	  }
	  return combo;
	};
	
	KeyCombo.prototype.check = function(pressedKeyNames) {
	  var startingKeyNameIndex = 0;
	  for (var i = 0; i < this.subCombos.length; i += 1) {
	    startingKeyNameIndex = this._checkSubCombo(
	      this.subCombos[i],
	      startingKeyNameIndex,
	      pressedKeyNames
	    );
	    if (startingKeyNameIndex === -1) { return false; }
	  }
	  return true;
	};
	
	KeyCombo.prototype.isEqual = function(otherKeyCombo) {
	  if (
	    !otherKeyCombo ||
	    typeof otherKeyCombo !== 'string' &&
	    typeof otherKeyCombo !== 'object'
	  ) { return false; }
	
	  if (typeof otherKeyCombo === 'string') {
	    otherKeyCombo = new KeyCombo(otherKeyCombo);
	  }
	
	  if (this.subCombos.length !== otherKeyCombo.subCombos.length) {
	    return false;
	  }
	  for (var i = 0; i < this.subCombos.length; i += 1) {
	    if (this.subCombos[i].length !== otherKeyCombo.subCombos[i].length) {
	      return false;
	    }
	  }
	
	  for (var i = 0; i < this.subCombos.length; i += 1) {
	    var subCombo      = this.subCombos[i];
	    var otherSubCombo = otherKeyCombo.subCombos[i].slice(0);
	
	    for (var j = 0; j < subCombo.length; j += 1) {
	      var keyName = subCombo[j];
	      var index   = otherSubCombo.indexOf(keyName);
	
	      if (index > -1) {
	        otherSubCombo.splice(index, 1);
	      }
	    }
	    if (otherSubCombo.length !== 0) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	KeyCombo._splitStr = function(str, deliminator) {
	  var s  = str;
	  var d  = deliminator;
	  var c  = '';
	  var ca = [];
	
	  for (var ci = 0; ci < s.length; ci += 1) {
	    if (ci > 0 && s[ci] === d && s[ci - 1] !== '\\') {
	      ca.push(c.trim());
	      c = '';
	      ci += 1;
	    }
	    c += s[ci];
	  }
	  if (c) { ca.push(c.trim()); }
	
	  return ca;
	};
	
	KeyCombo.prototype._checkSubCombo = function(subCombo, startingKeyNameIndex, pressedKeyNames) {
	  subCombo = subCombo.slice(0);
	  pressedKeyNames = pressedKeyNames.slice(startingKeyNameIndex);
	
	  var endIndex = startingKeyNameIndex;
	  for (var i = 0; i < subCombo.length; i += 1) {
	
	    var keyName = subCombo[i];
	    if (keyName[0] === '\\') {
	      var escapedKeyName = keyName.slice(1);
	      if (
	        escapedKeyName === KeyCombo.comboDeliminator ||
	        escapedKeyName === KeyCombo.keyDeliminator
	      ) {
	        keyName = escapedKeyName;
	      }
	    }
	
	    var index = pressedKeyNames.indexOf(keyName);
	    if (index > -1) {
	      subCombo.splice(i, 1);
	      i -= 1;
	      if (index > endIndex) {
	        endIndex = index;
	      }
	      if (subCombo.length === 0) {
	        return endIndex;
	      }
	    }
	  }
	  return -1;
	};
	
	
	module.exports = KeyCombo;


/***/ },
/* 238 */
/***/ function(module, exports) {

	
	module.exports = function(locale, platform, userAgent) {
	
	  // general
	  locale.bindKeyCode(3,   ['cancel']);
	  locale.bindKeyCode(8,   ['backspace']);
	  locale.bindKeyCode(9,   ['tab']);
	  locale.bindKeyCode(12,  ['clear']);
	  locale.bindKeyCode(13,  ['enter']);
	  locale.bindKeyCode(16,  ['shift']);
	  locale.bindKeyCode(17,  ['ctrl']);
	  locale.bindKeyCode(18,  ['alt', 'menu']);
	  locale.bindKeyCode(19,  ['pause', 'break']);
	  locale.bindKeyCode(20,  ['capslock']);
	  locale.bindKeyCode(27,  ['escape', 'esc']);
	  locale.bindKeyCode(32,  ['space', 'spacebar']);
	  locale.bindKeyCode(33,  ['pageup']);
	  locale.bindKeyCode(34,  ['pagedown']);
	  locale.bindKeyCode(35,  ['end']);
	  locale.bindKeyCode(36,  ['home']);
	  locale.bindKeyCode(37,  ['left']);
	  locale.bindKeyCode(38,  ['up']);
	  locale.bindKeyCode(39,  ['right']);
	  locale.bindKeyCode(40,  ['down']);
	  locale.bindKeyCode(41,  ['select']);
	  locale.bindKeyCode(42,  ['printscreen']);
	  locale.bindKeyCode(43,  ['execute']);
	  locale.bindKeyCode(44,  ['snapshot']);
	  locale.bindKeyCode(45,  ['insert', 'ins']);
	  locale.bindKeyCode(46,  ['delete', 'del']);
	  locale.bindKeyCode(47,  ['help']);
	  locale.bindKeyCode(145, ['scrolllock', 'scroll']);
	  locale.bindKeyCode(187, ['equal', 'equalsign', '=']);
	  locale.bindKeyCode(188, ['comma', ',']);
	  locale.bindKeyCode(190, ['period', '.']);
	  locale.bindKeyCode(191, ['slash', 'forwardslash', '/']);
	  locale.bindKeyCode(192, ['graveaccent', '`']);
	  locale.bindKeyCode(219, ['openbracket', '[']);
	  locale.bindKeyCode(220, ['backslash', '\\']);
	  locale.bindKeyCode(221, ['closebracket', ']']);
	  locale.bindKeyCode(222, ['apostrophe', '\'']);
	
	  // 0-9
	  locale.bindKeyCode(48, ['zero', '0']);
	  locale.bindKeyCode(49, ['one', '1']);
	  locale.bindKeyCode(50, ['two', '2']);
	  locale.bindKeyCode(51, ['three', '3']);
	  locale.bindKeyCode(52, ['four', '4']);
	  locale.bindKeyCode(53, ['five', '5']);
	  locale.bindKeyCode(54, ['six', '6']);
	  locale.bindKeyCode(55, ['seven', '7']);
	  locale.bindKeyCode(56, ['eight', '8']);
	  locale.bindKeyCode(57, ['nine', '9']);
	
	  // numpad
	  locale.bindKeyCode(96, ['numzero', 'num0']);
	  locale.bindKeyCode(97, ['numone', 'num1']);
	  locale.bindKeyCode(98, ['numtwo', 'num2']);
	  locale.bindKeyCode(99, ['numthree', 'num3']);
	  locale.bindKeyCode(100, ['numfour', 'num4']);
	  locale.bindKeyCode(101, ['numfive', 'num5']);
	  locale.bindKeyCode(102, ['numsix', 'num6']);
	  locale.bindKeyCode(103, ['numseven', 'num7']);
	  locale.bindKeyCode(104, ['numeight', 'num8']);
	  locale.bindKeyCode(105, ['numnine', 'num9']);
	  locale.bindKeyCode(106, ['nummultiply', 'num*']);
	  locale.bindKeyCode(107, ['numadd', 'num+']);
	  locale.bindKeyCode(108, ['numenter']);
	  locale.bindKeyCode(109, ['numsubtract', 'num-']);
	  locale.bindKeyCode(110, ['numdecimal', 'num.']);
	  locale.bindKeyCode(111, ['numdivide', 'num/']);
	  locale.bindKeyCode(144, ['numlock', 'num']);
	
	  // function keys
	  locale.bindKeyCode(112, ['f1']);
	  locale.bindKeyCode(113, ['f2']);
	  locale.bindKeyCode(114, ['f3']);
	  locale.bindKeyCode(115, ['f4']);
	  locale.bindKeyCode(116, ['f5']);
	  locale.bindKeyCode(117, ['f6']);
	  locale.bindKeyCode(118, ['f7']);
	  locale.bindKeyCode(119, ['f8']);
	  locale.bindKeyCode(120, ['f9']);
	  locale.bindKeyCode(121, ['f10']);
	  locale.bindKeyCode(122, ['f11']);
	  locale.bindKeyCode(123, ['f12']);
	
	  // secondary key symbols
	  locale.bindMacro('shift + `', ['tilde', '~']);
	  locale.bindMacro('shift + 1', ['exclamation', 'exclamationpoint', '!']);
	  locale.bindMacro('shift + 2', ['at', '@']);
	  locale.bindMacro('shift + 3', ['number', '#']);
	  locale.bindMacro('shift + 4', ['dollar', 'dollars', 'dollarsign', '$']);
	  locale.bindMacro('shift + 5', ['percent', '%']);
	  locale.bindMacro('shift + 6', ['caret', '^']);
	  locale.bindMacro('shift + 7', ['ampersand', 'and', '&']);
	  locale.bindMacro('shift + 8', ['asterisk', '*']);
	  locale.bindMacro('shift + 9', ['openparen', '(']);
	  locale.bindMacro('shift + 0', ['closeparen', ')']);
	  locale.bindMacro('shift + -', ['underscore', '_']);
	  locale.bindMacro('shift + =', ['plus', '+']);
	  locale.bindMacro('shift + [', ['opencurlybrace', 'opencurlybracket', '{']);
	  locale.bindMacro('shift + ]', ['closecurlybrace', 'closecurlybracket', '}']);
	  locale.bindMacro('shift + \\', ['verticalbar', '|']);
	  locale.bindMacro('shift + ;', ['colon', ':']);
	  locale.bindMacro('shift + \'', ['quotationmark', '\'']);
	  locale.bindMacro('shift + !,', ['openanglebracket', '<']);
	  locale.bindMacro('shift + .', ['closeanglebracket', '>']);
	  locale.bindMacro('shift + /', ['questionmark', '?']);
	
	  //a-z and A-Z
	  for (var keyCode = 65; keyCode <= 90; keyCode += 1) {
	    var keyName = String.fromCharCode(keyCode + 32);
	    var capitalKeyName = String.fromCharCode(keyCode);
	  	locale.bindKeyCode(keyCode, keyName);
	  	locale.bindMacro('shift + ' + keyName, capitalKeyName);
	  	locale.bindMacro('capslock + ' + keyName, capitalKeyName);
	  }
	
	  // browser caveats
	  var semicolonKeyCode = userAgent.match('Firefox') ? 59  : 186;
	  var dashKeyCode      = userAgent.match('Firefox') ? 173 : 189;
	  var leftCommandKeyCode;
	  var rightCommandKeyCode;
	  if (platform.match('Mac') && (userAgent.match('Safari') || userAgent.match('Chrome'))) {
	    leftCommandKeyCode  = 91;
	    rightCommandKeyCode = 93;
	  } else if(platform.match('Mac') && userAgent.match('Opera')) {
	    leftCommandKeyCode  = 17;
	    rightCommandKeyCode = 17;
	  } else if(platform.match('Mac') && userAgent.match('Firefox')) {
	    leftCommandKeyCode  = 224;
	    rightCommandKeyCode = 224;
	  }
	  locale.bindKeyCode(semicolonKeyCode,    ['semicolon', ';']);
	  locale.bindKeyCode(dashKeyCode,         ['dash', '-']);
	  locale.bindKeyCode(leftCommandKeyCode,  ['command', 'windows', 'win', 'super', 'leftcommand', 'leftwindows', 'leftwin', 'leftsuper']);
	  locale.bindKeyCode(rightCommandKeyCode, ['command', 'windows', 'win', 'super', 'rightcommand', 'rightwindows', 'rightwin', 'rightsuper']);
	
	  // kill keys
	  locale.setKillKey('command');
	};


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var CommentTabItemView, Marionette, Utils, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Marionette = __webpack_require__(49);
	
	app = __webpack_require__(48);
	
	Utils = __webpack_require__(188);
	
	CommentTabItemView = (function(superClass) {
	  extend(CommentTabItemView, superClass);
	
	  function CommentTabItemView() {
	    return CommentTabItemView.__super__.constructor.apply(this, arguments);
	  }
	
	  CommentTabItemView.prototype.tagName = "li";
	
	  CommentTabItemView.prototype.template = _.template("<i class=\"fa <%- isActive() %>\"></i>\n<a href=\"#\"><%- node %> <%- content %></a>");
	
	  CommentTabItemView.prototype.events = {
	    "click a": "setActiveNode"
	  };
	
	  CommentTabItemView.prototype.templateHelpers = function() {
	    return {
	      isActive: (function(_this) {
	        return function() {
	          if (_this.model.get("node") === _this.activeCommentId) {
	            return "fa-angle-right";
	          } else {
	            return "";
	          }
	        };
	      })(this)
	    };
	  };
	
	  CommentTabItemView.prototype.initialize = function(options) {
	    var activeComment;
	    activeComment = options.activeComment, this.parent = options.parent;
	    this.activeCommentId = activeComment.get("node");
	    this.listenTo(this.parent.model.skeletonTracing, "newActiveNode", this.update);
	    return this.listenTo(this.model, "change", this.render);
	  };
	
	  CommentTabItemView.prototype.update = function(activeCommentId) {
	    this.activeCommentId = activeCommentId;
	    this.render();
	    if (this.model.get("node") === this.activeCommentId && !Utils.isElementInViewport(this.el)) {
	      return this.el.scrollIntoView();
	    }
	  };
	
	  CommentTabItemView.prototype.setActiveNode = function() {
	    return this.parent.setActiveNode(this.model);
	  };
	
	  return CommentTabItemView;
	
	})(Marionette.ItemView);
	
	module.exports = CommentTabItemView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {var AbstractTreeRenderer, AbstractTreeView, Marionette, _, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	app = __webpack_require__(48);
	
	Marionette = __webpack_require__(49);
	
	AbstractTreeRenderer = __webpack_require__(241);
	
	AbstractTreeView = (function(superClass) {
	  extend(AbstractTreeView, superClass);
	
	  function AbstractTreeView() {
	    return AbstractTreeView.__super__.constructor.apply(this, arguments);
	  }
	
	  AbstractTreeView.prototype.className = "flex-column";
	
	  AbstractTreeView.prototype.template = _.template("<canvas id=\"abstract-tree-canvas\">");
	
	  AbstractTreeView.prototype.ui = {
	    "canvas": "canvas"
	  };
	
	  AbstractTreeView.prototype.events = {
	    "click @ui.canvas": "handleClick"
	  };
	
	  AbstractTreeView.prototype.initialize = function() {
	    this.listenTo(app.vent, "planes:resize", this.resize);
	    this.listenTo(app.vent, "view:setTheme", this.drawTree);
	    this.listenTo(this.model.user, "change:renderComments", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "newActiveNode", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "newActiveTree", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "newTree", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "mergeTree", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "reloadTrees", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "deleteTree", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "deleteActiveNode", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "newNode", this.drawTree);
	    this.listenTo(this.model.skeletonTracing, "updateComments", this.drawTree);
	    this.initialized = false;
	    return $(window).on("resize", (function(_this) {
	      return function() {
	        return _this.drawTree();
	      };
	    })(this));
	  };
	
	  AbstractTreeView.prototype.resize = function() {
	    this.initialized = true;
	    return this.render();
	  };
	
	  AbstractTreeView.prototype.render = function() {
	    AbstractTreeView.__super__.render.call(this);
	    if (this.initialized) {
	      this.abstractTreeRenderer = new AbstractTreeRenderer(this.ui.canvas);
	    }
	    return this.drawTree();
	  };
	
	  AbstractTreeView.prototype.drawTree = function() {
	    if (this.model.skeletonTracing && this.abstractTreeRenderer) {
	      this.abstractTreeRenderer.renderComments(this.model.user.get("renderComments"));
	      return this.abstractTreeRenderer.drawTree(this.model.skeletonTracing.getTree(), this.model.skeletonTracing.getActiveNodeId(), this.model.skeletonTracing.comments);
	    }
	  };
	
	  AbstractTreeView.prototype.handleClick = function(event) {
	    var id;
	    id = this.abstractTreeRenderer.getIdFromPos(event.offsetX, event.offsetY);
	    if (id) {
	      this.model.skeletonTracing.trigger("newActiveNode", id);
	      return this.model.skeletonTracing.centerActiveNode();
	    }
	  };
	
	  return AbstractTreeView;
	
	})(Marionette.ItemView);
	
	module.exports = AbstractTreeView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var AbstractTreeRenderer, Backbone, Constants, Toast, app,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	Backbone = __webpack_require__(3);
	
	app = __webpack_require__(48);
	
	Constants = __webpack_require__(61);
	
	Toast = __webpack_require__(18);
	
	AbstractTreeRenderer = (function() {
	  AbstractTreeRenderer.prototype.NODE_RADIUS = 2;
	
	  AbstractTreeRenderer.prototype.MAX_NODE_DISTANCE = 100;
	
	  AbstractTreeRenderer.prototype.CLICK_TRESHOLD = 6;
	
	  AbstractTreeRenderer.prototype.MODE_NORMAL = 0;
	
	  AbstractTreeRenderer.prototype.MODE_NOCHAIN = 1;
	
	  AbstractTreeRenderer.prototype.RENDER_COMMENTS = true;
	
	  function AbstractTreeRenderer($canvas) {
	    this.getIdFromPos = bind(this.getIdFromPos, this);
	    _.extend(this, Backbone.Events);
	    this.canvas = $canvas;
	    this.ctx = $canvas[0].getContext("2d");
	    this.ctx.lineWidth = 1;
	    this.nodeList = [];
	  }
	
	
	  /**
	   * Render function called by events and GUI.
	   * Draws the abstract tree, emphasizes the active node
	   * and highlights comments, if enabled.
	   * @param  {TracePoint} tree
	   * @param  {Number} @activeNodeId TracePoint id
	   * @param  {BackboneCollection} @comments
	   */
	
	  AbstractTreeRenderer.prototype.drawTree = function(tree, activeNodeId, comments) {
	    var e, error, mode, root;
	    this.activeNodeId = activeNodeId;
	    this.comments = comments;
	    if (tree == null) {
	      return;
	    }
	    this.setDimensions(this.canvas.width(), this.canvas.height());
	    this.clearBackground();
	    this.setupColors();
	    this.nodeList = [];
	    mode = this.MODE_NOCHAIN;
	    try {
	      root = tree.buildTree();
	    } catch (error) {
	      e = error;
	      console.log("Error:", e);
	      if (e === "CyclicTree") {
	        if (!this._cyclicTreeWarningIssued) {
	          Toast.error("Cyclic trees (Tree-ID: " + tree.treeId + ") are not supported by webKnossos. Please check the .nml file.");
	          this._cyclicTreeWarningIssued = true;
	        }
	        return;
	      }
	    }
	    if (root == null) {
	      return;
	    }
	    this.nodeDistance = Math.min(this.canvas.height() / (this.getMaxTreeDepth(root, mode) + 1), this.MAX_NODE_DISTANCE);
	    this.recordWidths(root);
	    this.drawTreeWithWidths(root, this.NODE_RADIUS, this.canvas.width() - this.NODE_RADIUS, this.nodeDistance / 2, mode);
	    return this.drawAllNodes();
	  };
	
	
	  /**
	   * Draws a whole tree inside the given borders.
	   * Thus it fits on the canvas and scales as the tree grows.
	   * @param  {TracePoint} tree
	   * @param  {Number} left  left border in pixels
	   * @param  {Number} right right border in pixels
	   * @param  {Number} top   y coordinate in pixels
	   * @param  {Number} mode  @MODE_NORMAL or @MODE_NOCHAIN
	   * @return {Object}       new middle and top coordinates in pixels
	   */
	
	  AbstractTreeRenderer.prototype.drawTreeWithWidths = function(tree, left, right, top, mode) {
	    var decision, middle;
	    decision = this.getNextDecision(tree);
	    middle = this.calculateMiddle(left, right);
	    if (decision.isBranch) {
	      middle = this.drawBranch(decision, left, right, top, mode);
	    } else if (!decision.isLeaf) {
	      middle = this.drawCommentChain(decision, left, right, top, mode);
	    }
	    if (mode === this.MODE_NORMAL || decision.chainCount < 3) {
	      this.drawChainFromTo(top, middle, tree, decision);
	    } else if (mode === this.MODE_NOCHAIN) {
	      this.drawChainWithChainIndicatorFromTo(top, middle, tree, decision);
	    }
	    return {
	      middle: middle,
	      top: top
	    };
	  };
	
	
	  /**
	   * Find the next node which have to be considered in an extra way.
	   * These are:
	   *   - branch points
	   *   - leaves
	   *   - commented nodes
	   * @param  {TracePoint} tree
	   * @return {Decision}
	   */
	
	  AbstractTreeRenderer.prototype.getNextDecision = function(tree) {
	    var chainCount, hasActiveNode;
	    chainCount = 0;
	    hasActiveNode = false;
	    if (tree.children.length === 1) {
	      tree = tree.children[0];
	      chainCount++;
	    }
	    while (tree.children.length === 1 && !this.nodeIdHasComment(tree.id)) {
	      if (!hasActiveNode) {
	        hasActiveNode = tree.id === this.activeNodeId;
	      }
	      tree = tree.children[0];
	      chainCount++;
	    }
	    return {
	      node: tree,
	      chainCount: chainCount,
	      isBranch: tree.children.length > 1,
	      isLeaf: tree.children.length === 0,
	      hasActiveNode: hasActiveNode
	    };
	  };
	
	
	  /**
	   * Draw a branch point as well as the left and right subtree.
	   * @param  {Decision} decision
	   * @param  {Number} left     left border in pixels
	   * @param  {Number} right    right border in pixels
	   * @param  {Number} top      y coordinate in pixels
	   * @param  {Number} mode     @MODE_NORMAL or @MODE_NOCHAIN
	   * @return {Number}          new middle coordinate in pixels
	   */
	
	  AbstractTreeRenderer.prototype.drawBranch = function(decision, left, right, top, mode) {
	    var branchMiddle, leftTree, middle, rightTree, topChildren;
	    branchMiddle = this.calculateBranchMiddle(decision, left, right);
	    topChildren = this.calculateChildTop(decision.chainCount, top, mode);
	    leftTree = this.drawTreeWithWidths(decision.node.children[0], left, branchMiddle, topChildren, mode);
	    rightTree = this.drawTreeWithWidths(decision.node.children[1], branchMiddle, right, topChildren, mode);
	    middle = this.calculateMiddle(leftTree.middle, rightTree.middle);
	    this.drawEdge(middle, topChildren - this.nodeDistance, leftTree.middle, leftTree.top);
	    this.drawEdge(middle, topChildren - this.nodeDistance, rightTree.middle, rightTree.top);
	    return middle;
	  };
	
	
	  /**
	   * Draw a sequence of nodes which begins with a comment.
	   * @param  {Decision}        decision
	   * @param  {Number} left     left border in pixels
	   * @param  {Number} right    right border in pixels
	   * @param  {Number} top      y coordinate in pixels
	   * @param  {Number} mode     @MODE_NORMAL or @MODE_NOCHAIN
	   * @return {Number}          new middle coordinate in pixels
	   */
	
	  AbstractTreeRenderer.prototype.drawCommentChain = function(decision, left, right, top, mode) {
	    var extent, topChild;
	    topChild = this.calculateTop(decision.chainCount, top, mode);
	    extent = this.drawTreeWithWidths(decision.node, left, right, topChild, mode);
	    return extent.middle;
	  };
	
	
	  /**
	   * Draws a sequence of nodes and the edges in between.
	   * @param  {Number} top      y coordinate in pixels
	   * @param  {Number} left     x coordinate in pixels
	   * @param  {TracePoint} tree
	   * @param  {Decision} decision
	   */
	
	  AbstractTreeRenderer.prototype.drawChainFromTo = function(top, left, tree, decision) {
	    var i, j, node, ref, results;
	    node = tree;
	    results = [];
	    for (i = j = 0, ref = decision.chainCount; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
	      this.addNode(left, top + i * this.nodeDistance, node.id);
	      node = node.children[0];
	      if (i !== 0) {
	        results.push(this.drawEdge(left, top + (i - 1) * this.nodeDistance, left, top + i * this.nodeDistance));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	
	  /**
	   * Draws the dashed chain indicator and the start and end nodes.
	   * @param  {Number} top      y coordinate in pixels
	   * @param  {Number} middle   middel x coordinate in pixels
	   * @param  {TracePoint} tree
	   * @param  {Decision} decision
	   */
	
	  AbstractTreeRenderer.prototype.drawChainWithChainIndicatorFromTo = function(top, middle, tree, decision) {
	    this.addNode(middle, top, tree.id);
	    this.drawEdge(middle, top, middle, top + 0.5 * this.nodeDistance);
	    this.drawChainIndicator(middle, top + 0.5 * this.nodeDistance, top + 1.5 * this.nodeDistance, decision.hasActiveNode);
	    this.drawEdge(middle, top + 1.5 * this.nodeDistance, middle, top + 2 * this.nodeDistance);
	    return this.addNode(middle, top + 2 * this.nodeDistance, decision.node.id);
	  };
	
	
	  /**
	   * Calculate middle that divides the left and right tree, if any.
	   * Middle is weighted accordingly to the subtrees` widths.
	   * @param  {Decision} decision
	   * @param  {Number} left           left border in pixels
	   * @param  {Number} right          right border in pixels
	   * @return {Number}                middle in pixels
	   */
	
	  AbstractTreeRenderer.prototype.calculateBranchMiddle = function(decision, left, right) {
	    var leftChild, rightChild;
	    leftChild = decision.node.children[0];
	    rightChild = decision.node.children[1];
	    return (right - left) * leftChild.width / (leftChild.width + rightChild.width) + left;
	  };
	
	
	  /**
	   * Calculate middle of a left and right border.
	   * @param  {Number} left  left border in pixels
	   * @param  {Number} right right border in pixels
	   * @return {Number}       middle in pixels
	   */
	
	  AbstractTreeRenderer.prototype.calculateMiddle = function(left, right) {
	    return (left + right) / 2;
	  };
	
	
	  /**
	   * Calculate the y coordinate of a node.
	   * @param  {Number} chainCount amount of chained nodes since the parent node
	   * @param  {Number} top        y coordinate of the parent node
	   * @param  {Number} mode       @MODE_NORMAL or @MODE_NOCHAIN
	   * @return {Number}            y coordinate of the current decision node
	   */
	
	  AbstractTreeRenderer.prototype.calculateTop = function(chainCount, top, mode) {
	    if (mode === this.MODE_NORMAL || chainCount < 3) {
	      return top + chainCount * this.nodeDistance;
	    } else if (mode === this.MODE_NOCHAIN) {
	      return top + 2 * this.nodeDistance;
	    }
	  };
	
	
	  /**
	   * Calculate the y coordinate of the first child of a node.
	   * @param  {Number} chainCount amount of chained nodes since the parent node
	   * @param  {Number} top        y coordinate of the parent node
	   * @param  {Number} mode       @MODE_NORMAL or @MODE_NOCHAIN
	   * @return {Number}            y coordinate of the current decision node's child
	   */
	
	  AbstractTreeRenderer.prototype.calculateChildTop = function(chainCount, top, mode) {
	    return this.calculateTop(chainCount, top, mode) + this.nodeDistance;
	  };
	
	
	  /**
	   * Add a node to the node list, so it can be drawn later.
	   * @param {Number} x
	   * @param {Number} y
	   * @param {Number} id TracePoint id
	   */
	
	  AbstractTreeRenderer.prototype.addNode = function(x, y, id) {
	    return this.nodeList.push({
	      x: x,
	      y: y,
	      id: id
	    });
	  };
	
	
	  /**
	   * Iterate the node list and draw all nodes onto the canvas.
	   */
	
	  AbstractTreeRenderer.prototype.drawAllNodes = function() {
	    var id, j, len, ref, ref1, results, x, y;
	    ref = this.nodeList;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      ref1 = ref[j], x = ref1.x, y = ref1.y, id = ref1.id;
	      results.push(this.drawNode(x, y, id));
	    }
	    return results;
	  };
	
	
	  /**
	   * Draw a single node onto the canvas.
	   * Take active state, theme and comment into consideration.
	   * @param  {Number} x
	   * @param  {Number} y
	   * @param  {Number} id TracePoint id
	   */
	
	  AbstractTreeRenderer.prototype.drawNode = function(x, y, id) {
	    var radius;
	    this.ctx.beginPath();
	    this.ctx.fillStyle = this.vgColor;
	    if (this.nodeIdHasComment(id)) {
	      this.ctx.fillStyle = this.commentColor;
	    }
	    radius = this.NODE_RADIUS;
	    if (id === this.activeNodeId) {
	      radius = 2 * radius;
	    }
	    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
	    return this.ctx.fill();
	  };
	
	
	  /**
	   * Draw an edge of the tree (a connector line) onto the canvas.
	   * Take theme into consideration.
	   * @param  {Number} x1 start coordinate
	   * @param  {Number} y1
	   * @param  {Number} x2 end coordinate
	   * @param  {Number} y2
	   */
	
	  AbstractTreeRenderer.prototype.drawEdge = function(x1, y1, x2, y2) {
	    this.ctx.beginPath();
	    this.ctx.strokeStyle = this.vgColor;
	    this.ctx.moveTo(x1, y1);
	    this.ctx.lineTo(x2, y2);
	    return this.ctx.stroke();
	  };
	
	
	  /**
	   * Draw a dashed edge, which indicates a straight chain of nodes.
	   * Take active state and theme into consideration.
	   * @param  {Number} x
	   * @param  {Number} top         start y coordinate
	   * @param  {Number} bottom      end y coordinate
	   * @param  {Boolean} emphasize  draw in bold outline when active node is in the chain
	   */
	
	  AbstractTreeRenderer.prototype.drawChainIndicator = function(x, top, bottom, emphasize) {
	    var dashLength, i, j, len, ref;
	    if (emphasize == null) {
	      emphasize = false;
	    }
	    dashLength = (bottom - top) / 7;
	    if (emphasize) {
	      this.ctx.lineWidth = 4;
	    }
	    this.ctx.beginPath();
	    this.ctx.strokeStyle = this.vgColor;
	    ref = [0, 1, 2];
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      this.ctx.moveTo(x, top + (2 * i + 1) * dashLength);
	      this.ctx.lineTo(x, top + (2 * i + 2) * dashLength);
	    }
	    this.ctx.stroke();
	    return this.ctx.lineWidth = 1;
	  };
	
	
	  /**
	   * Checks if a node is commented (RENDER_COMMENTS has to be true).
	   * @param  {Number} id TracePoint id
	   * @return {Boolean}    true if node is commented
	   */
	
	  AbstractTreeRenderer.prototype.nodeIdHasComment = function(id) {
	    return this.RENDER_COMMENTS && this.comments.hasCommentWithNodeId(id);
	  };
	
	
	  /**
	   * Traverse the tree and add a width property for each node
	   * which indicates the number of all leaves in the tree.
	   * @param  {TracePoint}   tree
	   * @return {Number}       width of the tree
	   */
	
	  AbstractTreeRenderer.prototype.recordWidths = function(tree) {
	    var child, decision, j, len, ref, width;
	    decision = this.getNextDecision(tree);
	    if (decision.isLeaf) {
	      decision.node.width = 1;
	      return 1;
	    }
	    width = 0;
	    ref = decision.node.children.slice(0, 2);
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      child.width = this.recordWidths(child);
	      width += child.width;
	    }
	    return width;
	  };
	
	
	  /**
	   * Recursively calculate the maximum depth of a TracePoint tree.
	   * @param  {TracePoint} tree
	   * @param  {Number} mode      @MODE_NORMAL or @MODE_NOCHAIN
	   * @param  {Number} count     helper count, current depth
	   * @return {Number}           depth of the tree
	   */
	
	  AbstractTreeRenderer.prototype.getMaxTreeDepth = function(tree, mode, count) {
	    var decision;
	    if (mode == null) {
	      mode = this.MODE_NORMAL;
	    }
	    if (count == null) {
	      count = 0;
	    }
	    if (!tree) {
	      return count;
	    }
	    count++;
	    decision = this.getNextDecision(tree);
	    if (mode === this.MODE_NOCHAIN) {
	      decision.chainCount = Math.min(decision.chainCount, 2);
	    }
	    count += decision.chainCount;
	    if (decision.isLeaf) {
	      return count;
	    }
	    if (decision.isBranch) {
	      return Math.max(this.getMaxTreeDepth(decision.node.children[0], mode, count), this.getMaxTreeDepth(decision.node.children[1], mode, count));
	    }
	    return this.getMaxTreeDepth(decision.node.children[0], mode, count);
	  };
	
	
	  /**
	   * Get the id of a TracePoint from a position on the canvas.
	   * @param  {Number} x
	   * @param  {Number} y
	   * @return {Number}   TracePoint id
	   */
	
	  AbstractTreeRenderer.prototype.getIdFromPos = function(x, y) {
	    var entry, j, len, ref;
	    ref = this.nodeList;
	    for (j = 0, len = ref.length; j < len; j++) {
	      entry = ref[j];
	      if (Math.abs(x - entry.x) <= this.CLICK_TRESHOLD && Math.abs(y - entry.y) <= this.CLICK_TRESHOLD) {
	        return entry.id;
	      }
	    }
	  };
	
	
	  /**
	   * Clear the background of the canvas.
	   */
	
	  AbstractTreeRenderer.prototype.clearBackground = function() {
	    return this.ctx.clearRect(0, 0, this.canvas.width(), this.canvas.height());
	  };
	
	
	  /**
	   * Apply a color theme according to the overall oxalis theme for
	   *  - comments
	   *  - nodes & edges
	   */
	
	  AbstractTreeRenderer.prototype.setupColors = function() {
	    if (app.oxalis.view.theme === Constants.THEME_BRIGHT) {
	      this.vgColor = "black";
	      return this.commentColor = "red";
	    } else {
	      this.vgColor = "white";
	      return this.commentColor = "blue";
	    }
	  };
	
	
	  /**
	   * Setter.
	   * @param  {Boolean} renderComments true, if abstract tree should show comments
	   */
	
	  AbstractTreeRenderer.prototype.renderComments = function(renderComments) {
	    return this.RENDER_COMMENTS = renderComments;
	  };
	
	
	  /**
	   * Set width and height of the canvas object.
	   * @param {Number} width
	   * @param {Number} height
	   */
	
	  AbstractTreeRenderer.prototype.setDimensions = function(width, height) {
	    this.canvas[0].width = width;
	    return this.canvas[0].height = height;
	  };
	
	  return AbstractTreeRenderer;
	
	})();
	
	module.exports = AbstractTreeRenderer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {var Backbone, ListTreeItemView, ListTreeView, Marionette, Utils, _, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	app = __webpack_require__(48);
	
	Utils = __webpack_require__(188);
	
	Marionette = __webpack_require__(49);
	
	Backbone = __webpack_require__(3);
	
	ListTreeItemView = __webpack_require__(243);
	
	ListTreeView = (function(superClass) {
	  extend(ListTreeView, superClass);
	
	  function ListTreeView() {
	    return ListTreeView.__super__.constructor.apply(this, arguments);
	  }
	
	  ListTreeView.prototype.id = "tree-navbar";
	
	  ListTreeView.prototype.className = "flex-column";
	
	  ListTreeView.prototype.template = _.template("<div>\n  <div class=\"btn-group\">\n    <button class=\"btn btn-default\" id=\"tree-create-button\"><i class=\"fa fa-plus\"></i>Create tree</button>\n    <button class=\"btn btn-default\" id=\"tree-delete-button\"><i class=\"fa fa-trash-o\"></i>Delete tree</button>\n  </div>\n  <div class=\"btn-group pull-right\">\n    <button class=\"btn btn-default\" id=\"tree-color-shuffle\" title=\"Change color\"><i class=\"fa fa-adjust\"></i>Change Color</button>\n    <button class=\"btn btn-default\" id=\"tree-color-shuffle-all\" title=\"Shuffle all Colors\"><i class=\"fa fa-random\"></i>Shuffle Colors</button>\n    <button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\" id=\"tree-sort-button\" title=\"Sort\">\n      <i class=\"fa fa-sort-alpha-asc\"></i>\n    </button>\n    <ul class=\"dropdown-menu pull-right\" id=\"tree-sort\">\n      <li>\n        <a href=\"#\" data-sort=\"name\">by name\n          <i class=\"fa fa-check\" id=\"sort-name-icon\"></i>\n        </a>\n      </li>\n      <li>\n        <a href=\"#\" data-sort=\"time\">by creation time\n          <i class=\"fa fa-check\" id= \"sort-time-icon\"></i>\n        </a>\n      </li>\n    </ul>\n  </div>\n</div>\n<div class=\"input-group\">\n  <span class=\"input-group-btn\">\n    <button class=\"btn btn-default\" id=\"tree-prev-button\"><i class=\"fa fa-arrow-left\"></i></button>\n  </span>\n  <input name=\"name\" id=\"tree-name-input\" class=\"form-control\" maxlength=\"30\" type=\"text\" autocomplete=\"off\">\n  <span class=\"input-group-btn\">\n    <button class=\"btn btn-default\" id=\"tree-next-button\"><i class=\"fa fa-arrow-right\"></i></button>\n  </span>\n</div>\n<ul id=\"tree-list\" class=\"flex-overflow\"></ul>");
	
	  ListTreeView.prototype.childView = ListTreeItemView;
	
	  ListTreeView.prototype.childViewContainer = "ul#tree-list";
	
	  ListTreeView.prototype.childViewOptions = function() {
	    return {
	      parent: this,
	      activeTreeId: this.getActiveTree().treeId
	    };
	  };
	
	  ListTreeView.prototype.events = {
	    "change #tree-name-input": "setTreeName",
	    "click #tree-prev-button": "selectPreviousTree",
	    "click #tree-next-button": "selectNextTree",
	    "click #tree-create-button": "createNewTree",
	    "click #tree-delete-button": "deleteTree",
	    "click #tree-color-shuffle": "shuffleTreeColor",
	    "click #tree-color-shuffle-all": "shuffleAllTreeColors",
	    "click a[data-sort]": "sortTrees"
	  };
	
	  ListTreeView.prototype.ui = {
	    "treeNameInput": "#tree-name-input",
	    "sortNameIcon": "#sort-name-icon",
	    "sortTimeIcon": "#sort-time-icon"
	  };
	
	  ListTreeView.prototype.initialize = function(options) {
	    this.collection = new Backbone.Collection();
	    this.listenTo(this, "render", this.updateSortIndicator);
	    this.listenTo(this, "render", this.refresh);
	    this.listenTo(this.model.skeletonTracing, "deleteTree", this.refresh);
	    this.listenTo(this.model.skeletonTracing, "mergeTree", this.refresh);
	    this.listenTo(this.model.skeletonTracing, "newTree", this.refresh);
	    this.listenTo(this.model.skeletonTracing, "newTreeName", this.updateTreeWithId);
	    this.listenTo(this.model.skeletonTracing, "reloadTrees", this.refresh);
	    this.listenTo(this.model.skeletonTracing, "deleteActiveNode", (function(_this) {
	      return function(node) {
	        return _this.updateTreeWithId(node.treeId);
	      };
	    })(this));
	    this.listenTo(this.model.skeletonTracing, "newNode", (function(_this) {
	      return function(id, treeId) {
	        return _this.updateTreeWithId(treeId);
	      };
	    })(this));
	    this.listenTo(this.model.skeletonTracing, "newTreeColor", this.updateTreeWithId);
	    this.listenTo(this.model.skeletonTracing, "newActiveTree", this.refresh);
	    return this.listenTo(this.model.skeletonTracing, "newActiveNode", this.updateName);
	  };
	
	  ListTreeView.prototype.setTreeName = function(evt) {
	    return this.model.skeletonTracing.setTreeName(evt.target.value);
	  };
	
	  ListTreeView.prototype.selectPreviousTree = function() {
	    return this.selectNextTree(false);
	  };
	
	  ListTreeView.prototype.selectNextTree = function() {
	    return this.selectNextTree(true);
	  };
	
	  ListTreeView.prototype.createNewTree = function() {
	    return this.model.skeletonTracing.createNewTree();
	  };
	
	  ListTreeView.prototype.deleteTree = function() {
	    return this.model.skeletonTracing.deleteTree(true);
	  };
	
	  ListTreeView.prototype.shuffleTreeColor = function() {
	    return this.model.skeletonTracing.shuffleTreeColor();
	  };
	
	  ListTreeView.prototype.shuffleAllTreeColors = function() {
	    return this.model.skeletonTracing.shuffleAllTreeColors();
	  };
	
	  ListTreeView.prototype.sortTrees = function(evt) {
	    evt.preventDefault();
	    this.model.user.set("sortTreesByName", $(evt.currentTarget).data("sort") === "name");
	    this.refresh();
	    return this.updateSortIndicator();
	  };
	
	  ListTreeView.prototype.updateTreeWithId = function(treeId) {
	    var $childView, tree;
	    $childView = this.$("a[data-treeid='" + treeId + "']");
	    tree = this.model.skeletonTracing.getTree(treeId);
	    $childView.children(".tree-node-count").text(tree.nodes.length);
	    $childView.children(".tree-icon").css("color", "#" + (Utils.intToHex(tree.color)));
	    return $childView.children(".tree-name").text(tree.name);
	  };
	
	  ListTreeView.prototype.updateSortIndicator = function() {
	    var isSortedByName;
	    isSortedByName = this.model.user.get("sortTreesByName");
	    this.ui.sortNameIcon.toggle(isSortedByName);
	    return this.ui.sortTimeIcon.toggle(!isSortedByName);
	  };
	
	  ListTreeView.prototype.selectNextTree = function(next) {
	    this.model.skeletonTracing.selectNextTree(next);
	    this.model.skeletonTracing.centerActiveNode();
	    return this.updateName();
	  };
	
	  ListTreeView.prototype.getActiveTree = function() {
	    return this.model.skeletonTracing.getTree();
	  };
	
	  ListTreeView.prototype.refresh = function() {
	    var trees;
	    trees = this.model.skeletonTracing.getTreesSorted();
	    this.collection.reset(trees);
	    return this.updateName();
	  };
	
	  ListTreeView.prototype.updateName = function() {
	    var name;
	    name = this.getActiveTree().name;
	    return this.ui.treeNameInput.val(name);
	  };
	
	  ListTreeView.prototype.setActiveTree = function(treeId) {
	    this.model.skeletonTracing.setActiveTree(treeId);
	    return this.model.skeletonTracing.centerActiveNode();
	  };
	
	  return ListTreeView;
	
	})(Marionette.CompositeView);
	
	module.exports = ListTreeView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var ColorConverter, ListTreeItemView, Marionette, Utils,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Marionette = __webpack_require__(49);
	
	Utils = __webpack_require__(188);
	
	ColorConverter = __webpack_require__(244);
	
	ListTreeItemView = (function(superClass) {
	  extend(ListTreeItemView, superClass);
	
	  function ListTreeItemView() {
	    return ListTreeItemView.__super__.constructor.apply(this, arguments);
	  }
	
	  ListTreeItemView.prototype.tagName = "li";
	
	  ListTreeItemView.prototype.template = _.template("<i class=\"fa <%- getIcon() %>\"></i>\n<a href=\"#\" data-treeid=\"<%- treeId %>\">\n  <span title=\"Node count\" class=\"inline-block tree-node-count\" style=\"width: 50px;\"><%- nodes.length %></span>\n  <i class=\"fa fa-circle tree-icon\" style=\"color: #<%- intToHex(color) %>\"></i>\n  <span title=\"Tree Name\" class=\"tree-name\"><%- name %></span>\n</a>");
	
	  ListTreeItemView.prototype.events = {
	    "click a": "setActive"
	  };
	
	  ListTreeItemView.prototype.templateHelpers = function() {
	    return {
	      getIcon: (function(_this) {
	        return function() {
	          if (_this.model.get("treeId") === _this.activeTreeId) {
	            return "fa-angle-right";
	          } else {
	            return "fa-bull";
	          }
	        };
	      })(this),
	      intToHex: Utils.intToHex
	    };
	  };
	
	  ListTreeItemView.prototype.initialize = function(options) {
	    this.activeTreeId = options.activeTreeId;
	    return this.parent = options.parent;
	  };
	
	  ListTreeItemView.prototype.setActive = function() {
	    var id;
	    id = this.model.get("treeId");
	    return this.parent.setActiveTree(id);
	  };
	
	  ListTreeItemView.prototype.onShow = function() {
	    if (this.model.get("treeId") === this.activeTreeId && !Utils.isElementInViewport(this.el)) {
	      return this.el.scrollIntoView();
	    }
	  };
	
	  return ListTreeItemView;
	
	})(Marionette.ItemView);
	
	module.exports = ListTreeItemView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var THREE = __webpack_require__(245);
	
	/**
	 * @author bhouston / http://exocortex.com/
	 * @author zz85 / http://github.com/zz85
	 */
	
	THREE.ColorConverter = {
	
		setHSV: function ( color, h, s, v ) {
	
			// https://gist.github.com/xpansive/1337890#file-index-js
			return color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );
	
		},
	
		getHSV: function( color ) {
	
			var hsl = color.getHSL();
	
			// based on https://gist.github.com/xpansive/1337890#file-index-js
			hsl.s *= ( hsl.l < 0.5 ) ? hsl.l : ( 1 - hsl.l );
	
			return {
				h: hsl.h,
				s: 2 * hsl.s / ( hsl.l + hsl.s ),
				v: hsl.l + hsl.s
			};
		},
	
		// where c, m, y, k is between 0 and 1
		
		setCMYK: function ( color, c, m, y, k ) {
	
			var r = ( 1 - c ) * ( 1 - k );
			var g = ( 1 - m ) * ( 1 - k );
			var b = ( 1 - y ) * ( 1 - k );
	
			return color.setRGB( r, g, b );
	
		},
	
		getCMYK: function ( color ) {
	
			var r = color.r;
			var g = color.g;
			var b = color.b;
			var k = 1 - Math.max(r, g, b);
			var c = ( 1 - r - k ) / ( 1 - k );
			var m = ( 1 - g - k ) / ( 1 - k );
			var y = ( 1 - b - k ) / ( 1 - k );
	
			return {
				c: c, m: m, y: y, k: k
			};
	
		}
	
	
	};
	
	/*** EXPORTS FROM exports-loader ***/
	module.exports = THREE.ColorConverter;


/***/ },
/* 245 */
/***/ function(module, exports) {

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Larry Battle / http://bateru.com/news
	 * @author bhouston / http://exocortex.com
	 */
	
	var THREE = { REVISION: '65' };
	
	self.console = self.console || {
	
		info: function () {},
		log: function () {},
		debug: function () {},
		warn: function () {},
		error: function () {}
	
	};
	
	String.prototype.trim = String.prototype.trim || function () {
	
		return this.replace( /^\s+|\s+$/g, '' );
	
	};
	
	// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767
	THREE.extend = function ( obj, source ) {
	
		// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/
		if ( Object.keys ) {
	
			var keys = Object.keys( source );
	
			for (var i = 0, il = keys.length; i < il; i++) {
	
				var prop = keys[i];
				Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
	
			}
	
		} else {
	
			var safeHasOwnProperty = {}.hasOwnProperty;
	
			for ( var prop in source ) {
	
				if ( safeHasOwnProperty.call( source, prop ) ) {
	
					obj[prop] = source[prop];
	
				}
	
			}
	
		}
	
		return obj;
	
	};
	
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	
	// requestAnimationFrame polyfill by Erik Möller
	// fixes from Paul Irish and Tino Zijdel
	// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.
	( function () {
	
		var lastTime = 0;
		var vendors = [ 'ms', 'moz', 'webkit', 'o' ];
	
		for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {
	
			self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
			self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];
	
		}
	
		if ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {
	
			self.requestAnimationFrame = function ( callback ) {
	
				var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
				var id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
				lastTime = currTime + timeToCall;
				return id;
	
			};
	
		}
	
		if( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {
	
			self.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };
	
		}
	
	}() );
	
	// GL STATE CONSTANTS
	
	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;
	
	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;
	
	// SHADOWING TYPES
	
	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;
	
	// MATERIAL CONSTANTS
	
	// side
	
	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;
	
	// shading
	
	THREE.NoShading = 0;
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;
	
	// colors
	
	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;
	
	// blending modes
	
	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;
	
	// custom blending equations
	// (numbers start from 100 not to clash with other
	//  mappings to OpenGL constants defined in Texture.js)
	
	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	
	// custom blending destination factors
	
	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;
	
	// custom blending source factors
	
	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;
	
	
	// TEXTURE CONSTANTS
	
	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;
	
	// Mapping modes
	
	THREE.UVMapping = function () {};
	
	THREE.CubeReflectionMapping = function () {};
	THREE.CubeRefractionMapping = function () {};
	
	THREE.SphericalReflectionMapping = function () {};
	THREE.SphericalRefractionMapping = function () {};
	
	// Wrapping modes
	
	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;
	
	// Filters
	
	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;
	
	// Data types
	
	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	
	// Pixel types
	
	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;
	
	// Pixel formats
	
	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	
	// Compressed texture formats
	
	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;
	
	/*
	// Potential future PVRTC compressed texture formats
	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
	*/
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( value ) {
	
		if ( value !== undefined ) this.set( value );
	
		return this;
	
	};
	
	THREE.Color.prototype = {
	
		constructor: THREE.Color,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value instanceof THREE.Color ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function ( h, s, l ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			if ( s === 0 ) {
	
				this.r = this.g = this.b = l;
	
			} else {
	
				var hue2rgb = function ( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				};
	
				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;
	
				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );
	
			}
	
			return this;
	
		},
	
		setStyle: function ( style ) {
	
			// rgb(255,0,0)
	
			if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {
	
				var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );
	
				this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
				this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
				this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
				return this;
	
			}
	
			// rgb(100%,0%,0%)
	
			if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {
	
				var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );
	
				this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
				this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
				this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
				return this;
	
			}
	
			// #ff0000
	
			if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {
	
				var color = /^\#([0-9a-f]{6})$/i.exec( style );
	
				this.setHex( parseInt( color[ 1 ], 16 ) );
	
				return this;
	
			}
	
			// #f00
	
			if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {
	
				var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );
	
				this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );
	
				return this;
	
			}
	
			// red
	
			if ( /^(\w+)$/i.test( style ) ) {
	
				this.setHex( THREE.ColorKeywords[ style ] );
	
				return this;
	
			}
	
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color ) {
	
			this.r = color.r * color.r;
			this.g = color.g * color.g;
			this.b = color.b * color.b;
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color ) {
	
			this.r = Math.sqrt( color.r );
			this.g = Math.sqrt( color.g );
			this.b = Math.sqrt( color.b );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( optionalTarget ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;
	
			return hsl;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array ) {
	
			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this.r, this.g, this.b ];
	
		},
	
		clone: function () {
	
			return new THREE.Color().setRGB( this.r, this.g, this.b );
	
		}
	
	};
	
	THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
	"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
	"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
	"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
	"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
	"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
	"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
	"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
	"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
	"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
	"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
	"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
	"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
	"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
	"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
	"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
	"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
	"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
	"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
	"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
	"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
	"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
	"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
	"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		_x: 0,_y: 0, _z: 0, _w: 0,
	
		_euler: undefined,
	
		_updateEuler: function ( callback ) {
	
			if ( this._euler !== undefined ) {
	
				this._euler.setFromQuaternion( this, undefined, false );
	
			}
	
		},
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this._updateEuler();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this._updateEuler();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this._updateEuler();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this._updateEuler();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this._updateEuler();
	
			return this;
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion._x;
			this._y = quaternion._y;
			this._z = quaternion._z;
			this._w = quaternion._w;
	
			this._updateEuler();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			if ( euler.order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( euler.order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( euler.order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this._updateEuler();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// axis have to be normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this._updateEuler();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = (m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21 ) / s;
				this._z = (m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = (m13 - m31 ) / s;
				this._x = (m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this._updateEuler();
	
			return this;
	
		},
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;
	
			this._updateEuler();
	
			return this;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this._updateEuler();
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		},
	
		slerp: function ( qb, t ) {
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
	
				cosHalfTheta = -cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this._updateEuler();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			this._w = array[ 3 ];
	
			this._updateEuler();
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this._x, this._y, this._z, this._w ];
	
		},
	
		clone: function () {
	
			return new THREE.Quaternion( this._x, this._y, this._z, this._w );
	
		}
	
	};
	
	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {
	
		return qm.copy( qa ).slerp( qb, t );
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.x *= s;
			this.y *= s;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			return this;
	
		},
	
		negate: function() {
	
			return this.multiplyScalar( - 1 );
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		equals: function( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array ) {
	
			this.x = array[ 0 ];
			this.y = array[ 1 ];
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this.x, this.y ];
	
		},
	
		clone: function () {
	
			return new THREE.Vector2( this.x, this.y );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
			this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide
	
			this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
			this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
			this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	
			return this;
	
		},
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[4] * y + e[8]  * z;
			this.y = e[1] * x + e[5] * y + e[9]  * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			return this;
	
		},
	
		negate: function () {
	
			return this.multiplyScalar( - 1 );
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength  ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( this.length() * v.length() );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		setEulerFromRotationMatrix: function ( m, order ) {
	
			console.error( "REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");
	
		},
	
		setEulerFromQuaternion: function ( q, order ) {
	
			console.error( "REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");
	
		},
	
		getPositionFromMatrix: function ( m ) {
	
			console.warn( "DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code." );
	
			return this.setFromMatrixPosition( m );
	
		},
	
		getScaleFromMatrix: function ( m ) {
	
			console.warn( "DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code." );
	
			return this.setFromMatrixScale( m );
		},
	
		getColumnFromMatrix: function ( index, matrix ) {
	
			console.warn( "DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code." );
	
			return this.setFromMatrixColumn( index, matrix );
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
		},
	
		setFromMatrixColumn: function ( index, matrix ) {
	
			var offset = index * 4;
	
			var me = matrix.elements;
	
			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array ) {
	
			this.x = array[ 0 ];
			this.y = array[ 1 ];
			this.z = array[ 2 ];
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this.x, this.y, this.z ];
	
		},
	
		clone: function () {
	
			return new THREE.Vector3( this.x, this.y, this.z );
	
		}
	
	};
	
	THREE.extend( THREE.Vector3.prototype, {
	
		applyEuler: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					console.error( 'ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );
	
				}
	
				this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				return this;
	
			};
	
		}(),
	
		projectOnVector: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( vector ) {
	
				v1.copy( vector ).normalize();
				var d = this.dot( v1 );
				return this.copy( v1 ).multiplyScalar( d );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( planeNormal ) {
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( vector ) {
	
			    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );
	
			    return this.subVectors( v1, this );
	
			}
	
		}()
	
	} );
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Vector4.prototype = {
	
		constructor: THREE.Vector4,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon )
			  && ( Math.abs( m13 - m31 ) < epsilon )
			  && ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				  && ( Math.abs( m13 + m31 ) < epsilon2 )
				  && ( Math.abs( m23 + m32 ) < epsilon2 )
				  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) { // m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else { // m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							 + ( m13 - m31 ) * ( m13 - m31 )
							 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			if ( this.w > v.w ) {
	
				this.w = v.w;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			if ( this.w < v.w ) {
	
				this.w = v.w;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			if ( this.w < min.w ) {
	
				this.w = min.w;
	
			} else if ( this.w > max.w ) {
	
				this.w = max.w;
	
			}
	
			return this;
	
		},
	
		negate: function() {
	
			return this.multiplyScalar( -1 );
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
	
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array ) {
	
			this.x = array[ 0 ];
			this.y = array[ 1 ];
			this.z = array[ 2 ];
			this.w = array[ 3 ];
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this.x, this.y, this.z, this.w ];
	
		},
	
		clone: function () {
	
			return new THREE.Vector4( this.x, this.y, this.z, this.w );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,
	
		_quaternion: undefined,
	
		_updateQuaternion: function () {
	
			if ( this._quaternion !== undefined ) {
	
				this._quaternion.setFromEuler( this, false );
	
			}
	
		},
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this._updateQuaternion();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this._updateQuaternion();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this._updateQuaternion();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this._updateQuaternion();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this._updateQuaternion();
	
			return this;
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this._updateQuaternion();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			// clamp, to handle numerical problems
	
			function clamp( x ) {
	
				return Math.min( Math.max( x, -1 ), 1 );
	
			}
	
			var te = m.elements;
			var m11 = te[0], m12 = te[4], m13 = te[8];
			var m21 = te[1], m22 = te[5], m23 = te[9];
			var m31 = te[2], m32 = te[6], m33 = te[10];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			this._updateQuaternion();
	
			return this;
	
		},
	
		setFromQuaternion: function ( q, order, update ) {
	
			// q is assumed to be normalized
	
			// clamp, to handle numerical problems
	
			function clamp( x ) {
	
				return Math.min( Math.max( x, -1 ), 1 );
	
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
	
			var sqx = q.x * q.x;
			var sqy = q.y * q.y;
			var sqz = q.z * q.z;
			var sqw = q.w * q.w;
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
				this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
				this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );
	
			} else if ( order ===  'YXZ' ) {
	
				this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
				this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
				this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
				this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
				this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );
	
			} else if ( order === 'ZYX' ) {
	
				this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
				this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
				this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );
	
			} else if ( order === 'YZX' ) {
	
				this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
				this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
				this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );
	
			} else if ( order === 'XZY' ) {
	
				this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
				this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
				this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );
	
			} else {
	
				console.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			if ( update !== false ) this._updateQuaternion();
	
			return this;
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function ( newOrder ) {
	
				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );
	
			};
	
	
		}(),
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this._updateQuaternion();
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this._x, this._y, this._z, this._order ];
	
		},
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		clone: function () {
	
			return new THREE.Euler( this._x, this._y, this._z, this._order );
	
		}
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Line3 = function ( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();
	
	};
	
	THREE.Line3.prototype = {
	
		constructor: THREE.Line3,
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function() {
	
			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();
	
			return function ( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = THREE.Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		},
	
		clone: function () {
	
			return new THREE.Line3().copy( this );
	
		}
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );
	
	};
	
	THREE.Box2.prototype = {
	
		constructor: THREE.Box2,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			if ( points.length > 0 ) {
	
				var point = points[ 0 ];
	
				this.min.copy( point );
				this.max.copy( point );
	
				for ( var i = 1, il = points.length; i < il; i ++ ) {
	
					point = points[ i ];
	
					if ( point.x < this.min.x ) {
	
						this.min.x = point.x;
	
					} else if ( point.x > this.max.x ) {
	
						this.max.x = point.x;
	
					}
	
					if ( point.y < this.min.y ) {
	
						this.min.y = point.y;
	
					} else if ( point.y > this.max.y ) {
	
						this.max.y = point.y;
	
					}
	
				}
	
			} else {
	
				this.makeEmpty();
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = -Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( -scalar );
			this.max.addScalar( scalar );
	
			return this;
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector2();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		},
	
		clone: function () {
	
			return new THREE.Box2().copy( this );
	
		}
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );
	
	};
	
	THREE.Box3.prototype = {
	
		constructor: THREE.Box3,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		addPoint: function ( point ) {
	
			if ( point.x < this.min.x ) {
	
				this.min.x = point.x;
	
			} else if ( point.x > this.max.x ) {
	
				this.max.x = point.x;
	
			}
	
			if ( point.y < this.min.y ) {
	
				this.min.y = point.y;
	
			} else if ( point.y > this.max.y ) {
	
				this.max.y = point.y;
	
			}
	
			if ( point.z < this.min.z ) {
	
				this.min.z = point.z;
	
			} else if ( point.z > this.max.z ) {
	
				this.max.z = point.z;
	
			}
	
		},
	
		setFromPoints: function ( points ) {
	
			if ( points.length > 0 ) {
	
				var point = points[ 0 ];
	
				this.min.copy( point );
				this.max.copy( point );
	
				for ( var i = 1, il = points.length; i < il; i ++ ) {
	
					this.addPoint( points[ i ] )
	
				}
	
			} else {
	
				this.makeEmpty();
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function() {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and childrens', world transforms
	
			var v1 = new THREE.Vector3();
	
			return function( object ) {
	
				var scope = this;
	
				object.updateMatrixWorld( true );
	
				this.makeEmpty();
	
				object.traverse( function ( node ) {
	
					if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {
	
						var vertices = node.geometry.vertices;
	
						for ( var i = 0, il = vertices.length; i < il; i++ ) {
	
							v1.copy( vertices[ i ] );
	
							v1.applyMatrix4( node.matrixWorld );
	
							scope.expandByPoint( v1 );
	
						}
	
					}
	
				} );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( -scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function() {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];
	
			return function ( matrix ) {
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111
	
				this.makeEmpty();
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		},
	
		clone: function () {
	
			return new THREE.Box3().copy( this );
	
		}
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
		this.elements = new Float32Array(9);
	
		this.set(
	
			( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
			n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
			n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1
	
		);
	};
	
	THREE.Matrix3.prototype = {
	
		constructor: THREE.Matrix3,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[0] = n11; te[3] = n12; te[6] = n13;
			te[1] = n21; te[4] = n22; te[7] = n23;
			te[2] = n31; te[5] = n32; te[8] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[0], me[3], me[6],
				me[1], me[4], me[7],
				me[2], me[5], me[8]
	
			);
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
	
		},
	
		multiplyVector3Array: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( a ) {
	
				for ( var i = 0, il = a.length; i < il; i += 3 ) {
	
					v1.x = a[ i ];
					v1.y = a[ i + 1 ];
					v1.z = a[ i + 2 ];
	
					v1.applyMatrix3(this);
	
					a[ i ]     = v1.x;
					a[ i + 1 ] = v1.y;
					a[ i + 2 ] = v1.z;
	
				}
	
				return a;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[0] *= s; te[3] *= s; te[6] *= s;
			te[1] *= s; te[4] *= s; te[7] *= s;
			te[2] *= s; te[5] *= s; te[8] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[0], b = te[1], c = te[2],
				d = te[3], e = te[4], f = te[5],
				g = te[6], h = te[7], i = te[8];
	
			return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;
	
		},
	
		getInverse: function ( matrix, throwOnInvertible ) {
	
			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )
	
			var me = matrix.elements;
			var te = this.elements;
	
			te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
			te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
			te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
			te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
			te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
			te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
			te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
			te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
			te[ 8 ] =   me[5] * me[0] - me[1] * me[4];
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];
	
			// no inverse
	
			if ( det === 0 ) {
	
				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1.0 / det );
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[1]; m[1] = m[3]; m[3] = tmp;
			tmp = m[2]; m[2] = m[6]; m[6] = tmp;
			tmp = m[5]; m[5] = m[7]; m[7] = tmp;
	
			return this;
	
		},
	
		getNormalMatrix: function ( m ) {
	
			// input: THREE.Matrix4
	
			this.getInverse( m ).transpose();
	
			return this;
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];
	
		},
	
		clone: function () {
	
			var te = this.elements;
	
			return new THREE.Matrix3(
	
				te[0], te[3], te[6],
				te[1], te[4], te[7],
				te[2], te[5], te[8]
	
			);
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	
	THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
		this.elements = new Float32Array( 16 );
	
		// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
		//   we should not support semi specification of Matrix4, it is just weird.
	
		var te = this.elements;
	
		te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
		te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
		te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
		te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;
	
	};
	
	THREE.Matrix4.prototype = {
	
		constructor: THREE.Matrix4,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
			te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
			te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
			te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		copy: function ( m ) {
	
			this.elements.set( m.elements );
	
			return this;
	
		},
	
		extractPosition: function ( m ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
				var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
				var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();
	
				te[0] = me[0] * scaleX;
				te[1] = me[1] * scaleX;
				te[2] = me[2] * scaleX;
	
				te[4] = me[4] * scaleY;
				te[5] = me[5] * scaleY;
				te[6] = me[6] * scaleY;
	
				te[8] = me[8] * scaleZ;
				te[9] = me[9] * scaleZ;
				te[10] = me[10] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				console.error( 'ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[0] = c * e;
				te[4] = - c * f;
				te[8] = d;
	
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = - b * c;
	
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
	
				te[1] = a * f;
				te[5] = a * e;
				te[9] = - b;
	
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[0] = ce - df * b;
				te[4] = - a * f;
				te[8] = de + cf * b;
	
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
	
				te[2] = - a * d;
				te[6] = b;
				te[10] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
	
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
	
				te[2] = - d;
				te[6] = b * c;
				te[10] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
	
				te[1] = f;
				te[5] = a * e;
				te[9] = - b * e;
	
				te[2] = - d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[0] = c * e;
				te[4] = - f;
				te[8] = d * e;
	
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
	
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
	
			}
	
			// last column
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
	
			// bottom row
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
	
			return this;
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );
	
			return this.makeRotationFromQuaternion( q );
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[0] = 1 - ( yy + zz );
			te[4] = xy - wz;
			te[8] = xz + wy;
	
			te[1] = xy + wz;
			te[5] = 1 - ( xx + zz );
			te[9] = yz - wx;
	
			te[2] = xz - wy;
			te[6] = yz + wx;
			te[10] = 1 - ( xx + yy );
	
			// last column
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
	
			// bottom row
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
	
			return this;
	
		},
	
		lookAt: function() {
	
			var x = new THREE.Vector3();
			var y = new THREE.Vector3();
			var z = new THREE.Vector3();
	
			return function ( eye, target, up ) {
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.length() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.length() === 0 ) {
	
					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[0] = x.x; te[4] = y.x; te[8] = z.x;
				te[1] = x.y; te[5] = y.y; te[9] = z.y;
				te[2] = x.z; te[6] = y.z; te[10] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
			var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
			var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
			var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
	
			var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
			var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
			var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
			var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
	
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
			r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
			r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
			r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
			te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
			te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
			te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );
	
		},
	
		multiplyVector4: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		multiplyVector3Array: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( a ) {
	
				for ( var i = 0, il = a.length; i < il; i += 3 ) {
	
					v1.x = a[ i ];
					v1.y = a[ i + 1 ];
					v1.z = a[ i + 2 ];
	
					v1.applyProjection( this );
	
					a[ i ]     = v1.x;
					a[ i + 1 ] = v1.y;
					a[ i + 2 ] = v1.z;
	
				}
	
				return a;
	
			};
	
		}(),
	
		rotateAxis: function ( v ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	
			v.transformDirection( this );
	
		},
	
		crossVector: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
			var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
			var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
			var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+n14 * n23 * n32
					-n13 * n24 * n32
					-n14 * n22 * n33
					+n12 * n24 * n33
					+n13 * n22 * n34
					-n12 * n23 * n34
				) +
				n42 * (
					+n11 * n23 * n34
					-n11 * n24 * n33
					+n14 * n21 * n33
					-n13 * n21 * n34
					+n13 * n24 * n31
					-n14 * n23 * n31
				) +
				n43 * (
					+n11 * n24 * n32
					-n11 * n22 * n34
					-n14 * n21 * n32
					+n12 * n21 * n34
					+n14 * n22 * n31
					-n12 * n24 * n31
				) +
				n44 * (
					-n13 * n22 * n31
					-n11 * n23 * n32
					+n11 * n22 * n33
					+n13 * n21 * n32
					-n12 * n21 * n33
					+n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[1]; te[1] = te[4]; te[4] = tmp;
			tmp = te[2]; te[2] = te[8]; te[8] = tmp;
			tmp = te[6]; te[6] = te[9]; te[9] = tmp;
	
			tmp = te[3]; te[3] = te[12]; te[12] = tmp;
			tmp = te[7]; te[7] = te[13]; te[13] = tmp;
			tmp = te[11]; te[11] = te[14]; te[14] = tmp;
	
			return this;
	
		},
	
		flattenToArray: function ( flat ) {
	
			var te = this.elements;
			flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
			flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
			flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
			flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];
	
			return flat;
	
		},
	
		flattenToArrayOffset: function( flat, offset ) {
	
			var te = this.elements;
			flat[ offset ] = te[0];
			flat[ offset + 1 ] = te[1];
			flat[ offset + 2 ] = te[2];
			flat[ offset + 3 ] = te[3];
	
			flat[ offset + 4 ] = te[4];
			flat[ offset + 5 ] = te[5];
			flat[ offset + 6 ] = te[6];
			flat[ offset + 7 ] = te[7];
	
			flat[ offset + 8 ]  = te[8];
			flat[ offset + 9 ]  = te[9];
			flat[ offset + 10 ] = te[10];
			flat[ offset + 11 ] = te[11];
	
			flat[ offset + 12 ] = te[12];
			flat[ offset + 13 ] = te[13];
			flat[ offset + 14 ] = te[14];
			flat[ offset + 15 ] = te[15];
	
			return flat;
	
		},
	
		getPosition: function() {
	
			var v1 = new THREE.Vector3();
	
			return function () {
	
				console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
				var te = this.elements;
				return v1.set( te[12], te[13], te[14] );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[12] = v.x;
			te[13] = v.y;
			te[14] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnInvertible ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;
	
			var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
			var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
			var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
			var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];
	
			te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
			te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
			te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
			te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
			te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
			te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
			te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
			te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
			te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
			te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
			te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
			te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
			te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
			te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
			te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
			te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;
	
			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];
	
			if ( det == 0 ) {
	
				var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg ); 
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
			}
	
			this.multiplyScalar( 1 / det );
	
			return this;
	
		},
	
		translate: function ( v ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .translate() has been removed.');
	
		},
	
		rotateX: function ( angle ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .rotateX() has been removed.');
	
		},
	
		rotateY: function ( angle ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .rotateY() has been removed.');
	
		},
	
		rotateZ: function ( angle ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .rotateZ() has been removed.');
	
		},
	
		rotateByAxis: function ( axis, angle ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[0] *= x; te[4] *= y; te[8] *= z;
			te[1] *= x; te[5] *= y; te[9] *= z;
			te[2] *= x; te[6] *= y; te[10] *= z;
			te[3] *= x; te[7] *= y; te[11] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	
			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, -s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				-s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, -s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector = new THREE.Vector3();
			var matrix = new THREE.Matrix4();
	
			return function ( position, quaternion, scale ) {
	
				var te = this.elements;
	
				var sx = vector.set( te[0], te[1], te[2] ).length();
				var sy = vector.set( te[4], te[5], te[6] ).length();
				var sz = vector.set( te[8], te[9], te[10] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if( det < 0 ) {
					sx = -sx;
				}
	
				position.x = te[12];
				position.y = te[13];
				position.z = te[14];
	
				// scale the rotation part
	
				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[0] *= invSX;
				matrix.elements[1] *= invSX;
				matrix.elements[2] *= invSX;
	
				matrix.elements[4] *= invSY;
				matrix.elements[5] *= invSY;
				matrix.elements[6] *= invSY;
	
				matrix.elements[8] *= invSZ;
				matrix.elements[9] *= invSZ;
				matrix.elements[10] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
			te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
			te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
			te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;
	
			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;
	
			te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
			te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
			te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
			te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];
	
		},
	
		clone: function () {
	
			var te = this.elements;
	
			return new THREE.Matrix4(
	
				te[0], te[4], te[8], te[12],
				te[1], te[5], te[9], te[13],
				te[2], te[6], te[10], te[14],
				te[3], te[7], te[11], te[15]
	
			);
	
		}
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.Ray.prototype = {
	
		constructor: THREE.Ray,
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		recast: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return result.copy( this.origin );
	
			}
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceTo( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceTo( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
	
			var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
			var segDir = v1.clone().sub( v0 ).normalize();
			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var diff = this.origin.clone().sub( segCenter );
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;
	
			if ( det >= 0 ) {
	
				// The ray and segment are not parallel.
	
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;
	
				if ( s0 >= 0 ) {
	
					if ( s1 >= - extDet ) {
	
						if ( s1 <= extDet ) {
	
							// region 0
							// Minimum at interior points of ray and segment.
	
							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 1
	
							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						// region 5
	
						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					}
	
				} else {
	
					if ( s1 <= - extDet) {
	
						// region 4
	
						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					} else if ( s1 <= extDet ) {
	
						// region 3
	
						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
					} else {
	
						// region 2
	
						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					}
	
				}
	
			} else {
	
				// Ray and segment are parallel.
	
				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
			}
	
			if ( optionalPointOnRay ) {
	
				optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );
	
			}
	
			if ( optionalPointOnSegment ) {
	
				optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );
	
			}
	
			return sqrDist;
	
		},
	
		isIntersectionSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
		},
	
		isIntersectionPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
			if ( denominator == 0 ) {
	
				// line is coplanar, return origin
				if( plane.distanceToPoint( this.origin ) == 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t :  null;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
			}
	
			return this.at( t, optionalTarget );
	
		},
	
		isIntersectionBox: function () {
			
			var v = new THREE.Vector3();
	
			return function ( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			}
	
		}(),
	
		intersectBox: function ( box , optionalTarget ) {
	
			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/
	
			var tmin,tmax,tymin,tymax,tzmin,tzmax;
	
			var invdirx = 1/this.direction.x,
				invdiry = 1/this.direction.y,
				invdirz = 1/this.direction.z;
	
			var origin = this.origin;
	
			if (invdirx >= 0) {
					
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
	
			} else { 
	
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}			
	
			if (invdiry >= 0) {
			
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
	
			} else {
	
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}
	
			if ((tmin > tymax) || (tymin > tmax)) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
			
			if (tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if (tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if (invdirz >= 0) {
			
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
	
			} else {
	
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}
	
			if ((tmin > tzmax) || (tzmin > tmax)) return null;
	
			if (tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if (tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
		},
	
		intersectTriangle: function() {
	
			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();
	
			return function ( a, b, c, backfaceCulling, optionalTarget ) {
	
				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );
		
			}
		
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();
	
			return this;
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		},
	
		clone: function () {
	
			return new THREE.Ray().copy( this );
	
		}
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.Sphere.prototype = {
	
		constructor: THREE.Sphere,
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
		},
	
	
		setFromPoints: function () {
	
			var box = new THREE.Box3();
	
			return function ( points, optionalCenter )  {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).center( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;			
	 		
	 		};
	
		}(),
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		},
	
		clone: function () {
	
			return new THREE.Sphere().copy( this );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.Frustum.prototype = {
	
		constructor: THREE.Frustum,
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[0].copy( p0 );
			planes[1].copy( p1 );
			planes[2].copy( p2 );
			planes[3].copy( p3 );
			planes[4].copy( p4 );
			planes[5].copy( p5 );
	
			return this;
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for( var i = 0; i < 6; i ++ ) {
	
				planes[i].copy( frustum.planes[i] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
			var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
			var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
			var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new THREE.Sphere();
	
			return function ( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = -sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox : function() {
	
			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();
	
			return function( box ) {
	
				var planes = this.planes;
				
				for ( var i = 0; i < 6 ; i ++ ) {
				
					var plane = planes[i];
					
					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );
					
					// if both outside plane, no intersection
	
					if ( d1 < 0 && d2 < 0 ) {
						
						return false;
			
					}
				}
	
				return true;
			};
	
		}(),
	
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		clone: function () {
	
			return new THREE.Frustum().copy( this );
	
		}
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.Plane.prototype = {
	
		constructor: THREE.Plane,
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function() {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= -1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		isIntersectionLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectLine: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator == 0 ) {
	
					// line is coplanar, return origin
					if( this.distanceToPoint( line.start ) == 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function() {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();
	
			return function ( matrix, optionalNormalMatrix ) {
	
				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
				
				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );
	
				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );
	
		},
	
		clone: function () {
	
			return new THREE.Plane().copy( this );
	
		}
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		PI2: Math.PI * 2,
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
			
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
			var uuid = new Array(36);
			var rnd = 0, r;
	
			return function () {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i == 8 || i == 13 || i == 18 || i == 23 ) {
				
						uuid[ i ] = '-';
				
					} else if ( i == 14 ) {
				
						uuid[ i ] = '4';
				
					} else {
				
						if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	
					}
				}
				
				return uuid.join('');
	
			};
	
		}(),
	
		// Clamp value to range <a, b>
	
		clamp: function ( x, a, b ) {
	
			return ( x < a ) ? a : ( ( x > b ) ? b : x );
	
		},
	
		// Clamp value to range <a, inf)
	
		clampBottom: function ( x, a ) {
	
			return x < a ? a : x;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min )/( max - min );
	
			return x*x*(3 - 2*x);
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min )/( max - min );
	
			return x*x*x*(x*(x*6 - 15) + 10);
	
		},
	
		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)
	
		random16: function () {
	
			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		sign: function ( x ) {
	
			return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );
	
		},
	
		degToRad: function() {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function() {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}()
	
	};
	
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( !nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint != oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				linearDistance, realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		};
	
	};
	
	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function() {
	
		var v0 = new THREE.Vector3();
	
		return function ( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycoordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function() {
	
		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// colinear or singular triangle
			if( denom == 0 ) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( -2, -1, -1 );
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycoordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function() {
	
		var v1 = new THREE.Vector3();
	
		return function ( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.Triangle.prototype = {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[i0] );
			this.b.copy( points[i1] );
			this.c.copy( points[i2] );
	
			return this;
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function() {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function () {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		},
	
		clone: function () {
	
			return new THREE.Triangle().copy( this );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Vertex = function ( v ) {
	
		console.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')
		return v;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.UV = function ( u, v ) {
	
		console.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
		return new THREE.Vector2( u, v );
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.Clock.prototype = {
	
		constructor: THREE.Clock,
	
		start: function () {
	
			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						? self.performance.now()
						: Date.now();
	
			this.oldTime = this.startTime;
			this.running = true;
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = self.performance !== undefined && self.performance.now !== undefined
						? self.performance.now()
						: Date.now();
	
				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	};
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {}
	
	THREE.EventDispatcher.prototype = {
	
		constructor: THREE.EventDispatcher,
	
		apply: function ( object ) {
	
			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
	
		},
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function () {
	
			var array = [];
	
			return function ( event ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];
	
				if ( listenerArray !== undefined ) {
	
					event.target = this;
	
					var length = listenerArray.length;
	
					for ( var i = 0; i < length; i ++ ) {
	
						array[ i ] = listenerArray[ i ];
	
					}
	
					for ( var i = 0; i < length; i ++ ) {
	
						array[ i ].call( this, event );
	
					}
	
				}
	
			};
	
		}()
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
		};
	
		var sphere = new THREE.Sphere();
		var localRay = new THREE.Ray();
		var facePlane = new THREE.Plane();
		var intersectPoint = new THREE.Vector3();
		var matrixPosition = new THREE.Vector3();
	
		var inverseMatrix = new THREE.Matrix4();
	
		var descSort = function ( a, b ) {
	
			return a.distance - b.distance;
	
		};
	
		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();
	
		var intersectObject = function ( object, raycaster, intersects ) {
	
			if ( object instanceof THREE.Sprite ) {
	
				matrixPosition.setFromMatrixPosition( object.matrixWorld );
				var distance = raycaster.ray.distanceToPoint( matrixPosition );
	
				if ( distance > object.scale.x ) {
	
					return intersects;
	
				}
	
				intersects.push( {
	
					distance: distance,
					point: object.position,
					face: null,
					object: object
	
				} );
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				// ATTENTION! This entire section (else if block) has been
				// added by Georg
	
				var geometry = object.geometry;
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					var positionArray = geometry.attributes.position.array;
					var numVertices   = geometry.attributes.position.numItems;
					var tempVector    = new THREE.Vector3(0, 0, 0)
	
					for (var i = 0; i < numVertices; i++) {
	
						var pos = [positionArray[3 * i], positionArray[3 * i + 1],
							positionArray[3 * i + 2]];
						if(raycaster.ray.__scalingFactors !== undefined){
							// Apply scaling of entire group
							// (voxel --> nm)
							pos[0] *= raycaster.ray.__scalingFactors[0];
							pos[1] *= raycaster.ray.__scalingFactors[1];
							pos[2] *= raycaster.ray.__scalingFactors[2];
						}
	
						tempVector.set( pos[0], pos[1], pos[2] );
	
						var distance = raycaster.ray.distanceToPoint( tempVector );
	
						if(distance < raycaster.ray.threshold){
							intersects.push( {
	
								distance: distance,
								point: tempVector,
								face: null,
								object: object,
								index: i
	
							} );
						}
					}
				}
	
			} else if ( object instanceof THREE.LOD ) {
	
				matrixPosition.setFromMatrixPosition( object.matrixWorld );
				var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
				intersectObject( object.getObjectForDistance( distance ), raycaster, intersects );
	
			} else if ( object instanceof THREE.Mesh ) {
	
				var geometry = object.geometry;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
	
				if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {
	
					return intersects;
	
				}
	
				// Check boundingBox before continuing
				
				inverseMatrix.getInverse( object.matrixWorld );  
				localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				if ( geometry.boundingBox !== null ) {
	
					if ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {
	
						return intersects;
	
					}
	
				} 
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					var material = object.material;
	
					if ( material === undefined ) return intersects;
					if ( geometry.dynamic === false ) return intersects;
	
					var a, b, c;
					var precision = raycaster.precision;
	
					if ( geometry.attributes.index !== undefined ) {
	
						var offsets = geometry.offsets;
						var indices = geometry.attributes.index.array;
						var positions = geometry.attributes.position.array;
						var offLength = geometry.offsets.length;
	
						var fl = geometry.attributes.index.array.length / 3;
	
						for ( var oi = 0; oi < offLength; ++oi ) {
	
							var start = offsets[ oi ].start;
							var count = offsets[ oi ].count;
							var index = offsets[ oi ].index;
	
							for ( var i = start, il = start + count; i < il; i += 3 ) {
	
								a = index + indices[ i ];
								b = index + indices[ i + 1 ]; 
								c = index + indices[ i + 2 ];
	
								vA.set(
									positions[ a * 3 ],
									positions[ a * 3 + 1 ],
									positions[ a * 3 + 2 ]
								);
								vB.set(
									positions[ b * 3 ],
									positions[ b * 3 + 1 ],
									positions[ b * 3 + 2 ]
								);
								vC.set(
									positions[ c * 3 ],
									positions[ c * 3 + 1 ],
									positions[ c * 3 + 2 ]
								);
	
								
								if ( material.side === THREE.BackSide ) {
								
									var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); 
	
								} else {
	
									var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );
	
								}
	
								if ( intersectionPoint === null ) continue;
	
								intersectionPoint.applyMatrix4( object.matrixWorld );
	
								var distance = raycaster.ray.origin.distanceTo( intersectionPoint );
	
								if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									point: intersectionPoint,
									face: null,
									faceIndex: null,
									object: object
	
								} );
	
							}
	
						}
	
					} else {
	
						var offsets = geometry.offsets;
						var positions = geometry.attributes.position.array;
						var offLength = geometry.offsets.length;
	
						var fl = geometry.attributes.position.array.length;
	
						for ( var i = 0; i < fl; i += 3 ) {
	
							a = i;
							b = i + 1;
							c = i + 2;
	
							vA.set(
								positions[ a * 3 ],
								positions[ a * 3 + 1 ],
								positions[ a * 3 + 2 ]
							);
							vB.set(
								positions[ b * 3 ],
								positions[ b * 3 + 1 ],
								positions[ b * 3 + 2 ]
							);
							vC.set(
								positions[ c * 3 ],
								positions[ c * 3 + 1 ],
								positions[ c * 3 + 2 ]
							);
	
							
							if ( material.side === THREE.BackSide ) {
								
								var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); 
	
							} else {
	
								var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );
	
							}
	
							if ( intersectionPoint === null ) continue;
	
							intersectionPoint.applyMatrix4( object.matrixWorld );
	
							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );
	
							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								point: intersectionPoint,
								face: null,
								faceIndex: null,
								object: object
	
							} );
	
						}
	
					}
	
				} else if ( geometry instanceof THREE.Geometry ) {
	
					var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
					var objectMaterials = isFaceMaterial === true ? object.material.materials : null;
	
					var a, b, c, d;
					var precision = raycaster.precision;
	
					var vertices = geometry.vertices;
	
					for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {
	
						var face = geometry.faces[ f ];
	
						var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;
	
						if ( material === undefined ) continue;
	
						a = vertices[ face.a ];
						b = vertices[ face.b ];
						c = vertices[ face.c ];
	
						if ( material.morphTargets === true ) {
	
							var morphTargets = geometry.morphTargets;
							var morphInfluences = object.morphTargetInfluences;
	
							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );
	
							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
								var influence = morphInfluences[ t ];
	
								if ( influence === 0 ) continue;
	
								var targets = morphTargets[ t ].vertices;
	
								vA.x += ( targets[ face.a ].x - a.x ) * influence;
								vA.y += ( targets[ face.a ].y - a.y ) * influence;
								vA.z += ( targets[ face.a ].z - a.z ) * influence;
	
								vB.x += ( targets[ face.b ].x - b.x ) * influence;
								vB.y += ( targets[ face.b ].y - b.y ) * influence;
								vB.z += ( targets[ face.b ].z - b.z ) * influence;
	
								vC.x += ( targets[ face.c ].x - c.x ) * influence;
								vC.y += ( targets[ face.c ].y - c.y ) * influence;
								vC.z += ( targets[ face.c ].z - c.z ) * influence;
	
							}
	
							vA.add( a );
							vB.add( b );
							vC.add( c );
	
							a = vA;
							b = vB;
							c = vC;
	
						}
	
						if ( material.side === THREE.BackSide ) {
								
							var intersectionPoint = localRay.intersectTriangle( c, b, a, true );
	
						} else {
									
							var intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );
	
						}
	
						if ( intersectionPoint === null ) continue;
	
						intersectionPoint.applyMatrix4( object.matrixWorld );
	
						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );
	
						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							point: intersectionPoint,
							face: face,
							faceIndex: f,
							object: object
	
						} );
	
					}
	
				}
	
			} else if ( object instanceof THREE.Line ) {
	
				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				// Checking boundingSphere distance to ray
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
				
				if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {
	
					return intersects;
	
				}
				
				inverseMatrix.getInverse( object.matrixWorld );
				localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				/* if ( geometry instanceof THREE.BufferGeometry ) {
	
				} else */ if ( geometry instanceof THREE.Geometry ) {
	
					var vertices = geometry.vertices;
					var nbVertices = vertices.length;
					var interSegment = new THREE.Vector3();
					var interRay = new THREE.Vector3();
					var step = object.type === THREE.LineStrip ? 1 : 2;
	
					for ( var i = 0; i < nbVertices - 1; i = i + step ) {
	
						var distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						var distance = localRay.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( object.matrixWorld ),
							face: null,
							faceIndex: null,
							object: object
	
						} );
	
					}
	
				}
	
			}
	
		};
	
		var intersectDescendants = function ( object, raycaster, intersects ) {
	
			var descendants = object.getDescendants();
	
			for ( var i = 0, l = descendants.length; i < l; i ++ ) {
	
				intersectObject( descendants[ i ], raycaster, intersects );
	
			}
		};
	
		//
	
		THREE.Raycaster.prototype.precision = 0.0001;
		THREE.Raycaster.prototype.linePrecision = 1;
	
		THREE.Raycaster.prototype.set = function ( origin, direction ) {
	
			this.ray.set( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
		};
	
		THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {
	
			var intersects = [];
	
			if ( recursive === true ) {
	
				intersectDescendants( object, this, intersects );
	
			}
	
			intersectObject( object, this, intersects );
	
			intersects.sort( descSort );
	
			return intersects;
	
		};
	
		THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {
	
			var intersects = [];
	
			for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
				intersectObject( objects[ i ], this, intersects );
	
				if ( recursive === true ) {
	
					intersectDescendants( objects[ i ], this, intersects );
	
				}
	
			}
	
			intersects.sort( descSort );
	
			return intersects;
	
		};
	
	}( THREE ) );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Object3D = function () {
	
		this.id = THREE.Object3DIdCount ++;
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
	
		this.parent = undefined;
		this.children = [];
	
		this.up = new THREE.Vector3( 0, 1, 0 );
	
		this.position = new THREE.Vector3();
		this._rotation = new THREE.Euler();
		this._quaternion = new THREE.Quaternion();
		this.scale = new THREE.Vector3( 1, 1, 1 );
	
		// keep rotation and quaternion in sync
	
		this._rotation._quaternion = this.quaternion;
		this._quaternion._euler = this.rotation;
	
		this.renderDepth = null;
	
		this.rotationAutoUpdate = true;
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = true;
		this.matrixWorldNeedsUpdate = true;
	
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
	
		this.userData = {};
	
	};
	
	
	THREE.Object3D.prototype = {
	
		constructor: THREE.Object3D,
		
		get rotation () { 
			return this._rotation; 
		},
	
		set rotation ( value ) {
			
			this._rotation = value;
			this._rotation._quaternion = this._quaternion;
			this._quaternion._euler = this._rotation;
			this._rotation._updateQuaternion();
			
		},
	
		get quaternion () { 
			return this._quaternion; 
		},
		
		set quaternion ( value ) {
			
			this._quaternion = value;
			this._quaternion._euler = this._rotation;
			this._rotation._quaternion = this._quaternion;
			this._quaternion._updateEuler();
			
		},
	
		get eulerOrder () {
	
			console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );
	
			return this.rotation.order;
	
		},
	
		set eulerOrder ( value ) {
	
			console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );
	
			this.rotation.order = value;
	
		},
	
		get useQuaternion () {
	
			console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );
	
		},
	
		set useQuaternion ( value ) {
	
			console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );
	
		},
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function() {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			}
	
		}(),
	
		rotateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new THREE.Vector3();
	
			return function ( axis, distance ) {
	
				v1.copy( axis );
	
				v1.applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			}
	
		}(),
	
		translate: function ( distance, axis ) {
	
			console.warn( 'DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );
			return this.translateOnAxis( axis, distance );
	
		},
	
		translateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This routine does not support objects with rotated and/or translated parent(s)
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				m1.lookAt( vector, this.position, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( object === this ) {
	
				console.warn( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
				return;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== undefined ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
				// add to scene
	
				var scene = this;
	
				while ( scene.parent !== undefined ) {
	
					scene = scene.parent;
	
				}
	
				if ( scene !== undefined && scene instanceof THREE.Scene )  {
	
					scene.__addObject( object );
	
				}
	
			}
	
		},
	
		remove: function ( object ) {
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = undefined;
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
				// remove from scene
	
				var scene = this;
	
				while ( scene.parent !== undefined ) {
	
					scene = scene.parent;
	
				}
	
				if ( scene !== undefined && scene instanceof THREE.Scene ) {
	
					scene.__removeObject( object );
	
				}
	
			}
	
		},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].traverse( callback );
	
			}
	
		},
	
		getObjectById: function ( id, recursive ) {
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
	
				if ( child.id === id ) {
	
					return child;
	
				}
	
				if ( recursive === true ) {
	
					child = child.getObjectById( id, recursive );
	
					if ( child !== undefined ) {
	
						return child;
	
					}
	
				}
	
			}
	
			return undefined;
	
		},
	
		getObjectByName: function ( name, recursive ) {
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
	
				if ( child.name === name ) {
	
					return child;
	
				}
	
				if ( recursive === true ) {
	
					child = child.getObjectByName( name, recursive );
	
					if ( child !== undefined ) {
	
						return child;
	
					}
	
				}
	
			}
	
			return undefined;
	
		},
	
		getChildByName: function ( name, recursive ) {
	
			console.warn( 'DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name, recursive );
	
		},
	
		getDescendants: function ( array ) {
	
			if ( array === undefined ) array = [];
	
			Array.prototype.push.apply( array, this.children );
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].getDescendants( array );
	
			}
	
			return array;
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === undefined ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		clone: function ( object, recursive ) {
	
			if ( object === undefined ) object = new THREE.Object3D();
			if ( recursive === undefined ) recursive = true;
	
			object.name = this.name;
	
			object.up.copy( this.up );
	
			object.position.copy( this.position );
			object.quaternion.copy( this.quaternion );
			object.scale.copy( this.scale );
	
			object.renderDepth = this.renderDepth;
	
			object.rotationAutoUpdate = this.rotationAutoUpdate;
	
			object.matrix.copy( this.matrix );
			object.matrixWorld.copy( this.matrixWorld );
	
			object.matrixAutoUpdate = this.matrixAutoUpdate;
			object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
	
			object.visible = this.visible;
	
			object.castShadow = this.castShadow;
			object.receiveShadow = this.receiveShadow;
	
			object.frustumCulled = this.frustumCulled;
	
			object.userData = JSON.parse( JSON.stringify( this.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					var child = this.children[ i ];
					object.add( child.clone() );
	
				}
	
			}
	
			return object;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );
	
	THREE.Object3DIdCount = 0;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author julianwa / https://github.com/julianwa
	 */
	
	THREE.Projector = function () {
	
		var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
		_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
		_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,
		_line, _lineCount, _linePool = [], _linePoolLength = 0,
		_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,
	
		_renderData = { objects: [], sprites: [], lights: [], elements: [] },
	
		_vA = new THREE.Vector3(),
		_vB = new THREE.Vector3(),
		_vC = new THREE.Vector3(),
	
		_vector3 = new THREE.Vector3(),
		_vector4 = new THREE.Vector4(),
	
		_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
		_boundingBox = new THREE.Box3(),
		_points3 = new Array( 3 ),
		_points4 = new Array( 4 ),
	
		_viewMatrix = new THREE.Matrix4(),
		_viewProjectionMatrix = new THREE.Matrix4(),
	
		_modelMatrix,
		_modelViewProjectionMatrix = new THREE.Matrix4(),
	
		_normalMatrix = new THREE.Matrix3(),
		_normalViewMatrix = new THREE.Matrix3(),
	
		_centroid = new THREE.Vector3(),
	
		_frustum = new THREE.Frustum(),
	
		_clippedVertex1PositionScreen = new THREE.Vector4(),
		_clippedVertex2PositionScreen = new THREE.Vector4();
	
		this.projectVector = function ( vector, camera ) {
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
	
			return vector.applyProjection( _viewProjectionMatrix );
	
		};
	
		this.unprojectVector = function () {
	
			var projectionMatrixInverse = new THREE.Matrix4();
	
			return function ( vector, camera ) {
	
				projectionMatrixInverse.getInverse( camera.projectionMatrix );
				_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );
	
				return vector.applyProjection( _viewProjectionMatrix );
	
			};
	
		}();
	
		this.pickingRay = function ( vector, camera ) {
	
			// set two vectors with opposing z values
			vector.z = -1.0;
			var end = new THREE.Vector3( vector.x, vector.y, 1.0 );
	
			this.unprojectVector( vector, camera );
			this.unprojectVector( end, camera );
	
			// find direction from vector to end
			end.sub( vector ).normalize();
	
			return new THREE.Raycaster( vector, end );
	
		};
	
		var getObject = function ( object ) {
	
			_object = getNextObjectInPool();
			_object.id = object.id;
			_object.object = object;
	
			if ( object.renderDepth !== null ) {
	
				_object.z = object.renderDepth;
	
			} else {
	
				_vector3.setFromMatrixPosition( object.matrixWorld );
				_vector3.applyProjection( _viewProjectionMatrix );
				_object.z = _vector3.z;
	
			}
	
			return _object;
	
		};
	
		var projectVertex = function ( vertex ) {
	
			var position = vertex.position;
			var positionWorld = vertex.positionWorld;
			var positionScreen = vertex.positionScreen;
	
			positionWorld.copy( position ).applyMatrix4( _modelMatrix );
			positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );
	
			var invW = 1 / positionScreen.w;
	
			positionScreen.x *= invW;
			positionScreen.y *= invW;
			positionScreen.z *= invW;
	
			vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&
					 positionScreen.y >= -1 && positionScreen.y <= 1 &&
					 positionScreen.z >= -1 && positionScreen.z <= 1;
	
		};
	
		var projectObject = function ( object ) {
	
			if ( object.visible === false ) return;
	
			if ( object instanceof THREE.Light ) {
	
				_renderData.lights.push( object );
	
			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {
	
				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
					_renderData.objects.push( getObject( object ) );
	
				}
	
			} else if ( object instanceof THREE.Sprite ) {
	
				_renderData.sprites.push( getObject( object ) );
	
			}
	
			for ( var i = 0, l = object.children.length; i < l; i ++ ) {
	
				projectObject( object.children[ i ] );
	
			}
	
		};
	
		var projectGraph = function ( root, sortObjects ) {
	
			_objectCount = 0;
	
			_renderData.objects.length = 0;
			_renderData.sprites.length = 0;
			_renderData.lights.length = 0;
	
			projectObject( root );
	
			if ( sortObjects === true ) {
	
				_renderData.objects.sort( painterSort );
	
			}
	
		};
	
		this.projectScene = function ( scene, camera, sortObjects, sortElements ) {
	
			var visible = false,
			object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
			v1, v2, v3, v4, isFaceMaterial, objectMaterials;
	
			_face3Count = 0;
			_lineCount = 0;
			_spriteCount = 0;
	
			_renderData.elements.length = 0;
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
			if ( camera.parent === undefined ) camera.updateMatrixWorld();
	
			_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
			_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );
	
			_normalViewMatrix.getNormalMatrix( _viewMatrix );
	
			_frustum.setFromMatrix( _viewProjectionMatrix );
	
			projectGraph( scene, sortObjects );
	
			for ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {
	
				object = _renderData.objects[ o ].object;
	
				_modelMatrix = object.matrixWorld;
	
				_vertexCount = 0;
	
				if ( object instanceof THREE.Mesh ) {
	
					geometry = object.geometry;
	
					vertices = geometry.vertices;
					faces = geometry.faces;
					faceVertexUvs = geometry.faceVertexUvs;
	
					_normalMatrix.getNormalMatrix( _modelMatrix );
	
					isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
					objectMaterials = isFaceMaterial === true ? object.material : null;
	
					for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {
	
						_vertex = getNextVertexInPool();
						_vertex.position.copy( vertices[ v ] );
	
						projectVertex( _vertex );
	
					}
	
					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
						face = faces[ f ];
	
						var material = isFaceMaterial === true
							? objectMaterials.materials[ face.materialIndex ]
							: object.material;
	
						if ( material === undefined ) continue;
	
						var side = material.side;
	
						v1 = _vertexPool[ face.a ];
						v2 = _vertexPool[ face.b ];
						v3 = _vertexPool[ face.c ];
	
						if ( material.morphTargets === true ) {
	
							var morphTargets = geometry.morphTargets;
							var morphInfluences = object.morphTargetInfluences;
	
							var v1p = v1.position;
							var v2p = v2.position;
							var v3p = v3.position;
	
							_vA.set( 0, 0, 0 );
							_vB.set( 0, 0, 0 );
							_vC.set( 0, 0, 0 );
	
							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
								var influence = morphInfluences[ t ];
	
								if ( influence === 0 ) continue;
	
								var targets = morphTargets[ t ].vertices;
	
								_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;
								_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;
								_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;
	
								_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;
								_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;
								_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;
	
								_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;
								_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;
								_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;
	
							}
	
							v1.position.add( _vA );
							v2.position.add( _vB );
							v3.position.add( _vC );
	
							projectVertex( v1 );
							projectVertex( v2 );
							projectVertex( v3 );
	
						}
	
						_points3[ 0 ] = v1.positionScreen;
						_points3[ 1 ] = v2.positionScreen;
						_points3[ 2 ] = v3.positionScreen;
	
						if ( v1.visible === true || v2.visible === true || v3.visible === true ||
							_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {
	
							visible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *
								    ( v2.positionScreen.y - v1.positionScreen.y ) -
								    ( v3.positionScreen.y - v1.positionScreen.y ) *
								    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;
	
							if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {
	
								_face = getNextFace3InPool();
	
								_face.id = object.id;
								_face.v1.copy( v1 );
								_face.v2.copy( v2 );
								_face.v3.copy( v3 );
	
							} else {
	
								continue;
	
							}
	
						} else {
	
							continue;
	
						}
	
						_face.normalModel.copy( face.normal );
	
						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {
	
							_face.normalModel.negate();
	
						}
	
						_face.normalModel.applyMatrix3( _normalMatrix ).normalize();
	
						_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );
	
						_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );
	
						faceVertexNormals = face.vertexNormals;
	
						for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {
	
							var normalModel = _face.vertexNormalsModel[ n ];
							normalModel.copy( faceVertexNormals[ n ] );
	
							if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {
	
								normalModel.negate();
	
							}
	
							normalModel.applyMatrix3( _normalMatrix ).normalize();
	
							var normalModelView = _face.vertexNormalsModelView[ n ];
							normalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );
	
						}
	
						_face.vertexNormalsLength = faceVertexNormals.length;
	
						for ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {
	
							uvs = faceVertexUvs[ c ][ f ];
	
							if ( uvs === undefined ) continue;
	
							for ( var u = 0, ul = uvs.length; u < ul; u ++ ) {
	
								_face.uvs[ c ][ u ] = uvs[ u ];
	
							}
	
						}
	
						_face.color = face.color;
						_face.material = material;
	
						_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );
	
						_face.z = _centroid.z;
	
						_renderData.elements.push( _face );
	
					}
	
				} else if ( object instanceof THREE.Line ) {
	
					_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );
	
					vertices = object.geometry.vertices;
	
					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );
	
					// Handle LineStrip and LinePieces
					var step = object.type === THREE.LinePieces ? 2 : 1;
	
					for ( v = 1, vl = vertices.length; v < vl; v ++ ) {
	
						v1 = getNextVertexInPool();
						v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );
	
						if ( ( v + 1 ) % step > 0 ) continue;
	
						v2 = _vertexPool[ _vertexCount - 2 ];
	
						_clippedVertex1PositionScreen.copy( v1.positionScreen );
						_clippedVertex2PositionScreen.copy( v2.positionScreen );
	
						if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {
	
							// Perform the perspective divide
							_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
							_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );
	
							_line = getNextLineInPool();
	
							_line.id = object.id;
							_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
							_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );
	
							_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );
	
							_line.material = object.material;
	
							if ( object.material.vertexColors === THREE.VertexColors ) {
	
								_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
								_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );
	
							}
	
							_renderData.elements.push( _line );
	
						}
	
					}
	
				}
	
			}
	
			for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {
	
				object = _renderData.sprites[ o ].object;
	
				_modelMatrix = object.matrixWorld;
	
				_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
				_vector4.applyMatrix4( _viewProjectionMatrix );
	
				var invW = 1 / _vector4.w;
	
				_vector4.z *= invW;
	
				if ( _vector4.z >= -1 && _vector4.z <= 1 ) {
	
					_sprite = getNextSpriteInPool();
					_sprite.id = object.id;
					_sprite.x = _vector4.x * invW;
					_sprite.y = _vector4.y * invW;
					_sprite.z = _vector4.z;
					_sprite.object = object;
	
					_sprite.rotation = object.rotation;
	
					_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
					_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );
	
					_sprite.material = object.material;
	
					_renderData.elements.push( _sprite );
	
				}
	
			}
	
			if ( sortElements === true ) _renderData.elements.sort( painterSort );
	
			return _renderData;
	
		};
	
		// Pools
	
		function getNextObjectInPool() {
	
			if ( _objectCount === _objectPoolLength ) {
	
				var object = new THREE.RenderableObject();
				_objectPool.push( object );
				_objectPoolLength ++;
				_objectCount ++;
				return object;
	
			}
	
			return _objectPool[ _objectCount ++ ];
	
		}
	
		function getNextVertexInPool() {
	
			if ( _vertexCount === _vertexPoolLength ) {
	
				var vertex = new THREE.RenderableVertex();
				_vertexPool.push( vertex );
				_vertexPoolLength ++;
				_vertexCount ++;
				return vertex;
	
			}
	
			return _vertexPool[ _vertexCount ++ ];
	
		}
	
		function getNextFace3InPool() {
	
			if ( _face3Count === _face3PoolLength ) {
	
				var face = new THREE.RenderableFace3();
				_face3Pool.push( face );
				_face3PoolLength ++;
				_face3Count ++;
				return face;
	
			}
	
			return _face3Pool[ _face3Count ++ ];
	
	
		}
	
		function getNextLineInPool() {
	
			if ( _lineCount === _linePoolLength ) {
	
				var line = new THREE.RenderableLine();
				_linePool.push( line );
				_linePoolLength ++;
				_lineCount ++
				return line;
	
			}
	
			return _linePool[ _lineCount ++ ];
	
		}
	
		function getNextSpriteInPool() {
	
			if ( _spriteCount === _spritePoolLength ) {
	
				var sprite = new THREE.RenderableSprite();
				_spritePool.push( sprite );
				_spritePoolLength ++;
				_spriteCount ++
				return sprite;
	
			}
	
			return _spritePool[ _spriteCount ++ ];
	
		}
	
		//
	
		function painterSort( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else if ( a.id !== b.id ) {
	
				return a.id - b.id;
	
			} else {
	
				return 0;
	
			}
	
		}
	
		function clipLine( s1, s2 ) {
	
			var alpha1 = 0, alpha2 = 1,
	
			// Calculate the boundary coordinate of each vertex for the near and far clip planes,
			// Z = -1 and Z = +1, respectively.
			bc1near =  s1.z + s1.w,
			bc2near =  s2.z + s2.w,
			bc1far =  - s1.z + s1.w,
			bc2far =  - s2.z + s2.w;
	
			if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {
	
				// Both vertices lie entirely within all clip planes.
				return true;
	
			} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {
	
				// Both vertices lie entirely outside one of the clip planes.
				return false;
	
			} else {
	
				// The line segment spans at least one clip plane.
	
				if ( bc1near < 0 ) {
	
					// v1 lies outside the near plane, v2 inside
					alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );
	
				} else if ( bc2near < 0 ) {
	
					// v2 lies outside the near plane, v1 inside
					alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );
	
				}
	
				if ( bc1far < 0 ) {
	
					// v1 lies outside the far plane, v2 inside
					alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );
	
				} else if ( bc2far < 0 ) {
	
					// v2 lies outside the far plane, v2 inside
					alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );
	
				}
	
				if ( alpha2 < alpha1 ) {
	
					// The line segment spans two boundaries, but is outside both of them.
					// (This can't happen when we're only clipping against just near/far but good
					//  to leave the check here for future usage if other clip planes are added.)
					return false;
	
				} else {
	
					// Update the s1 and s2 vertices to match the clipped line segment.
					s1.lerp( s2, alpha1 );
					s2.lerp( s1, 1 - alpha2 );
	
					return true;
	
				}
	
			}
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [ ];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];
	
		this.vertexTangents = [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		this.centroid = new THREE.Vector3();
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			var face = new THREE.Face3( this.a, this.b, this.c );
	
			face.normal.copy( this.normal );
			face.color.copy( this.color );
			face.centroid.copy( this.centroid );
	
			face.materialIndex = this.materialIndex;
	
			var i, il;
			for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
			for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
			for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();
	
			return face;
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {
	
		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')
	
		return new THREE.Face3( a, b, c, normal, color, materialIndex );
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Geometry = function () {
	
		this.id = THREE.GeometryIdCount ++;
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
	
		this.vertices = [];
		this.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line
	
		this.faces = [];
	
		this.faceVertexUvs = [[]];
	
		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.hasTangents = false;
	
		this.dynamic = true; // the intermediate typed arrays will be deleted when set to false
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.tangentsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
	
		this.buffersNeedUpdate = false;
	
	};
	
	THREE.Geometry.prototype = {
	
		constructor: THREE.Geometry,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
				face.centroid.applyMatrix4( matrix );
	
			}
	
			if ( this.boundingBox instanceof THREE.Box3 ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere instanceof THREE.Sphere ) {
	
				this.computeBoundingSphere();
	
			}
	
		},
	
		computeCentroids: function () {
	
			var f, fl, face;
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
				face.centroid.set( 0, 0, 0 );
	
				face.centroid.add( this.vertices[ face.a ] );
				face.centroid.add( this.vertices[ face.b ] );
				face.centroid.add( this.vertices[ face.c ] );
				face.centroid.divideScalar( 3 );
	
			}
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new THREE.Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC, vD;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
					db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
				face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
				face.vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			// based on http://www.terathon.com/code/tangent.html
			// tangents go to vertices
	
			var f, fl, v, vl, i, il, vertexIndex,
				face, uv, vA, vB, vC, uvA, uvB, uvC,
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r, t, test,
				tan1 = [], tan2 = [],
				sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
				tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
				n = new THREE.Vector3(), w;
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				tan1[ v ] = new THREE.Vector3();
				tan2[ v ] = new THREE.Vector3();
	
			}
	
			function handleTriangle( context, a, b, c, ua, ub, uc ) {
	
				vA = context.vertices[ a ];
				vB = context.vertices[ b ];
				vC = context.vertices[ c ];
	
				uvA = uv[ ua ];
				uvB = uv[ ub ];
				uvC = uv[ uc ];
	
				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;
	
				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;
	
				r = 1.0 / ( s1 * t2 - s2 * t1 );
				sdir.set( ( t2 * x1 - t1 * x2 ) * r,
						  ( t2 * y1 - t1 * y2 ) * r,
						  ( t2 * z1 - t1 * z2 ) * r );
				tdir.set( ( s1 * x2 - s2 * x1 ) * r,
						  ( s1 * y2 - s2 * y1 ) * r,
						  ( s1 * z2 - s2 * z1 ) * r );
	
				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );
	
				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
				uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents
	
				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );
	
			}
	
			var faceIndex = [ 'a', 'b', 'c', 'd' ];
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {
	
					n.copy( face.vertexNormals[ i ] );
	
					vertexIndex = face[ faceIndex[ i ] ];
	
					t = tan1[ vertexIndex ];
	
					// Gram-Schmidt orthogonalize
	
					tmp.copy( t );
					tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
	
					// Calculate handedness
	
					tmp2.crossVectors( face.vertexNormals[ i ], t );
					test = tmp2.dot( tan2[ vertexIndex ] );
					w = (test < 0.0) ? -1.0 : 1.0;
	
					face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );
	
				}
	
			}
	
			this.hasTangents = true;
	
		},
	
		computeLineDistances: function ( ) {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i,il, face;
			var indices, k, j, jl, u;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			};
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				var dupIndex = -1;
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
					if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {
	
						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;
	
					}
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		clone: function () {
	
			var geometry = new THREE.Geometry();
	
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				geometry.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = this.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				geometry.faces.push( faces[ i ].clone() );
	
			}
	
			var uvs = this.faceVertexUvs[ 0 ];
	
			for ( var i = 0, il = uvs.length; i < il; i ++ ) {
	
				var uv = uvs[ i ], uvCopy = [];
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );
	
				}
	
				geometry.faceVertexUvs[ 0 ].push( uvCopy );
	
			}
	
			return geometry;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );
	
	THREE.GeometryIdCount = 0;
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		this.id = THREE.GeometryIdCount ++;
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
	
		// attributes
	
		this.attributes = {};
	
		// attributes typed arrays are kept only if dynamic flag is set
	
		this.dynamic = true;
	
		// offsets for chunks when using indexed elements
	
		this.offsets = [];
	
		// boundings
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.hasTangents = false;
	
		// for compatibility
	
		this.morphTargets = [];
	
	};
	
	THREE.BufferGeometry.prototype = {
	
		constructor: THREE.BufferGeometry,
	
		addAttribute: function( name, type, numItems, itemSize ) {
	
			this.attributes[ name ] = {
	
				itemSize: itemSize,
				array: new type( numItems * itemSize )
	
			};
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var positionArray;
			var normalArray;
	
			if ( this.attributes[ "position" ] ) positionArray = this.attributes[ "position" ].array;
			if ( this.attributes[ "normal" ] ) normalArray = this.attributes[ "normal" ].array;
	
			if ( positionArray !== undefined ) {
	
				matrix.multiplyVector3Array( positionArray );
				this.verticesNeedUpdate = true;
	
			}
	
			if ( normalArray !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.multiplyVector3Array( normalArray );
	
				this.normalizeNormals();
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			var positions = this.attributes[ "position" ].array;
	
			if ( positions ) {
	
				var bb = this.boundingBox;
				var x, y, z;
	
				if( positions.length >= 3 ) {
					bb.min.x = bb.max.x = positions[ 0 ];
					bb.min.y = bb.max.y = positions[ 1 ];
					bb.min.z = bb.max.z = positions[ 2 ];
				}
	
				for ( var i = 3, il = positions.length; i < il; i += 3 ) {
	
					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
	
					// bounding box
	
					if ( x < bb.min.x ) {
	
						bb.min.x = x;
	
					} else if ( x > bb.max.x ) {
	
						bb.max.x = x;
	
					}
	
					if ( y < bb.min.y ) {
	
						bb.min.y = y;
	
					} else if ( y > bb.max.y ) {
	
						bb.max.y = y;
	
					}
	
					if ( z < bb.min.z ) {
	
						bb.min.z = z;
	
					} else if ( z > bb.max.z ) {
	
						bb.max.z = z;
	
					}
	
				}
	
			}
	
			if ( positions === undefined || positions.length === 0 ) {
	
				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );
	
			}
	
		},
	
		computeBoundingSphere: function () {
	
			var box = new THREE.Box3();
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new THREE.Sphere();
	
				}
	
				var positions = this.attributes[ "position" ].array;
	
				if ( positions ) {
	
					box.makeEmpty();
	
					var center = this.boundingSphere.center;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						box.addPoint( vector );
	
					}
	
					box.center( center );
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
				}
	
			}
	
		}(),
	
		computeVertexNormals: function () {
	
			if ( this.attributes[ "position" ] ) {
	
				var i, il;
				var j, jl;
	
				var nVertexElements = this.attributes[ "position" ].array.length;
	
				if ( this.attributes[ "normal" ] === undefined ) {
	
					this.attributes[ "normal" ] = {
	
						itemSize: 3,
						array: new Float32Array( nVertexElements )
	
					};
	
				} else {
	
					// reset existing normals to zero
	
					for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {
	
						this.attributes[ "normal" ].array[ i ] = 0;
	
					}
	
				}
	
				var positions = this.attributes[ "position" ].array;
				var normals = this.attributes[ "normal" ].array;
	
				var vA, vB, vC, x, y, z,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( this.attributes[ "index" ] ) {
	
					var indices = this.attributes[ "index" ].array;
	
					var offsets = this.offsets;
	
					for ( j = 0, jl = offsets.length; j < jl; ++ j ) {
	
						var start = offsets[ j ].start;
						var count = offsets[ j ].count;
						var index = offsets[ j ].index;
	
						for ( i = start, il = start + count; i < il; i += 3 ) {
	
							vA = index + indices[ i ];
							vB = index + indices[ i + 1 ];
							vC = index + indices[ i + 2 ];
	
							x = positions[ vA * 3 ];
							y = positions[ vA * 3 + 1 ];
							z = positions[ vA * 3 + 2 ];
							pA.set( x, y, z );
	
							x = positions[ vB * 3 ];
							y = positions[ vB * 3 + 1 ];
							z = positions[ vB * 3 + 2 ];
							pB.set( x, y, z );
	
							x = positions[ vC * 3 ];
							y = positions[ vC * 3 + 1 ];
							z = positions[ vC * 3 + 2 ];
							pC.set( x, y, z );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA * 3 ]     += cb.x;
							normals[ vA * 3 + 1 ] += cb.y;
							normals[ vA * 3 + 2 ] += cb.z;
	
							normals[ vB * 3 ]     += cb.x;
							normals[ vB * 3 + 1 ] += cb.y;
							normals[ vB * 3 + 2 ] += cb.z;
	
							normals[ vC * 3 ]     += cb.x;
							normals[ vC * 3 + 1 ] += cb.y;
							normals[ vC * 3 + 2 ] += cb.z;
	
						}
	
					}
	
				// non-indexed elements (unconnected triangle soup)
	
				} else {
	
					for ( i = 0, il = positions.length; i < il; i += 9 ) {
	
						x = positions[ i ];
						y = positions[ i + 1 ];
						z = positions[ i + 2 ];
						pA.set( x, y, z );
	
						x = positions[ i + 3 ];
						y = positions[ i + 4 ];
						z = positions[ i + 5 ];
						pB.set( x, y, z );
	
						x = positions[ i + 6 ];
						y = positions[ i + 7 ];
						z = positions[ i + 8 ];
						pC.set( x, y, z );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] 	 = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes[ "normal" ].array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i ] 	 *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		computeTangents: function () {
	
			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)
	
			if ( this.attributes[ "index" ] === undefined ||
				 this.attributes[ "position" ] === undefined ||
				 this.attributes[ "normal" ] === undefined ||
				 this.attributes[ "uv" ] === undefined ) {
	
				console.warn( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
				return;
	
			}
	
			var indices = this.attributes[ "index" ].array;
			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;
			var uvs = this.attributes[ "uv" ].array;
	
			var nVertices = positions.length / 3;
	
			if ( this.attributes[ "tangent" ] === undefined ) {
	
				var nTangentElements = 4 * nVertices;
	
				this.attributes[ "tangent" ] = {
	
					itemSize: 4,
					array: new Float32Array( nTangentElements )
	
				};
	
			}
	
			var tangents = this.attributes[ "tangent" ].array;
	
			var tan1 = [], tan2 = [];
	
			for ( var k = 0; k < nVertices; k ++ ) {
	
				tan1[ k ] = new THREE.Vector3();
				tan2[ k ] = new THREE.Vector3();
	
			}
	
			var xA, yA, zA,
				xB, yB, zB,
				xC, yC, zC,
	
				uA, vA,
				uB, vB,
				uC, vC,
	
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r;
	
			var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();
	
			function handleTriangle( a, b, c ) {
	
				xA = positions[ a * 3 ];
				yA = positions[ a * 3 + 1 ];
				zA = positions[ a * 3 + 2 ];
	
				xB = positions[ b * 3 ];
				yB = positions[ b * 3 + 1 ];
				zB = positions[ b * 3 + 2 ];
	
				xC = positions[ c * 3 ];
				yC = positions[ c * 3 + 1 ];
				zC = positions[ c * 3 + 2 ];
	
				uA = uvs[ a * 2 ];
				vA = uvs[ a * 2 + 1 ];
	
				uB = uvs[ b * 2 ];
				vB = uvs[ b * 2 + 1 ];
	
				uC = uvs[ c * 2 ];
				vC = uvs[ c * 2 + 1 ];
	
				x1 = xB - xA;
				x2 = xC - xA;
	
				y1 = yB - yA;
				y2 = yC - yA;
	
				z1 = zB - zA;
				z2 = zC - zA;
	
				s1 = uB - uA;
				s2 = uC - uA;
	
				t1 = vB - vA;
				t2 = vC - vA;
	
				r = 1.0 / ( s1 * t2 - s2 * t1 );
	
				sdir.set(
					( t2 * x1 - t1 * x2 ) * r,
					( t2 * y1 - t1 * y2 ) * r,
					( t2 * z1 - t1 * z2 ) * r
				);
	
				tdir.set(
					( s1 * x2 - s2 * x1 ) * r,
					( s1 * y2 - s2 * y1 ) * r,
					( s1 * z2 - s2 * z1 ) * r
				);
	
				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );
	
				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );
	
			}
	
			var i, il;
			var j, jl;
			var iA, iB, iC;
	
			var offsets = this.offsets;
	
			for ( j = 0, jl = offsets.length; j < jl; ++ j ) {
	
				var start = offsets[ j ].start;
				var count = offsets[ j ].count;
				var index = offsets[ j ].index;
	
				for ( i = start, il = start + count; i < il; i += 3 ) {
	
					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];
	
					handleTriangle( iA, iB, iC );
	
				}
	
			}
	
			var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
			var n = new THREE.Vector3(), n2 = new THREE.Vector3();
			var w, t, test;
	
			function handleVertex( v ) {
	
				n.x = normals[ v * 3 ];
				n.y = normals[ v * 3 + 1 ];
				n.z = normals[ v * 3 + 2 ];
	
				n2.copy( n );
	
				t = tan1[ v ];
	
				// Gram-Schmidt orthogonalize
	
				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
	
				// Calculate handedness
	
				tmp2.crossVectors( n2, t );
				test = tmp2.dot( tan2[ v ] );
				w = ( test < 0.0 ) ? -1.0 : 1.0;
	
				tangents[ v * 4 ]     = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;
	
			}
	
			for ( j = 0, jl = offsets.length; j < jl; ++ j ) {
	
				var start = offsets[ j ].start;
				var count = offsets[ j ].count;
				var index = offsets[ j ].index;
	
				for ( i = start, il = start + count; i < il; i += 3 ) {
	
					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];
	
					handleVertex( iA );
					handleVertex( iB );
					handleVertex( iC );
	
				}
	
			}
	
			this.hasTangents = true;
			this.tangentsNeedUpdate = true;
	
		},
	
		clone: function () {
	
			var geometry = new THREE.BufferGeometry();
	
			var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
	
			for ( var attr in this.attributes ) {
	
				var sourceAttr = this.attributes[ attr ];
				var sourceArray = sourceAttr.array;
	
				var attribute = {
	
					itemSize: sourceAttr.itemSize,
					numItems: sourceAttr.numItems,
					array: null
	
				};
	
				for ( var i = 0, il = types.length; i < il; i ++ ) {
	
					var type = types[ i ];
	
					if ( sourceArray instanceof type ) {
	
						attribute.array = new type( sourceArray );
						break;
	
					}
	
				}
	
				geometry.attributes[ attr ] = attribute;
	
			}
	
			for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {
	
				var offset = this.offsets[ i ];
	
				geometry.offsets.push( {
	
					start: offset.start,
					index: offset.index,
					count: offset.count
	
				} );
	
			}
	
			return geometry;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Camera.prototype.lookAt = function () {
	
		// This routine does not support cameras with rotated and/or translated parent(s)
	
		var m1 = new THREE.Matrix4();
	
		return function ( vector ) {
	
			m1.lookAt( this.position, vector, this.up );
	
			this.quaternion.setFromRotationMatrix( m1 );
	
		};
	
	}();
	
	THREE.Camera.prototype.clone = function (camera) {
	
		if ( camera === undefined ) camera = new THREE.Camera();
	
		THREE.Object3D.prototype.clone.call( this, camera );
	
		camera.matrixWorldInverse.copy( this.matrixWorldInverse );
		camera.projectionMatrix.copy( this.projectionMatrix );
	
		return camera;
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	
	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	
		this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );
	
	};
	
	THREE.OrthographicCamera.prototype.clone = function () {
	
		var camera = new THREE.OrthographicCamera();
	
		THREE.Camera.prototype.clone.call( this, camera );
	
		camera.left = this.left;
		camera.right = this.right;
		camera.top = this.top;
		camera.bottom = this.bottom;
		
		camera.near = this.near;
		camera.far = this.far;
	
		return camera;
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	
	
	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (fullframe) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();
	
	}
	
	
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	
	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {
	
		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	
		this.updateProjectionMatrix();
	
	};
	
	
	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	
		if ( this.fullWidth ) {
	
			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
			var bottom = -top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );
	
			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);
	
		} else {
	
			this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );
	
		}
	
	};
	
	THREE.PerspectiveCamera.prototype.clone = function () {
	
		var camera = new THREE.PerspectiveCamera();
	
		THREE.Camera.prototype.clone.call( this, camera );
	
		camera.fov = this.fov;
		camera.aspect = this.aspect;
		camera.near = this.near;
		camera.far = this.far;
	
		return camera;
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	 
	THREE.Light = function ( hex ) {
	
		THREE.Object3D.call( this );
	
		this.color = new THREE.Color( hex );
	
	};
	
	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Light.prototype.clone = function ( light ) {
	
		if ( light === undefined ) light = new THREE.Light();
	
		THREE.Object3D.prototype.clone.call( this, light );
	
		light.color.copy( this.color );
	
		return light;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( hex ) {
	
		THREE.Light.call( this, hex );
	
	};
	
	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	
	THREE.AmbientLight.prototype.clone = function () {
	
		var light = new THREE.AmbientLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		return light;
	
	};
	
	/**
	 * @author MPanknin / http://www.redplant.de/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.AreaLight = function ( hex, intensity ) {
	
		THREE.Light.call( this, hex );
	
		this.normal = new THREE.Vector3( 0, -1, 0 );
		this.right = new THREE.Vector3( 1, 0, 0 );
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.width = 1.0;
		this.height = 1.0;
	
		this.constantAttenuation = 1.5;
		this.linearAttenuation = 0.5;
		this.quadraticAttenuation = 0.1;
	
	};
	
	THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
	
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( hex, intensity ) {
	
		THREE.Light.call( this, hex );
	
		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.castShadow = false;
		this.onlyShadow = false;
	
		//
	
		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
	
		this.shadowCameraLeft = -500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = -500;
	
		this.shadowCameraVisible = false;
	
		this.shadowBias = 0;
		this.shadowDarkness = 0.5;
	
		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;
	
		//
	
		this.shadowCascade = false;
	
		this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
		this.shadowCascadeCount = 2;
	
		this.shadowCascadeBias = [ 0, 0, 0 ];
		this.shadowCascadeWidth = [ 512, 512, 512 ];
		this.shadowCascadeHeight = [ 512, 512, 512 ];
	
		this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
		this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];
	
		this.shadowCascadeArray = [];
	
		//
	
		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;
	
	};
	
	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	
	THREE.DirectionalLight.prototype.clone = function () {
	
		var light = new THREE.DirectionalLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.target = this.target.clone();
	
		light.intensity = this.intensity;
	
		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;
	
		return light;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {
	
		THREE.Light.call( this, skyColorHex );
	
		this.position.set( 0, 100, 0 );
	
		this.groundColor = new THREE.Color( groundColorHex );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
	};
	
	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	
	THREE.HemisphereLight.prototype.clone = function () {
	
		var light = new THREE.HemisphereLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.groundColor.copy( this.groundColor );
		light.intensity = this.intensity;
	
		return light;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLight = function ( hex, intensity, distance ) {
	
		THREE.Light.call( this, hex );
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
	
	};
	
	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	
	THREE.PointLight.prototype.clone = function () {
	
		var light = new THREE.PointLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.intensity = this.intensity;
		light.distance = this.distance;
	
		return light;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {
	
		THREE.Light.call( this, hex );
	
		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
	
		this.castShadow = false;
		this.onlyShadow = false;
	
		//
	
		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;
	
		this.shadowCameraVisible = false;
	
		this.shadowBias = 0;
		this.shadowDarkness = 0.5;
	
		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;
	
		//
	
		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;
	
	};
	
	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	
	THREE.SpotLight.prototype.clone = function () {
	
		var light = new THREE.SpotLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.target = this.target.clone();
	
		light.intensity = this.intensity;
		light.distance = this.distance;
		light.angle = this.angle;
		light.exponent = this.exponent;
	
		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;
	
		return light;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function ( showStatus ) {
	
		this.showStatus = showStatus;
		this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: undefined,
	
		addStatusElement: function () {
	
			var e = document.createElement( "div" );
	
			e.style.position = "absolute";
			e.style.right = "0px";
			e.style.top = "0px";
			e.style.fontSize = "0.8em";
			e.style.textAlign = "left";
			e.style.background = "rgba(0,0,0,0.25)";
			e.style.color = "#fff";
			e.style.width = "120px";
			e.style.padding = "0.5em 0.5em 0.5em 0.5em";
			e.style.zIndex = 1000;
	
			e.innerHTML = "Loading ...";
	
			return e;
	
		},
	
		updateProgress: function ( progress ) {
	
			var message = "Loaded ";
	
			if ( progress.total ) {
	
				message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";
	
	
			} else {
	
				message += ( progress.loaded / 1000 ).toFixed(2) + " KB";
	
			}
	
			this.statusDomElement.innerHTML = message;
	
		},
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
			parts.pop();
			return ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );
	
			}
	
			return array;
	
		},
	
		needsTangents: function ( materials ) {
	
			for( var i = 0, il = materials.length; i < il; i ++ ) {
	
				var m = materials[ i ];
	
				if ( m instanceof THREE.ShaderMaterial ) return true;
	
			}
	
			return false;
	
		},
	
		createMaterial: function ( m, texturePath ) {
	
			var _this = this;
	
			function is_pow2( n ) {
	
				var l = Math.log( n ) / Math.LN2;
				return Math.floor( l ) == l;
	
			}
	
			function nearest_pow2( n ) {
	
				var l = Math.log( n ) / Math.LN2;
				return Math.pow( 2, Math.round(  l ) );
	
			}
	
			function load_image( where, url ) {
	
				var image = new Image();
	
				image.onload = function () {
	
					if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {
	
						var width = nearest_pow2( this.width );
						var height = nearest_pow2( this.height );
	
						where.image.width = width;
						where.image.height = height;
						where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );
	
					} else {
	
						where.image = this;
	
					}
	
					where.needsUpdate = true;
	
				};
	
				if ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;
				image.src = url;
	
			}
	
			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {
	
				var isCompressed = /\.dds$/i.test( sourceFile );
				var fullPath = texturePath + "/" + sourceFile;
	
				if ( isCompressed ) {
	
					var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );
	
					where[ name ] = texture;
	
				} else {
	
					var texture = document.createElement( 'canvas' );
	
					where[ name ] = new THREE.Texture( texture );
	
				}
	
				where[ name ].sourceFile = sourceFile;
	
				if( repeat ) {
	
					where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );
	
					if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;
	
				}
	
				if ( offset ) {
	
					where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );
	
				}
	
				if ( wrap ) {
	
					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					}
	
					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];
	
				}
	
				if ( anisotropy ) {
	
					where[ name ].anisotropy = anisotropy;
	
				}
	
				if ( ! isCompressed ) {
	
					load_image( where[ name ], fullPath );
	
				}
	
			}
	
			function rgb2hex( rgb ) {
	
				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;
	
			}
	
			// defaults
	
			var mtype = "MeshLambertMaterial";
			var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };
	
			// parameters from model file
	
			if ( m.shading ) {
	
				var shading = m.shading.toLowerCase();
	
				if ( shading === "phong" ) mtype = "MeshPhongMaterial";
				else if ( shading === "basic" ) mtype = "MeshBasicMaterial";
	
			}
	
			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {
	
				mpars.blending = THREE[ m.blending ];
	
			}
	
			if ( m.transparent !== undefined || m.opacity < 1.0 ) {
	
				mpars.transparent = m.transparent;
	
			}
	
			if ( m.depthTest !== undefined ) {
	
				mpars.depthTest = m.depthTest;
	
			}
	
			if ( m.depthWrite !== undefined ) {
	
				mpars.depthWrite = m.depthWrite;
	
			}
	
			if ( m.visible !== undefined ) {
	
				mpars.visible = m.visible;
	
			}
	
			if ( m.flipSided !== undefined ) {
	
				mpars.side = THREE.BackSide;
	
			}
	
			if ( m.doubleSided !== undefined ) {
	
				mpars.side = THREE.DoubleSide;
	
			}
	
			if ( m.wireframe !== undefined ) {
	
				mpars.wireframe = m.wireframe;
	
			}
	
			if ( m.vertexColors !== undefined ) {
	
				if ( m.vertexColors === "face" ) {
	
					mpars.vertexColors = THREE.FaceColors;
	
				} else if ( m.vertexColors ) {
	
					mpars.vertexColors = THREE.VertexColors;
	
				}
	
			}
	
			// colors
	
			if ( m.colorDiffuse ) {
	
				mpars.color = rgb2hex( m.colorDiffuse );
	
			} else if ( m.DbgColor ) {
	
				mpars.color = m.DbgColor;
	
			}
	
			if ( m.colorSpecular ) {
	
				mpars.specular = rgb2hex( m.colorSpecular );
	
			}
	
			if ( m.colorAmbient ) {
	
				mpars.ambient = rgb2hex( m.colorAmbient );
	
			}
	
			// modifiers
	
			if ( m.transparency ) {
	
				mpars.opacity = m.transparency;
	
			}
	
			if ( m.specularCoef ) {
	
				mpars.shininess = m.specularCoef;
	
			}
	
			// textures
	
			if ( m.mapDiffuse && texturePath ) {
	
				create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
	
			}
	
			if ( m.mapLight && texturePath ) {
	
				create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
	
			}
	
			if ( m.mapBump && texturePath ) {
	
				create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
	
			}
	
			if ( m.mapNormal && texturePath ) {
	
				create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
	
			}
	
			if ( m.mapSpecular && texturePath ) {
	
				create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
	
			}
	
			//
	
			if ( m.mapBumpScale ) {
	
				mpars.bumpScale = m.mapBumpScale;
	
			}
	
			// special case for normal mapped material
	
			if ( m.mapNormal ) {
	
				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
				uniforms[ "tNormal" ].value = mpars.normalMap;
	
				if ( m.mapNormalFactor ) {
	
					uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );
	
				}
	
				if ( mpars.map ) {
	
					uniforms[ "tDiffuse" ].value = mpars.map;
					uniforms[ "enableDiffuse" ].value = true;
	
				}
	
				if ( mpars.specularMap ) {
	
					uniforms[ "tSpecular" ].value = mpars.specularMap;
					uniforms[ "enableSpecular" ].value = true;
	
				}
	
				if ( mpars.lightMap ) {
	
					uniforms[ "tAO" ].value = mpars.lightMap;
					uniforms[ "enableAO" ].value = true;
	
				}
	
				// for the moment don't handle displacement texture
	
				uniforms[ "diffuse" ].value.setHex( mpars.color );
				uniforms[ "specular" ].value.setHex( mpars.specular );
				uniforms[ "ambient" ].value.setHex( mpars.ambient );
	
				uniforms[ "shininess" ].value = mpars.shininess;
	
				if ( mpars.opacity !== undefined ) {
	
					uniforms[ "opacity" ].value = mpars.opacity;
	
				}
	
				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
				var material = new THREE.ShaderMaterial( parameters );
	
				if ( mpars.transparent ) {
	
					material.transparent = true;
	
				}
	
			} else {
	
				var material = new THREE[ mtype ]( mpars );
	
			}
	
			if ( m.DbgName !== undefined ) material.name = m.DbgName;
	
			return material;
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.XHRLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.XHRLoader.prototype = {
	
		constructor: THREE.XHRLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
			var request = new XMLHttpRequest();
	
			if ( onLoad !== undefined ) {
	
				request.addEventListener( 'load', function ( event ) {
	
					onLoad( event.target.responseText );
					scope.manager.itemEnd( url );
	
				}, false );
	
			}
	
			if ( onProgress !== undefined ) {
	
				request.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			if ( onError !== undefined ) {
	
				request.addEventListener( 'error', function ( event ) {
	
					onError( event );
	
				}, false );
	
			}
	
			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
	
			request.open( 'GET', url, true );
			request.send( null );
	
			scope.manager.itemStart( url );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.ImageLoader.prototype = {
	
		constructor: THREE.ImageLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
			var image = document.createElement( 'img' );
	
			if ( onLoad !== undefined ) {
	
				image.addEventListener( 'load', function ( event ) {
	
					scope.manager.itemEnd( url );
					onLoad( this );
	
				}, false );
	
			}
	
			if ( onProgress !== undefined ) {
	
				image.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			if ( onError !== undefined ) {
	
				image.addEventListener( 'error', function ( event ) {
	
					onError( event );
	
				}, false );
	
			}
	
			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
			image.src = url;
	
			scope.manager.itemStart( url );
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( showStatus ) {
	
		THREE.Loader.call( this, showStatus );
	
		this.withCredentials = false;
	
	};
	
	THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
	
	THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {
	
		var scope = this;
	
		// todo: unify load API to for easier SceneLoader use
	
		texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );
	
		this.onLoadStart();
		this.loadAjaxJSON( this, url, callback, texturePath );
	
	};
	
	THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {
	
		var xhr = new XMLHttpRequest();
	
		var length = 0;
	
		xhr.onreadystatechange = function () {
	
			if ( xhr.readyState === xhr.DONE ) {
	
				if ( xhr.status === 200 || xhr.status === 0 ) {
	
					if ( xhr.responseText ) {
	
						var json = JSON.parse( xhr.responseText );
						var result = context.parse( json, texturePath );
						callback( result.geometry, result.materials );
	
					} else {
	
						console.warn( "THREE.JSONLoader: [" + url + "] seems to be unreachable or file there is empty" );
	
					}
	
					// in context of more complex asset initialization
					// do not block on single failed file
					// maybe should go even one more level up
	
					context.onLoadComplete();
	
				} else {
	
					console.error( "THREE.JSONLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );
	
				}
	
			} else if ( xhr.readyState === xhr.LOADING ) {
	
				if ( callbackProgress ) {
	
					if ( length === 0 ) {
	
						length = xhr.getResponseHeader( "Content-Length" );
	
					}
	
					callbackProgress( { total: length, loaded: xhr.responseText.length } );
	
				}
	
			} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {
	
				if ( callbackProgress !== undefined ) {
	
					length = xhr.getResponseHeader( "Content-Length" );
	
				}
	
			}
	
		};
	
		xhr.open( "GET", url, true );
		xhr.withCredentials = this.withCredentials;
		xhr.send( null );
	
	};
	
	THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {
	
		var scope = this,
		geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
		parseModel( scale );
	
		parseSkin();
		parseMorphing( scale );
	
		geometry.computeCentroids();
		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();
	
		function parseModel( scale ) {
	
			function isBitSet( value, position ) {
	
				return value & ( 1 << position );
	
			}
	
			var i, j, fi,
	
			offset, zLength,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,
	
			vertex, face, faceA, faceB, color, hex, normal,
	
			uvLayer, uv, u, v,
	
			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,
	
			nUvLayers = 0;
	
			if ( json.uvs !== undefined ) {
	
				// disregard empty arrays
	
				for ( i = 0; i < json.uvs.length; i++ ) {
	
					if ( json.uvs[ i ].length ) nUvLayers ++;
	
				}
	
				for ( i = 0; i < nUvLayers; i++ ) {
	
					geometry.faceVertexUvs[ i ] = [];
	
				}
	
			}
	
			offset = 0;
			zLength = vertices.length;
	
			while ( offset < zLength ) {
	
				vertex = new THREE.Vector3();
	
				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;
	
				geometry.vertices.push( vertex );
	
			}
	
			offset = 0;
			zLength = faces.length;
	
			while ( offset < zLength ) {
	
				type = faces[ offset ++ ];
	
	
				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	    = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );
	
				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
				if ( isQuad ) {
	
					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];
	
					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];
	
					offset += 4;
	
					if ( hasMaterial ) {
	
						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;
	
					}
	
					// to get face <=> uv index correspondence
	
					fi = geometry.faces.length;
	
					if ( hasFaceVertexUv ) {
	
						for ( i = 0; i < nUvLayers; i++ ) {
	
							uvLayer = json.uvs[ i ];
	
							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = []
	
							for ( j = 0; j < 4; j ++ ) {
	
								uvIndex = faces[ offset ++ ];
	
								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];
	
								uv = new THREE.Vector2( u, v );
	
								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
							}
	
						}
	
					}
	
					if ( hasFaceNormal ) {
	
						normalIndex = faces[ offset ++ ] * 3;
	
						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);
	
						faceB.normal.copy( faceA.normal );
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						for ( i = 0; i < 4; i++ ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
	
							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
						}
	
					}
	
	
					if ( hasFaceColor ) {
	
						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];
	
						faceA.color.setHex( hex );
						faceB.color.setHex( hex );
	
					}
	
	
					if ( hasFaceVertexColor ) {
	
						for ( i = 0; i < 4; i++ ) {
	
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
	
							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );
	
						}
	
					}
	
					geometry.faces.push( faceA );
					geometry.faces.push( faceB );
	
				} else {
	
					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];
	
					if ( hasMaterial ) {
	
						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;
	
					}
	
					// to get face <=> uv index correspondence
	
					fi = geometry.faces.length;
	
					if ( hasFaceVertexUv ) {
	
						for ( i = 0; i < nUvLayers; i++ ) {
	
							uvLayer = json.uvs[ i ];
	
							geometry.faceVertexUvs[ i ][ fi ] = [];
	
							for ( j = 0; j < 3; j ++ ) {
	
								uvIndex = faces[ offset ++ ];
	
								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];
	
								uv = new THREE.Vector2( u, v );
	
								geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
							}
	
						}
	
					}
	
					if ( hasFaceNormal ) {
	
						normalIndex = faces[ offset ++ ] * 3;
	
						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						for ( i = 0; i < 3; i++ ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
							face.vertexNormals.push( normal );
	
						}
	
					}
	
	
					if ( hasFaceColor ) {
	
						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );
	
					}
	
	
					if ( hasFaceVertexColor ) {
	
						for ( i = 0; i < 3; i++ ) {
	
							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );
	
						}
	
					}
	
					geometry.faces.push( face );
	
				}
	
			}
	
		};
	
		function parseSkin() {
	
			var i, l, x, y, z, w, a, b, c, d;
	
			if ( json.skinWeights ) {
	
				for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {
	
					x = json.skinWeights[ i     ];
					y = json.skinWeights[ i + 1 ];
					z = 0;
					w = 0;
	
					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
				}
	
			}
	
			if ( json.skinIndices ) {
	
				for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {
	
					a = json.skinIndices[ i     ];
					b = json.skinIndices[ i + 1 ];
					c = 0;
					d = 0;
	
					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
				}
	
			}
	
			geometry.bones = json.bones;
			// could change this to json.animations[0] or remove completely
			geometry.animation = json.animation;
			geometry.animations = json.animations;
		};
	
		function parseMorphing( scale ) {
	
			if ( json.morphTargets !== undefined ) {
	
				var i, l, v, vl, dstVertices, srcVertices;
	
				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];
	
					dstVertices = geometry.morphTargets[ i ].vertices;
					srcVertices = json.morphTargets [ i ].vertices;
	
					for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;
	
						dstVertices.push( vertex );
	
					}
	
				}
	
			}
	
			if ( json.morphColors !== undefined ) {
	
				var i, l, c, cl, dstColors, srcColors, color;
	
				for ( i = 0, l = json.morphColors.length; i < l; i++ ) {
	
					geometry.morphColors[ i ] = {};
					geometry.morphColors[ i ].name = json.morphColors[ i ].name;
					geometry.morphColors[ i ].colors = [];
	
					dstColors = geometry.morphColors[ i ].colors;
					srcColors = json.morphColors [ i ].colors;
	
					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {
	
						color = new THREE.Color( 0xffaa00 );
						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
						dstColors.push( color );
	
					}
	
				}
	
			}
	
		};
	
		if ( json.materials === undefined ) {
	
			return { geometry: geometry };
	
		} else {
	
			var materials = this.initMaterials( json.materials, texturePath );
	
			if ( this.needsTangents( materials ) ) {
	
				geometry.computeTangents();
	
			}
	
			return { geometry: geometry, materials: materials };
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var loaded = 0, total = 0;
	
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			total ++;
	
		};
	
		this.itemEnd = function ( url ) {
	
			loaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, loaded, total );
	
			}
	
			if ( loaded === total && scope.onLoad !== undefined ) {
	
				scope.onLoad();
	
			}
	
		};
	
	};
	
	THREE.DefaultLoadingManager = new THREE.LoadingManager();
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.BufferGeometryLoader.prototype = {
	
		constructor: THREE.BufferGeometryLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader();
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			var geometry = new THREE.BufferGeometry();
	
			var attributes = json.attributes;
			var offsets = json.offsets;
			var boundingSphere = json.boundingSphere;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				geometry.attributes[ key ] = {
					itemSize: attribute.itemSize,
					array: new self[ attribute.type ]( attribute.array )
				}
	
			}
	
			if ( offsets !== undefined ) {
	
				geometry.offsets = JSON.parse( JSON.stringify( offsets ) );
	
			}
	
			if ( boundingSphere !== undefined ) {
	
				geometry.boundingSphere = new THREE.Sphere(
					new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
					boundingSphere.radius
				);
	
			}
	
			return geometry;
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.GeometryLoader.prototype = {
	
		constructor: THREE.GeometryLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader();
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MaterialLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.MaterialLoader.prototype = {
	
		constructor: THREE.MaterialLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader();
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			var material = new THREE[ json.type ];
	
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
	
			if ( json.materials !== undefined ) {
	
				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
					material.materials.push( this.parse( json.materials[ i ] ) );
	
				}
	
			}
	
			return material;
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ObjectLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.ObjectLoader.prototype = {
	
		constructor: THREE.ObjectLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			var geometries = this.parseGeometries( json.geometries );
			var materials = this.parseMaterials( json.materials );
			var object = this.parseObject( json.object, geometries, materials );
	
			return object;
	
		},
	
		parseGeometries: function ( json ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
	
							geometry = new THREE.PlaneGeometry(
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'CircleGeometry':
	
							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments
							);
	
							break;
	
						case 'CubeGeometry':
	
							geometry = new THREE.CubeGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CylinderGeometry':
	
							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded
							);
	
							break;
	
						case 'SphereGeometry':
	
							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'IcosahedronGeometry':
	
							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'TorusGeometry':
	
							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
	
							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data.data );
	
							break;
	
						case 'Geometry':
	
							geometry = geometryLoader.parse( data.data ).geometry;
	
							break;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json ) {
	
			var materials = {};
	
			if ( json !== undefined ) {
	
				var loader = new THREE.MaterialLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
					var material = loader.parse( data );
	
					material.uuid = data.uuid;
	
					if ( data.name !== undefined ) material.name = data.name;
	
					materials[ data.uuid ] = material;
	
				}
	
			}
	
			return materials;
	
		},
	
		parseObject: function () {
	
			var matrix = new THREE.Matrix4();
	
			return function ( data, geometries, materials ) {
	
				var object;
	
				switch ( data.type ) {
	
					case 'Scene':
	
						object = new THREE.Scene();
	
						break;
	
					case 'PerspectiveCamera':
	
						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
						break;
	
					case 'OrthographicCamera':
	
						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
						break;
	
					case 'AmbientLight':
	
						object = new THREE.AmbientLight( data.color );
	
						break;
	
					case 'DirectionalLight':
	
						object = new THREE.DirectionalLight( data.color, data.intensity );
	
						break;
	
					case 'PointLight':
	
						object = new THREE.PointLight( data.color, data.intensity, data.distance );
	
						break;
	
					case 'SpotLight':
	
						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );
	
						break;
	
					case 'HemisphereLight':
	
						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );
	
						break;
	
					case 'Mesh':
	
						var geometry = geometries[ data.geometry ];
						var material = materials[ data.material ];
	
						if ( geometry === undefined ) {
	
							console.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );
	
						}
	
						if ( material === undefined ) {
	
							console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );
	
						}
	
						object = new THREE.Mesh( geometry, material );
	
						break;
	
					case 'Sprite':
	
						var material = materials[ data.material ];
	
						if ( material === undefined ) {
	
							console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );
	
						}
	
						object = new THREE.Sprite( material );
	
						break;
	
					default:
	
						object = new THREE.Object3D();
	
				}
	
				object.uuid = data.uuid;
	
				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {
	
					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );
	
				} else {
	
					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
				}
	
				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;
	
				if ( data.children !== undefined ) {
	
					for ( var child in data.children ) {
	
						object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
					}
	
				}
	
				return object;
	
			}
	
		}()
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneLoader = function () {
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function() {};
		this.onLoadComplete = function () {};
	
		this.callbackSync = function () {};
		this.callbackProgress = function () {};
	
		this.geometryHandlers = {};
		this.hierarchyHandlers = {};
	
		this.addGeometryHandler( "ascii", THREE.JSONLoader );
	
	};
	
	THREE.SceneLoader.prototype = {
	
		constructor: THREE.SceneLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				scope.parse( JSON.parse( text ), onLoad, url );
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		addGeometryHandler: function ( typeID, loaderClass ) {
	
			this.geometryHandlers[ typeID ] = { "loaderClass": loaderClass };
	
		},
	
		addHierarchyHandler: function ( typeID, loaderClass ) {
	
			this.hierarchyHandlers[ typeID ] = { "loaderClass": loaderClass };
	
		},
	
		parse: function ( json, callbackFinished, url ) {
	
			var scope = this;
	
			var urlBase = THREE.Loader.prototype.extractUrlBase( url );
	
			var geometry, material, camera, fog,
				texture, images, color,
				light, hex, intensity,
				counter_models, counter_textures,
				total_models, total_textures,
				result;
	
			var target_array = [];
	
			var data = json;
	
			// async geometry loaders
	
			for ( var typeID in this.geometryHandlers ) {
	
				var loaderClass = this.geometryHandlers[ typeID ][ "loaderClass" ];
				this.geometryHandlers[ typeID ][ "loaderObject" ] = new loaderClass();
	
			}
	
			// async hierachy loaders
	
			for ( var typeID in this.hierarchyHandlers ) {
	
				var loaderClass = this.hierarchyHandlers[ typeID ][ "loaderClass" ];
				this.hierarchyHandlers[ typeID ][ "loaderObject" ] = new loaderClass();
	
			}
	
			counter_models = 0;
			counter_textures = 0;
	
			result = {
	
				scene: new THREE.Scene(),
				geometries: {},
				face_materials: {},
				materials: {},
				textures: {},
				objects: {},
				cameras: {},
				lights: {},
				fogs: {},
				empties: {},
				groups: {}
	
			};
	
			if ( data.transform ) {
	
				var position = data.transform.position,
					rotation = data.transform.rotation,
					scale = data.transform.scale;
	
				if ( position ) {
	
					result.scene.position.fromArray( position );
	
				}
	
				if ( rotation ) {
	
					result.scene.rotation.fromArray( rotation );
	
				}
	
				if ( scale ) {
	
					result.scene.scale.fromArray( scale );
	
				}
	
				if ( position || rotation || scale ) {
	
					result.scene.updateMatrix();
					result.scene.updateMatrixWorld();
	
				}
	
			}
	
			function get_url( source_url, url_type ) {
	
				if ( url_type == "relativeToHTML" ) {
	
					return source_url;
	
				} else {
	
					return urlBase + "/" + source_url;
	
				}
	
			};
	
			// toplevel loader function, delegates to handle_children
	
			function handle_objects() {
	
				handle_children( result.scene, data.objects );
	
			}
	
			// handle all the children from the loaded json and attach them to given parent
	
			function handle_children( parent, children ) {
	
				var mat, dst, pos, rot, scl, quat;
	
				for ( var objID in children ) {
	
					// check by id if child has already been handled,
					// if not, create new object
	
					var object = result.objects[ objID ];
					var objJSON = children[ objID ];
	
					if ( object === undefined ) {
	
						// meshes
	
						if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {
	
							if ( objJSON.loading === undefined ) {
	
								var reservedTypes = {
									"type": 1, "url": 1, "material": 1,
									"position": 1, "rotation": 1, "scale" : 1,
									"visible": 1, "children": 1, "userData": 1,
									"skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1
								};
	
								var loaderParameters = {};
	
								for ( var parType in objJSON ) {
	
									if ( ! ( parType in reservedTypes ) ) {
	
										loaderParameters[ parType ] = objJSON[ parType ];
	
									}
	
								}
	
								material = result.materials[ objJSON.material ];
	
								objJSON.loading = true;
	
								var loader = scope.hierarchyHandlers[ objJSON.type ][ "loaderObject" ];
	
								// ColladaLoader
	
								if ( loader.options ) {
	
									loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );
	
								// UTF8Loader
								// OBJLoader
	
								} else {
	
									loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );
	
								}
	
							}
	
						} else if ( objJSON.geometry !== undefined ) {
	
							geometry = result.geometries[ objJSON.geometry ];
	
							// geometry already loaded
	
							if ( geometry ) {
	
								var needsTangents = false;
	
								material = result.materials[ objJSON.material ];
								needsTangents = material instanceof THREE.ShaderMaterial;
	
								pos = objJSON.position;
								rot = objJSON.rotation;
								scl = objJSON.scale;
								mat = objJSON.matrix;
								quat = objJSON.quaternion;
	
								// use materials from the model file
								// if there is no material specified in the object
	
								if ( ! objJSON.material ) {
	
									material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );
	
								}
	
								// use materials from the model file
								// if there is just empty face material
								// (must create new material as each model has its own face material)
	
								if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {
	
									material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );
	
								}
	
								if ( material instanceof THREE.MeshFaceMaterial ) {
	
									for ( var i = 0; i < material.materials.length; i ++ ) {
	
										needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );
	
									}
	
								}
	
								if ( needsTangents ) {
	
									geometry.computeTangents();
	
								}
	
								if ( objJSON.skin ) {
	
									object = new THREE.SkinnedMesh( geometry, material );
	
								} else if ( objJSON.morph ) {
	
									object = new THREE.MorphAnimMesh( geometry, material );
	
									if ( objJSON.duration !== undefined ) {
	
										object.duration = objJSON.duration;
	
									}
	
									if ( objJSON.time !== undefined ) {
	
										object.time = objJSON.time;
	
									}
	
									if ( objJSON.mirroredLoop !== undefined ) {
	
										object.mirroredLoop = objJSON.mirroredLoop;
	
									}
	
									if ( material.morphNormals ) {
	
										geometry.computeMorphNormals();
	
									}
	
								} else {
	
									object = new THREE.Mesh( geometry, material );
	
								}
	
								object.name = objID;
	
								if ( mat ) {
	
									object.matrixAutoUpdate = false;
									object.matrix.set(
										mat[0],  mat[1],  mat[2],  mat[3],
										mat[4],  mat[5],  mat[6],  mat[7],
										mat[8],  mat[9],  mat[10], mat[11],
										mat[12], mat[13], mat[14], mat[15]
									);
	
								} else {
	
									object.position.fromArray( pos );
	
									if ( quat ) {
	
										object.quaternion.fromArray( quat );
	
									} else {
	
										object.rotation.fromArray( rot );
	
									}
	
									object.scale.fromArray( scl );
	
								}
	
								object.visible = objJSON.visible;
								object.castShadow = objJSON.castShadow;
								object.receiveShadow = objJSON.receiveShadow;
	
								parent.add( object );
	
								result.objects[ objID ] = object;
	
							}
	
						// lights
	
						} else if ( objJSON.type === "AmbientLight" || objJSON.type === "PointLight" ||
							objJSON.type === "DirectionalLight" || objJSON.type === "SpotLight" ||
							objJSON.type === "HemisphereLight" || objJSON.type === "AreaLight" ) {
	
							var color = objJSON.color;
							var intensity = objJSON.intensity;
							var distance = objJSON.distance;
							var position = objJSON.position;
							var rotation = objJSON.rotation;
	
							switch ( objJSON.type ) {
	
								case 'AmbientLight':
									light = new THREE.AmbientLight( color );
									break;
	
								case 'PointLight':
									light = new THREE.PointLight( color, intensity, distance );
									light.position.fromArray( position );
									break;
	
								case 'DirectionalLight':
									light = new THREE.DirectionalLight( color, intensity );
									light.position.fromArray( objJSON.direction );
									break;
	
								case 'SpotLight':
									light = new THREE.SpotLight( color, intensity, distance, 1 );
									light.angle = objJSON.angle;
									light.position.fromArray( position );
									light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
									light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
									break;
	
								case 'HemisphereLight':
									light = new THREE.DirectionalLight( color, intensity, distance );
									light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
									light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
									break;
	
								case 'AreaLight':
									light = new THREE.AreaLight(color, intensity);
									light.position.fromArray( position );
									light.width = objJSON.size;
									light.height = objJSON.size_y;
									break;
	
							}
	
							parent.add( light );
	
							light.name = objID;
							result.lights[ objID ] = light;
							result.objects[ objID ] = light;
	
						// cameras
	
						} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {
	
							pos = objJSON.position;
							rot = objJSON.rotation;
							quat = objJSON.quaternion;
	
							if ( objJSON.type === "PerspectiveCamera" ) {
	
								camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );
	
							} else if ( objJSON.type === "OrthographicCamera" ) {
	
								camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );
	
							}
	
							camera.name = objID;
							camera.position.fromArray( pos );
	
							if ( quat !== undefined ) {
	
								camera.quaternion.fromArray( quat );
	
							} else if ( rot !== undefined ) {
	
								camera.rotation.fromArray( rot );
	
							}
	
							parent.add( camera );
	
							result.cameras[ objID ] = camera;
							result.objects[ objID ] = camera;
	
						// pure Object3D
	
						} else {
	
							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							quat = objJSON.quaternion;
	
							object = new THREE.Object3D();
							object.name = objID;
							object.position.fromArray( pos );
	
							if ( quat ) {
	
								object.quaternion.fromArray( quat );
	
							} else {
	
								object.rotation.fromArray( rot );
	
							}
	
							object.scale.fromArray( scl );
							object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;
	
							parent.add( object );
	
							result.objects[ objID ] = object;
							result.empties[ objID ] = object;
	
						}
	
						if ( object ) {
	
							if ( objJSON.userData !== undefined ) {
	
								for ( var key in objJSON.userData ) {
	
									var value = objJSON.userData[ key ];
									object.userData[ key ] = value;
	
								}
	
							}
	
							if ( objJSON.groups !== undefined ) {
	
								for ( var i = 0; i < objJSON.groups.length; i ++ ) {
	
									var groupID = objJSON.groups[ i ];
	
									if ( result.groups[ groupID ] === undefined ) {
	
										result.groups[ groupID ] = [];
	
									}
	
									result.groups[ groupID ].push( objID );
	
								}
	
							}
	
						}
	
					}
	
					if ( object !== undefined && objJSON.children !== undefined ) {
	
						handle_children( object, objJSON.children );
	
					}
	
				}
	
			};
	
			function handle_mesh( geo, mat, id ) {
	
				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;
				handle_objects();
	
			};
	
			function handle_hierarchy( node, id, parent, material, obj ) {
	
				var p = obj.position;
				var r = obj.rotation;
				var q = obj.quaternion;
				var s = obj.scale;
	
				node.position.fromArray( p );
	
				if ( q ) {
	
					node.quaternion.fromArray( q );
	
				} else {
	
					node.rotation.fromArray( r );
	
				}
	
				node.scale.fromArray( s );
	
				// override children materials
				// if object material was specified in JSON explicitly
	
				if ( material ) {
	
					node.traverse( function ( child ) {
	
						child.material = material;
	
					} );
	
				}
	
				// override children visibility
				// with root node visibility as specified in JSON
	
				var visible = ( obj.visible !== undefined ) ? obj.visible : true;
	
				node.traverse( function ( child ) {
	
					child.visible = visible;
	
				} );
	
				parent.add( node );
	
				node.name = id;
	
				result.objects[ id ] = node;
				handle_objects();
	
			};
	
			function create_callback_geometry( id ) {
	
				return function ( geo, mat ) {
	
					geo.name = id;
	
					handle_mesh( geo, mat, id );
	
					counter_models -= 1;
	
					scope.onLoadComplete();
	
					async_callback_gate();
	
				}
	
			};
	
			function create_callback_hierachy( id, parent, material, obj ) {
	
				return function ( event ) {
	
					var result;
	
					// loaders which use EventDispatcher
	
					if ( event.content ) {
	
						result = event.content;
	
					// ColladaLoader
	
					} else if ( event.dae ) {
	
						result = event.scene;
	
	
					// UTF8Loader
	
					} else {
	
						result = event;
	
					}
	
					handle_hierarchy( result, id, parent, material, obj );
	
					counter_models -= 1;
	
					scope.onLoadComplete();
	
					async_callback_gate();
	
				}
	
			};
	
			function create_callback_embed( id ) {
	
				return function ( geo, mat ) {
	
					geo.name = id;
	
					result.geometries[ id ] = geo;
					result.face_materials[ id ] = mat;
	
				}
	
			};
	
			function async_callback_gate() {
	
				var progress = {
	
					totalModels : total_models,
					totalTextures : total_textures,
					loadedModels : total_models - counter_models,
					loadedTextures : total_textures - counter_textures
	
				};
	
				scope.callbackProgress( progress, result );
	
				scope.onLoadProgress();
	
				if ( counter_models === 0 && counter_textures === 0 ) {
	
					finalize();
					callbackFinished( result );
	
				}
	
			};
	
			function finalize() {
	
				// take care of targets which could be asynchronously loaded objects
	
				for ( var i = 0; i < target_array.length; i ++ ) {
	
					var ta = target_array[ i ];
	
					var target = result.objects[ ta.targetName ];
	
					if ( target ) {
	
						ta.object.target = target;
	
					} else {
	
						// if there was error and target of specified name doesn't exist in the scene file
						// create instead dummy target
						// (target must be added to scene explicitly as parent is already added)
	
						ta.object.target = new THREE.Object3D();
						result.scene.add( ta.object.target );
	
					}
	
					ta.object.target.userData.targetInverse = ta.object;
	
				}
	
			};
	
			var callbackTexture = function ( count ) {
	
				counter_textures -= count;
				async_callback_gate();
	
				scope.onLoadComplete();
	
			};
	
			// must use this instead of just directly calling callbackTexture
			// because of closure in the calling context loop
	
			var generateTextureCallback = function ( count ) {
	
				return function () {
	
					callbackTexture( count );
	
				};
	
			};
	
			function traverse_json_hierarchy( objJSON, callback ) {
	
				callback( objJSON );
	
				if ( objJSON.children !== undefined ) {
	
					for ( var objChildID in objJSON.children ) {
	
						traverse_json_hierarchy( objJSON.children[ objChildID ], callback );
	
					}
	
				}
	
			};
	
			// first go synchronous elements
	
			// fogs
	
			var fogID, fogJSON;
	
			for ( fogID in data.fogs ) {
	
				fogJSON = data.fogs[ fogID ];
	
				if ( fogJSON.type === "linear" ) {
	
					fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );
	
				} else if ( fogJSON.type === "exp2" ) {
	
					fog = new THREE.FogExp2( 0x000000, fogJSON.density );
	
				}
	
				color = fogJSON.color;
				fog.color.setRGB( color[0], color[1], color[2] );
	
				result.fogs[ fogID ] = fog;
	
			}
	
			// now come potentially asynchronous elements
	
			// geometries
	
			// count how many geometries will be loaded asynchronously
	
			var geoID, geoJSON;
	
			for ( geoID in data.geometries ) {
	
				geoJSON = data.geometries[ geoID ];
	
				if ( geoJSON.type in this.geometryHandlers ) {
	
					counter_models += 1;
	
					scope.onLoadStart();
	
				}
	
			}
	
			// count how many hierarchies will be loaded asynchronously
	
			for ( var objID in data.objects ) {
	
				traverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {
	
					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {
	
						counter_models += 1;
	
						scope.onLoadStart();
	
					}
	
				});
	
			}
	
			total_models = counter_models;
	
			for ( geoID in data.geometries ) {
	
				geoJSON = data.geometries[ geoID ];
	
				if ( geoJSON.type === "cube" ) {
	
					geometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
					geometry.name = geoID;
					result.geometries[ geoID ] = geometry;
	
				} else if ( geoJSON.type === "plane" ) {
	
					geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
					geometry.name = geoID;
					result.geometries[ geoID ] = geometry;
	
				} else if ( geoJSON.type === "sphere" ) {
	
					geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
					geometry.name = geoID;
					result.geometries[ geoID ] = geometry;
	
				} else if ( geoJSON.type === "cylinder" ) {
	
					geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
					geometry.name = geoID;
					result.geometries[ geoID ] = geometry;
	
				} else if ( geoJSON.type === "torus" ) {
	
					geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
					geometry.name = geoID;
					result.geometries[ geoID ] = geometry;
	
				} else if ( geoJSON.type === "icosahedron" ) {
	
					geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
					geometry.name = geoID;
					result.geometries[ geoID ] = geometry;
	
				} else if ( geoJSON.type in this.geometryHandlers ) {
	
					var loaderParameters = {};
	
					for ( var parType in geoJSON ) {
	
						if ( parType !== "type" && parType !== "url" ) {
	
							loaderParameters[ parType ] = geoJSON[ parType ];
	
						}
	
					}
	
					var loader = this.geometryHandlers[ geoJSON.type ][ "loaderObject" ];
					loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );
	
				} else if ( geoJSON.type === "embedded" ) {
	
					var modelJson = data.embeds[ geoJSON.id ],
						texture_path = "";
	
					// pass metadata along to jsonLoader so it knows the format version
	
					modelJson.metadata = data.metadata;
	
					if ( modelJson ) {
	
						var jsonLoader = this.geometryHandlers[ "ascii" ][ "loaderObject" ];
						var model = jsonLoader.parse( modelJson, texture_path );
						create_callback_embed( geoID )( model.geometry, model.materials );
	
					}
	
				}
	
			}
	
			// textures
	
			// count how many textures will be loaded asynchronously
	
			var textureID, textureJSON;
	
			for ( textureID in data.textures ) {
	
				textureJSON = data.textures[ textureID ];
	
				if ( textureJSON.url instanceof Array ) {
	
					counter_textures += textureJSON.url.length;
	
					for( var n = 0; n < textureJSON.url.length; n ++ ) {
	
						scope.onLoadStart();
	
					}
	
				} else {
	
					counter_textures += 1;
	
					scope.onLoadStart();
	
				}
	
			}
	
			total_textures = counter_textures;
	
			for ( textureID in data.textures ) {
	
				textureJSON = data.textures[ textureID ];
	
				if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {
	
					textureJSON.mapping = new THREE[ textureJSON.mapping ]();
	
				}
	
				if ( textureJSON.url instanceof Array ) {
	
					var count = textureJSON.url.length;
					var url_array = [];
	
					for( var i = 0; i < count; i ++ ) {
	
						url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );
	
					}
	
					var isCompressed = /\.dds$/i.test( url_array[ 0 ] );
	
					if ( isCompressed ) {
	
						texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );
	
					} else {
	
						texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );
	
					}
	
				} else {
	
					var isCompressed = /\.dds$/i.test( textureJSON.url );
					var fullUrl = get_url( textureJSON.url, data.urlBaseType );
					var textureCallback = generateTextureCallback( 1 );
	
					if ( isCompressed ) {
	
						texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );
	
					} else {
	
						texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );
	
					}
	
					if ( THREE[ textureJSON.minFilter ] !== undefined )
						texture.minFilter = THREE[ textureJSON.minFilter ];
	
					if ( THREE[ textureJSON.magFilter ] !== undefined )
						texture.magFilter = THREE[ textureJSON.magFilter ];
	
					if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;
	
					if ( textureJSON.repeat ) {
	
						texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );
	
						if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
					}
	
					if ( textureJSON.offset ) {
	
						texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );
	
					}
	
					// handle wrap after repeat so that default repeat can be overriden
	
					if ( textureJSON.wrap ) {
	
						var wrapMap = {
							"repeat": THREE.RepeatWrapping,
							"mirror": THREE.MirroredRepeatWrapping
						}
	
						if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
						if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];
	
					}
	
				}
	
				result.textures[ textureID ] = texture;
	
			}
	
			// materials
	
			var matID, matJSON;
			var parID;
	
			for ( matID in data.materials ) {
	
				matJSON = data.materials[ matID ];
	
				for ( parID in matJSON.parameters ) {
	
					if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {
	
						matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];
	
					} else if ( parID === "shading" ) {
	
						matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;
	
					} else if ( parID === "side" ) {
	
						if ( matJSON.parameters[ parID ] == "double" ) {
	
							matJSON.parameters[ parID ] = THREE.DoubleSide;
	
						} else if ( matJSON.parameters[ parID ] == "back" ) {
	
							matJSON.parameters[ parID ] = THREE.BackSide;
	
						} else {
	
							matJSON.parameters[ parID ] = THREE.FrontSide;
	
						}
	
					} else if ( parID === "blending" ) {
	
						matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;
	
					} else if ( parID === "combine" ) {
	
						matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;
	
					} else if ( parID === "vertexColors" ) {
	
						if ( matJSON.parameters[ parID ] == "face" ) {
	
							matJSON.parameters[ parID ] = THREE.FaceColors;
	
						// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false
	
						} else if ( matJSON.parameters[ parID ] ) {
	
							matJSON.parameters[ parID ] = THREE.VertexColors;
	
						}
	
					} else if ( parID === "wrapRGB" ) {
	
						var v3 = matJSON.parameters[ parID ];
						matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );
	
					}
	
				}
	
				if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {
	
					matJSON.parameters.transparent = true;
	
				}
	
				if ( matJSON.parameters.normalMap ) {
	
					var shader = THREE.ShaderLib[ "normalmap" ];
					var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
					var diffuse = matJSON.parameters.color;
					var specular = matJSON.parameters.specular;
					var ambient = matJSON.parameters.ambient;
					var shininess = matJSON.parameters.shininess;
	
					uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];
	
					if ( matJSON.parameters.normalScale ) {
	
						uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );
	
					}
	
					if ( matJSON.parameters.map ) {
	
						uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
						uniforms[ "enableDiffuse" ].value = true;
	
					}
	
					if ( matJSON.parameters.envMap ) {
	
						uniforms[ "tCube" ].value = matJSON.parameters.envMap;
						uniforms[ "enableReflection" ].value = true;
						uniforms[ "reflectivity" ].value = matJSON.parameters.reflectivity;
	
					}
	
					if ( matJSON.parameters.lightMap ) {
	
						uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
						uniforms[ "enableAO" ].value = true;
	
					}
	
					if ( matJSON.parameters.specularMap ) {
	
						uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
						uniforms[ "enableSpecular" ].value = true;
	
					}
	
					if ( matJSON.parameters.displacementMap ) {
	
						uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
						uniforms[ "enableDisplacement" ].value = true;
	
						uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
						uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;
	
					}
	
					uniforms[ "diffuse" ].value.setHex( diffuse );
					uniforms[ "specular" ].value.setHex( specular );
					uniforms[ "ambient" ].value.setHex( ambient );
	
					uniforms[ "shininess" ].value = shininess;
	
					if ( matJSON.parameters.opacity ) {
	
						uniforms[ "opacity" ].value = matJSON.parameters.opacity;
	
					}
	
					var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
	
					material = new THREE.ShaderMaterial( parameters );
	
				} else {
	
					material = new THREE[ matJSON.type ]( matJSON.parameters );
	
				}
	
				material.name = matID;
	
				result.materials[ matID ] = material;
	
			}
	
			// second pass through all materials to initialize MeshFaceMaterials
			// that could be referring to other materials out of order
	
			for ( matID in data.materials ) {
	
				matJSON = data.materials[ matID ];
	
				if ( matJSON.parameters.materials ) {
	
					var materialArray = [];
	
					for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {
	
						var label = matJSON.parameters.materials[ i ];
						materialArray.push( result.materials[ label ] );
	
					}
	
					result.materials[ matID ].materials = materialArray;
	
				}
	
			}
	
			// objects ( synchronous init of procedural primitives )
	
			handle_objects();
	
			// defaults
	
			if ( result.cameras && data.defaults.camera ) {
	
				result.currentCamera = result.cameras[ data.defaults.camera ];
	
			}
	
			if ( result.fogs && data.defaults.fog ) {
	
				result.scene.fog = result.fogs[ data.defaults.fog ];
	
			}
	
			// synchronous callback
	
			scope.callbackSync( result );
	
			// just in case there are no async elements
	
			async_callback_gate();
	
		}
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.TextureLoader.prototype = {
	
		constructor: THREE.TextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {
	
				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		this.id = THREE.MaterialIdCount ++;
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
	
		this.side = THREE.FrontSide;
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blending = THREE.NormalBlending;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
	
		this.depthTest = true;
		this.depthWrite = true;
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
	
		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this.needsUpdate = true;
	
	};
	
	THREE.Material.prototype = {
	
		constructor: THREE.Material,
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
					continue;
	
				}
	
				if ( key in this ) {
	
					var currentValue = this[ key ];
	
					if ( currentValue instanceof THREE.Color ) {
	
						currentValue.set( newValue );
	
					} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
						currentValue.copy( newValue );
	
					} else if ( key == 'overdraw') {
	
						// ensure overdraw is backwards-compatable with legacy boolean type
						this[ key ] = Number(newValue);
	
					} else {
	
						this[ key ] = newValue;
	
					}
	
				}
	
			}
	
		},
	
		clone: function ( material ) {
	
			if ( material === undefined ) material = new THREE.Material();
	
			material.name = this.name;
	
			material.side = this.side;
	
			material.opacity = this.opacity;
			material.transparent = this.transparent;
	
			material.blending = this.blending;
	
			material.blendSrc = this.blendSrc;
			material.blendDst = this.blendDst;
			material.blendEquation = this.blendEquation;
	
			material.depthTest = this.depthTest;
			material.depthWrite = this.depthWrite;
	
			material.polygonOffset = this.polygonOffset;
			material.polygonOffsetFactor = this.polygonOffsetFactor;
			material.polygonOffsetUnits = this.polygonOffsetUnits;
	
			material.alphaTest = this.alphaTest;
	
			material.overdraw = this.overdraw;
	
			material.visible = this.visible;
	
			return material;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );
	
	THREE.MaterialIdCount = 0;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.LineBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.LineBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.linewidth = this.linewidth;
		material.linecap = this.linecap;
		material.linejoin = this.linejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.LineDashedMaterial.prototype.clone = function () {
	
		var material = new THREE.LineDashedMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.linewidth = this.linewidth;
	
		material.scale = this.scale;
		material.dashSize = this.dashSize;
		material.gapSize = this.gapSize;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.lightMap = null;
	
		this.specularMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.specularMap = this.specularMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  ambient: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.ambient = new THREE.Color( 0xffffff );
		this.emissive = new THREE.Color( 0x000000 );
	
		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
	
		this.map = null;
	
		this.lightMap = null;
	
		this.specularMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshLambertMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshLambertMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.ambient.copy( this.ambient );
		material.emissive.copy( this.emissive );
	
		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.specularMap = this.specularMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  ambient: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.ambient = new THREE.Color( 0xffffff );
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.metal = false;
		this.perPixel = true;
	
		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
	
		this.map = null;
	
		this.lightMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.specularMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshPhongMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshPhongMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.ambient.copy( this.ambient );
		material.emissive.copy( this.emissive );
		material.specular.copy( this.specular );
		material.shininess = this.shininess;
	
		material.metal = this.metal;
		material.perPixel = this.perPixel;
	
		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.bumpMap = this.bumpMap;
		material.bumpScale = this.bumpScale;
	
		material.normalMap = this.normalMap;
		material.normalScale.copy( this.normalScale );
	
		material.specularMap = this.specularMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshDepthMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshDepthMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.shading = THREE.FlatShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshNormalMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshNormalMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MeshFaceMaterial = function ( materials ) {
	
		this.materials = materials instanceof Array ? materials : [];
	
	};
	
	THREE.MeshFaceMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshFaceMaterial();
	
		for ( var i = 0; i < this.materials.length; i ++ ) {
	
			material.materials.push( this.materials[ i ].clone() );
	
		}
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.ParticleSystemMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.ParticleSystemMaterial.prototype.clone = function () {
	
		var material = new THREE.ParticleSystemMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.map = this.map;
	
		material.size = this.size;
		material.sizeAttenuation = this.sizeAttenuation;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	// backwards compatibility
	
	THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  defines: { "label" : "value" },
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.fragmentShader = "void main() {}";
		this.vertexShader = "void main() {}";
		this.uniforms = {};
		this.defines = {};
		this.attributes = null;
	
		this.shading = THREE.SmoothShading;
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
	
		this.lights = false; // set to use scene lights
	
		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream
	
		this.skinning = false; // set to use skinning attribute streams
	
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			"color" : [ 1, 1, 1],
			"uv" : [ 0, 0 ],
			"uv2" : [ 0, 0 ]
		};
	
		// By default, bind position to attribute index 0. In WebGL, attribute 0
		// should always be used to avoid potentially expensive emulation.
		this.index0AttributeName = "position";
	
		this.setValues( parameters );
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.ShaderMaterial.prototype.clone = function () {
	
		var material = new THREE.ShaderMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.fragmentShader = this.fragmentShader;
		material.vertexShader = this.vertexShader;
	
		material.uniforms = THREE.UniformsUtils.clone( this.uniforms );
	
		material.attributes = this.attributes;
		material.defines = this.defines;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		material.fog = this.fog;
	
		material.lights = this.lights;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
	
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		// defaults
	
		this.color = new THREE.Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.fog = false;
	
		// set parameters
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.SpriteMaterial.prototype.clone = function () {
	
		var material = new THREE.SpriteMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.map = this.map;
	
		material.rotation = this.rotation;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  program: <function>,
	 *  opacity: <float>,
	 *  blending: THREE.NormalBlending
	 * }
	 */
	
	THREE.SpriteCanvasMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
		this.program = function ( context, color ) {};
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.SpriteCanvasMaterial.prototype.clone = function () {
	
		var material = new THREE.SpriteCanvasMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.program = this.program;
	
		return material;
	
	};
	
	// backwards compatibility
	
	THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		this.id = THREE.TextureIdCount ++;
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
	
		this.image = image;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		this._needsUpdate = false;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		get needsUpdate () {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.update();
	
			this._needsUpdate = value;
	
		},
	
		clone: function ( texture ) {
	
			if ( texture === undefined ) texture = new THREE.Texture();
	
			texture.image = this.image;
			texture.mipmaps = this.mipmaps.slice(0);
	
			texture.mapping = this.mapping;
	
			texture.wrapS = this.wrapS;
			texture.wrapT = this.wrapT;
	
			texture.magFilter = this.magFilter;
			texture.minFilter = this.minFilter;
	
			texture.anisotropy = this.anisotropy;
	
			texture.format = this.format;
			texture.type = this.type;
	
			texture.offset.copy( this.offset );
			texture.repeat.copy( this.repeat );
	
			texture.generateMipmaps = this.generateMipmaps;
			texture.premultiplyAlpha = this.premultiplyAlpha;
			texture.flipY = this.flipY;
			texture.unpackAlignment = this.unpackAlignment;
	
			return texture;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );
	
	THREE.TextureIdCount = 0;
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	
	THREE.CompressedTexture.prototype.clone = function () {
	
		var texture = new THREE.CompressedTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		return texture;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { data: data, width: width, height: height };
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	
	THREE.DataTexture.prototype.clone = function () {
	
		var texture = new THREE.DataTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		return texture;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ParticleSystem = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );
	
		this.sortParticles = false;
		this.frustumCulled = false;
	
	};
	
	THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.ParticleSystem.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );
	
		object.sortParticles = this.sortParticles;
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, type ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.type = ( type !== undefined ) ? type : THREE.LineStrip;
	
	};
	
	THREE.LineStrip = 0;
	THREE.LinePieces = 1;
	
	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Line.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.updateMorphTargets();
	
	};
	
	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Mesh.prototype.updateMorphTargets = function () {
	
		if ( this.geometry.morphTargets.length > 0 ) {
	
			this.morphTargetBase = -1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
	
			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
			}
	
		}
	
	};
	
	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {
	
		if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
			return this.morphTargetDictionary[ name ];
	
		}
	
		console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );
	
		return 0;
	
	};
	
	THREE.Mesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Bone = function( belongsToSkin ) {
	
		THREE.Object3D.call( this );
	
		this.skin = belongsToSkin;
		this.skinMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {
	
		// update local
	
		if ( this.matrixAutoUpdate ) {
	
			forceUpdate |= this.updateMatrix();
	
		}
	
		// update skin matrix
	
		if ( forceUpdate || this.matrixWorldNeedsUpdate ) {
	
			if( parentSkinMatrix ) {
	
				this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );
	
			} else {
	
				this.skinMatrix.copy( this.matrix );
	
			}
	
			this.matrixWorldNeedsUpdate = false;
			forceUpdate = true;
	
		}
	
		// update children
	
		var child, i, l = this.children.length;
	
		for ( i = 0; i < l; i ++ ) {
	
			this.children[ i ].update( this.skinMatrix, forceUpdate );
	
		}
	
	};
	
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		//
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		// init bones
	
		this.identityMatrix = new THREE.Matrix4();
	
		this.bones = [];
		this.boneMatrices = [];
	
		var b, bone, gbone, p, q, s;
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			for ( b = 0; b < this.geometry.bones.length; b ++ ) {
	
				gbone = this.geometry.bones[ b ];
	
				p = gbone.pos;
				q = gbone.rotq;
				s = gbone.scl;
	
				bone = this.addBone();
	
				bone.name = gbone.name;
				bone.position.set( p[0], p[1], p[2] );
				bone.quaternion.set( q[0], q[1], q[2], q[3] );
			
				if ( s !== undefined ) {
	
					bone.scale.set( s[0], s[1], s[2] );
	
				} else {
	
					bone.scale.set( 1, 1, 1 );
	
				}
	
			}
	
			for ( b = 0; b < this.bones.length; b ++ ) {
	
				gbone = this.geometry.bones[ b ];
				bone = this.bones[ b ];
	
				if ( gbone.parent === -1 ) {
	
					this.add( bone );
	
				} else {
	
					this.bones[ gbone.parent ].add( bone );
	
				}
	
			}
	
			//
	
			var nBones = this.bones.length;
	
			if ( this.useVertexTexture ) {
	
				// layout (1 matrix = 4 pixels)
				//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
				//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
				//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
				//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)
	
				var size;
	
				if ( nBones > 256 )
					size = 64;
				else if ( nBones > 64 )
					size = 32;
				else if ( nBones > 16 )
					size = 16;
				else
					size = 8;
	
				this.boneTextureWidth = size;
				this.boneTextureHeight = size;
	
				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
				this.boneTexture.minFilter = THREE.NearestFilter;
				this.boneTexture.magFilter = THREE.NearestFilter;
				this.boneTexture.generateMipmaps = false;
				this.boneTexture.flipY = false;
	
			} else {
	
				this.boneMatrices = new Float32Array( 16 * nBones );
	
			}
	
			this.pose();
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.SkinnedMesh.prototype.addBone = function( bone ) {
	
		if ( bone === undefined ) {
	
			bone = new THREE.Bone( this );
	
		}
	
		this.bones.push( bone );
	
		return bone;
	
	};
	
	THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
	
		var offsetMatrix = new THREE.Matrix4();
	
		return function ( force ) {
	
			this.matrixAutoUpdate && this.updateMatrix();
	
			// update matrixWorld
	
			if ( this.matrixWorldNeedsUpdate || force ) {
	
				if ( this.parent ) {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				} else {
	
					this.matrixWorld.copy( this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
	
				if ( child instanceof THREE.Bone ) {
	
					child.update( this.identityMatrix, false );
	
				} else {
	
					child.updateMatrixWorld( true );
	
				}
	
			}
	
			// make a snapshot of the bones' rest position
	
			if ( this.boneInverses == undefined ) {
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					var inverse = new THREE.Matrix4();
	
					inverse.getInverse( this.bones[ b ].skinMatrix );
	
					this.boneInverses.push( inverse );
	
				}
	
			}
	
			// flatten bone matrices to array
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				// compute the offset between the current and the original transform;
	
				// TODO: we could get rid of this multiplication step if the skinMatrix
				// was already representing the offset; however, this requires some
				// major changes to the animation system
	
				offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );
	
			}
	
			if ( this.useVertexTexture ) {
	
				this.boneTexture.needsUpdate = true;
	
			}
	
		};
	
	}();
	
	THREE.SkinnedMesh.prototype.pose = function () {
	
		this.updateMatrixWorld( true );
	
		this.normalizeSkinWeights();
	
	};
	
	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
	
		if ( this.geometry instanceof THREE.Geometry ) {
	
			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {
	
				var sw = this.geometry.skinWeights[ i ];
	
				var scale = 1.0 / sw.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					sw.multiplyScalar( scale );
	
				} else {
	
					sw.set( 1 ); // this will be normalized by the shader anyway
	
				}
	
			}
	
		} else {
	
			// skinning weights assumed to be normalized for THREE.BufferGeometry
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) {
	
			object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );
	
		}
	
		THREE.Mesh.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphAnimMesh = function ( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		// API
	
		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;
	
		// internals
	
		this.lastKeyframe = 0;
		this.currentKeyframe = 0;
	
		this.direction = 1;
		this.directionBackwards = false;
	
		this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );
	
	};
	
	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {
	
		this.startKeyframe = start;
		this.endKeyframe = end;
	
		this.length = this.endKeyframe - this.startKeyframe + 1;
	
	};
	
	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
	
		this.direction = 1;
		this.directionBackwards = false;
	
	};
	
	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
	
		this.direction = -1;
		this.directionBackwards = true;
	
	};
	
	THREE.MorphAnimMesh.prototype.parseAnimations = function () {
	
		var geometry = this.geometry;
	
		if ( ! geometry.animations ) geometry.animations = {};
	
		var firstAnimation, animations = geometry.animations;
	
		var pattern = /([a-z]+)(\d+)/;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );
	
			if ( parts && parts.length > 1 ) {
	
				var label = parts[ 1 ];
				var num = parts[ 2 ];
	
				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };
	
				var animation = animations[ label ];
	
				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;
	
				if ( ! firstAnimation ) firstAnimation = label;
	
			}
	
		}
	
		geometry.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {
	
		if ( ! this.geometry.animations ) this.geometry.animations = {};
	
		this.geometry.animations[ label ] = { start: start, end: end };
	
	};
	
	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {
	
		var animation = this.geometry.animations[ label ];
	
		if ( animation ) {
	
			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;
	
		} else {
	
			console.warn( "animation[" + label + "] undefined" );
	
		}
	
	};
	
	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {
	
		var frameTime = this.duration / this.length;
	
		this.time += this.direction * delta;
	
		if ( this.mirroredLoop ) {
	
			if ( this.time > this.duration || this.time < 0 ) {
	
				this.direction *= -1;
	
				if ( this.time > this.duration ) {
	
					this.time = this.duration;
					this.directionBackwards = true;
	
				}
	
				if ( this.time < 0 ) {
	
					this.time = 0;
					this.directionBackwards = false;
	
				}
	
			}
	
		} else {
	
			this.time = this.time % this.duration;
	
			if ( this.time < 0 ) this.time += this.duration;
	
		}
	
		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );
	
		if ( keyframe !== this.currentKeyframe ) {
	
			this.morphTargetInfluences[ this.lastKeyframe ] = 0;
			this.morphTargetInfluences[ this.currentKeyframe ] = 1;
	
			this.morphTargetInfluences[ keyframe ] = 0;
	
			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;
	
		}
	
		var mix = ( this.time % frameTime ) / frameTime;
	
		if ( this.directionBackwards ) {
	
			mix = 1 - mix;
	
		}
	
		this.morphTargetInfluences[ this.currentKeyframe ] = mix;
		this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;
	
	};
	
	THREE.MorphAnimMesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );
	
		object.duration = this.duration;
		object.mirroredLoop = this.mirroredLoop;
		object.time = this.time;
	
		object.lastKeyframe = this.lastKeyframe;
		object.currentKeyframe = this.currentKeyframe;
	
		object.direction = this.direction;
		object.directionBackwards = this.directionBackwards;
	
		THREE.Mesh.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.objects = [];
	
	};
	
	
	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.LOD.prototype.addLevel = function ( object, distance ) {
	
		if ( distance === undefined ) distance = 0;
	
		distance = Math.abs( distance );
	
		for ( var l = 0; l < this.objects.length; l ++ ) {
	
			if ( distance < this.objects[ l ].distance ) {
	
				break;
	
			}
	
		}
	
		this.objects.splice( l, 0, { distance: distance, object: object } );
		this.add( object );
	
	};
	
	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {
	
		for ( var i = 1, l = this.objects.length; i < l; i ++ ) {
	
			if ( distance < this.objects[ i ].distance ) {
	
				break;
	
			}
	
		}
	
		return this.objects[ i - 1 ].object;
	
	};
	
	THREE.LOD.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( camera ) {
	
			if ( this.objects.length > 1 ) {
	
				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );
	
				var distance = v1.distanceTo( v2 );
	
				this.objects[ 0 ].object.visible = true;
	
				for ( var i = 1, l = this.objects.length; i < l; i ++ ) {
	
					if ( distance >= this.objects[ i ].distance ) {
	
						this.objects[ i - 1 ].object.visible = false;
						this.objects[ i     ].object.visible = true;
	
					} else {
	
						break;
	
					}
	
				}
	
				for( ; i < l; i ++ ) {
	
					this.objects[ i ].object.visible = false;
	
				}
	
			}
	
		};
	
	}();
	
	THREE.LOD.prototype.clone = function () {
	
		// TODO
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
	};
	
	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	
	/*
	 * Custom update matrix
	 */
	
	THREE.Sprite.prototype.updateMatrix = function () {
	
		this.matrix.compose( this.position, this.quaternion, this.scale );
	
		this.matrixWorldNeedsUpdate = true;
	
	};
	
	THREE.Sprite.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Sprite( this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	// Backwards compatibility
	
	THREE.Particle = THREE.Sprite;
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
		this.matrixAutoUpdate = false;
	
		this.__lights = [];
	
		this.__objectsAdded = [];
		this.__objectsRemoved = [];
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Scene.prototype.__addObject = function ( object ) {
	
		if ( object instanceof THREE.Light ) {
	
			if ( this.__lights.indexOf( object ) === - 1 ) {
	
				this.__lights.push( object );
	
			}
	
			if ( object.target && object.target.parent === undefined ) {
	
				this.add( object.target );
	
			}
	
		} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {
	
			this.__objectsAdded.push( object );
	
			// check if previously removed
	
			var i = this.__objectsRemoved.indexOf( object );
	
			if ( i !== -1 ) {
	
				this.__objectsRemoved.splice( i, 1 );
	
			}
	
		}
	
		this.dispatchEvent( { type: 'objectAdded', object: object } );
		object.dispatchEvent( { type: 'addedToScene', scene: this } );
	
		for ( var c = 0; c < object.children.length; c ++ ) {
	
			this.__addObject( object.children[ c ] );
	
		}
	
	};
	
	THREE.Scene.prototype.__removeObject = function ( object ) {
	
		if ( object instanceof THREE.Light ) {
	
			var i = this.__lights.indexOf( object );
	
			if ( i !== -1 ) {
	
				this.__lights.splice( i, 1 );
	
			}
	
			if ( object.shadowCascadeArray ) {
	
				for ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {
	
					this.__removeObject( object.shadowCascadeArray[ x ] );
	
				}
	
			}
	
		} else if ( !( object instanceof THREE.Camera ) ) {
	
			this.__objectsRemoved.push( object );
	
			// check if previously added
	
			var i = this.__objectsAdded.indexOf( object );
	
			if ( i !== -1 ) {
	
				this.__objectsAdded.splice( i, 1 );
	
			}
	
		}
	
		this.dispatchEvent( { type: 'objectRemoved', object: object } );
		object.dispatchEvent( { type: 'removedFromScene', scene: this } );
	
		for ( var c = 0; c < object.children.length; c ++ ) {
	
			this.__removeObject( object.children[ c ] );
	
		}
	
	};
	
	THREE.Scene.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Scene();
	
		THREE.Object3D.prototype.clone.call(this, object);
	
		if ( this.fog !== null ) object.fog = this.fog.clone();
		if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();
	
		object.autoUpdate = this.autoUpdate;
		object.matrixAutoUpdate = this.matrixAutoUpdate;
	
		return object;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( hex, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( hex );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( hex, density ) {
	
		this.name = '';
	
		this.color = new THREE.Color( hex );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CanvasRenderer = function ( parameters ) {
	
		console.log( 'THREE.CanvasRenderer', THREE.REVISION );
	
		var smoothstep = THREE.Math.smoothstep;
	
		parameters = parameters || {};
	
		var _this = this,
		_renderData, _elements, _lights,
		_projector = new THREE.Projector(),
	
		_canvas = parameters.canvas !== undefined
				? parameters.canvas
				: document.createElement( 'canvas' ),
	
		_canvasWidth = _canvas.width,
		_canvasHeight = _canvas.height,
		_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),
		
		_context = _canvas.getContext( '2d' ),
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0,
	
		_contextGlobalAlpha = 1,
		_contextGlobalCompositeOperation = 0,
		_contextStrokeStyle = null,
		_contextFillStyle = null,
		_contextLineWidth = null,
		_contextLineCap = null,
		_contextLineJoin = null,
		_contextDashSize = null,
		_contextGapSize = 0,
	
		_camera,
	
		_v1, _v2, _v3, _v4,
		_v5 = new THREE.RenderableVertex(),
		_v6 = new THREE.RenderableVertex(),
	
		_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
		_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,
	
		_color = new THREE.Color(),
		_color1 = new THREE.Color(),
		_color2 = new THREE.Color(),
		_color3 = new THREE.Color(),
		_color4 = new THREE.Color(),
	
		_diffuseColor = new THREE.Color(),
		_emissiveColor = new THREE.Color(),
	
		_lightColor = new THREE.Color(),
	
		_patterns = {},
	
		_near, _far,
	
		_image, _uvs,
		_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,
	
		_clipBox = new THREE.Box2(),
		_clearBox = new THREE.Box2(),
		_elemBox = new THREE.Box2(),
	
		_ambientLight = new THREE.Color(),
		_directionalLights = new THREE.Color(),
		_pointLights = new THREE.Color(),
	
		_vector3 = new THREE.Vector3(), // Needed for PointLight
	
		_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
		_gradientMap, _gradientMapContext, _gradientMapQuality = 16;
	
		_pixelMap = document.createElement( 'canvas' );
		_pixelMap.width = _pixelMap.height = 2;
	
		_pixelMapContext = _pixelMap.getContext( '2d' );
		_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
		_pixelMapContext.fillRect( 0, 0, 2, 2 );
	
		_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
		_pixelMapData = _pixelMapImage.data;
	
		_gradientMap = document.createElement( 'canvas' );
		_gradientMap.width = _gradientMap.height = _gradientMapQuality;
	
		_gradientMapContext = _gradientMap.getContext( '2d' );
		_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
		_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );
	
		_gradientMapQuality --; // Fix UVs
	
		// dash+gap fallbacks for Firefox and everything else
	
		if ( _context.setLineDash === undefined ) {
	
			if ( _context.mozDash !== undefined ) {
	
				_context.setLineDash = function ( values ) {
	
					_context.mozDash = values[ 0 ] !== null ? values : null;
	
				}
	
			} else {
	
				_context.setLineDash = function () {}
	
			}
	
		}
	
		this.domElement = _canvas;
	
		this.devicePixelRatio = parameters.devicePixelRatio !== undefined
					? parameters.devicePixelRatio
					: self.devicePixelRatio !== undefined
						? self.devicePixelRatio
						: 1;
	
		this.autoClear = true;
		this.sortObjects = true;
		this.sortElements = true;
	
		this.info = {
	
			render: {
	
				vertices: 0,
				faces: 0
	
			}
	
		}
	
		// WebGLRenderer compatibility
	
		this.supportsVertexTextures = function () {};
		this.setFaceCulling = function () {};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_canvasWidth = width * this.devicePixelRatio;
			_canvasHeight = height * this.devicePixelRatio;
	
			_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
			_canvasHeightHalf = Math.floor( _canvasHeight / 2 );
	
			_canvas.width = _canvasWidth;
			_canvas.height = _canvasHeight;
	
			if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			_clipBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
			_clearBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
			_contextGlobalAlpha = 1;
			_contextGlobalCompositeOperation = 0;
			_contextStrokeStyle = null;
			_contextFillStyle = null;
			_contextLineWidth = null;
			_contextLineCap = null;
			_contextLineJoin = null;
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			_clearBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
		};
	
		this.setClearColorHex = function ( hex, alpha ) {
	
			console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
			this.setClearColor( hex, alpha );
	
		};
	
		this.getMaxAnisotropy = function () {
	
			return 0;
	
		};
	
		this.clear = function () {
	
			_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );
	
			if ( _clearBox.empty() === false ) {
	
				_clearBox.intersect( _clipBox );
				_clearBox.expandByScalar( 2 );
	
				if ( _clearAlpha < 1 ) {
	
					_context.clearRect(
						_clearBox.min.x | 0,
						_clearBox.min.y | 0,
						( _clearBox.max.x - _clearBox.min.x ) | 0,
						( _clearBox.max.y - _clearBox.min.y ) | 0
					);
	
				}
	
				if ( _clearAlpha > 0 ) {
	
					setBlending( THREE.NormalBlending );
					setOpacity( 1 );
	
					setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );
	
					_context.fillRect(
						_clearBox.min.x | 0,
						_clearBox.min.y | 0,
						( _clearBox.max.x - _clearBox.min.x ) | 0,
						( _clearBox.max.y - _clearBox.min.y ) | 0
					);
	
				}
	
				_clearBox.makeEmpty();
	
			}
	
		};
	
		// compatibility
	
		this.clearColor = function () {};
		this.clearDepth = function () {};
		this.clearStencil = function () {};
	
		this.render = function ( scene, camera ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			if ( this.autoClear === true ) this.clear();
	
			_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );
	
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
	
			_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
			_elements = _renderData.elements;
			_lights = _renderData.lights;
			_camera = camera;
	
			/* DEBUG
			setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
			_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
			*/
	
			calculateLights();
	
			for ( var e = 0, el = _elements.length; e < el; e++ ) {
	
				var element = _elements[ e ];
	
				var material = element.material;
	
				if ( material === undefined || material.visible === false ) continue;
	
				_elemBox.makeEmpty();
	
				if ( element instanceof THREE.RenderableSprite ) {
	
					_v1 = element;
					_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;
	
					renderSprite( _v1, element, material );
	
				} else if ( element instanceof THREE.RenderableLine ) {
	
					_v1 = element.v1; _v2 = element.v2;
	
					_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
					_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
	
					_elemBox.setFromPoints( [
						_v1.positionScreen,
						_v2.positionScreen
					] );
	
					if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {
	
						renderLine( _v1, _v2, element, material );
	
					}
	
				} else if ( element instanceof THREE.RenderableFace3 ) {
	
					_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;
	
					if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
					if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
					if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;
	
					_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
					_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
					_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;
	
					if ( material.overdraw > 0 ) {
	
						expand( _v1.positionScreen, _v2.positionScreen, material.overdraw );
						expand( _v2.positionScreen, _v3.positionScreen, material.overdraw );
						expand( _v3.positionScreen, _v1.positionScreen, material.overdraw );
	
					}
	
					_elemBox.setFromPoints( [
						_v1.positionScreen,
						_v2.positionScreen,
						_v3.positionScreen
					] );
	
					if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {
	
						renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );
	
					}
	
				}
	
				/* DEBUG
				setLineWidth( 1 );
				setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
				_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
				*/
	
				_clearBox.union( _elemBox );
	
			}
	
			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
			_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
			*/
	
			_context.setTransform( 1, 0, 0, 1, 0, 0 );
	
		};
	
		//
	
		function calculateLights() {
	
			_ambientLight.setRGB( 0, 0, 0 );
			_directionalLights.setRGB( 0, 0, 0 );
			_pointLights.setRGB( 0, 0, 0 );
	
			for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {
	
				var light = _lights[ l ];
				var lightColor = light.color;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					_ambientLight.add( lightColor );
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					// for sprites
	
					_directionalLights.add( lightColor );
	
				} else if ( light instanceof THREE.PointLight ) {
	
					// for sprites
	
					_pointLights.add( lightColor );
	
				}
	
			}
	
		}
	
		function calculateLight( position, normal, color ) {
	
			for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {
	
				var light = _lights[ l ];
	
				_lightColor.copy( light.color );
	
				if ( light instanceof THREE.DirectionalLight ) {
	
					var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();
	
					var amount = normal.dot( lightPosition );
	
					if ( amount <= 0 ) continue;
	
					amount *= light.intensity;
	
					color.add( _lightColor.multiplyScalar( amount ) );
	
				} else if ( light instanceof THREE.PointLight ) {
	
					var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );
	
					var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );
	
					if ( amount <= 0 ) continue;
	
					amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );
	
					if ( amount == 0 ) continue;
	
					amount *= light.intensity;
	
					color.add( _lightColor.multiplyScalar( amount ) );
	
				}
	
			}
	
		}
	
		function renderSprite( v1, element, material ) {
	
			setOpacity( material.opacity );
			setBlending( material.blending );
	
			var scaleX = element.scale.x * _canvasWidthHalf;
			var scaleY = element.scale.y * _canvasHeightHalf;
	
			var dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite
			_elemBox.min.set( v1.x - dist, v1.y - dist );
			_elemBox.max.set( v1.x + dist, v1.y + dist );
	
			if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {
	
				_elemBox.makeEmpty();
				return;
	
			}
	
			if ( material instanceof THREE.SpriteMaterial ||
				 material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility
	
				var texture = material.map;
	
				if ( texture !== null ) {
	
					if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {
	
						if ( texture.image !== undefined && texture.image.width > 0 ) {
	
							textureToPattern( texture );
	
						}
	
						texture.addEventListener( 'update', onTextureUpdate );
	
					}
	
					var pattern = _patterns[ texture.id ];
	
					if ( pattern !== undefined ) {
	
						setFillStyle( pattern );
	
					} else {
	
						setFillStyle( 'rgba( 0, 0, 0, 1 )' );
	
					}
	
					//
	
					var bitmap = texture.image;
	
					var ox = bitmap.width * texture.offset.x;
					var oy = bitmap.height * texture.offset.y;
	
					var sx = bitmap.width * texture.repeat.x;
					var sy = bitmap.height * texture.repeat.y;
	
					var cx = scaleX / sx;
					var cy = scaleY / sy;
	
					_context.save();
					_context.translate( v1.x, v1.y );
					if ( material.rotation !== 0 ) _context.rotate( material.rotation );
					_context.translate( - scaleX / 2, - scaleY / 2 );
					_context.scale( cx, cy );
					_context.translate( - ox, - oy );
					_context.fillRect( ox, oy, sx, sy );
					_context.restore();
	
				} else { // no texture
	
					setFillStyle( material.color.getStyle() );
	
					_context.save();
					_context.translate( v1.x, v1.y );
					if ( material.rotation !== 0 ) _context.rotate( material.rotation );
					_context.scale( scaleX, - scaleY );
					_context.fillRect( - 0.5, - 0.5, 1, 1 );
					_context.restore();
	
				}
	
			} else if ( material instanceof THREE.SpriteCanvasMaterial ) {
	
				setStrokeStyle( material.color.getStyle() );
				setFillStyle( material.color.getStyle() );
	
				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.scale( scaleX, scaleY );
	
				material.program( _context );
	
				_context.restore();
	
			}
	
			/* DEBUG
			setStrokeStyle( 'rgb(255,255,0)' );
			_context.beginPath();
			_context.moveTo( v1.x - 10, v1.y );
			_context.lineTo( v1.x + 10, v1.y );
			_context.moveTo( v1.x, v1.y - 10 );
			_context.lineTo( v1.x, v1.y + 10 );
			_context.stroke();
			*/
	
		}
	
		function renderLine( v1, v2, element, material ) {
	
			setOpacity( material.opacity );
			setBlending( material.blending );
	
			_context.beginPath();
			_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
			_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );
	
			if ( material instanceof THREE.LineBasicMaterial ) {
	
				setLineWidth( material.linewidth );
				setLineCap( material.linecap );
				setLineJoin( material.linejoin );
	
				if ( material.vertexColors !== THREE.VertexColors ) {
	
					setStrokeStyle( material.color.getStyle() );
	
				} else {
	
					var colorStyle1 = element.vertexColors[0].getStyle();
					var colorStyle2 = element.vertexColors[1].getStyle();
	
					if ( colorStyle1 === colorStyle2 ) {
	
						setStrokeStyle( colorStyle1 );
	
					} else {
	
						try {
	
							var grad = _context.createLinearGradient(
								v1.positionScreen.x,
								v1.positionScreen.y,
								v2.positionScreen.x,
								v2.positionScreen.y
							);
							grad.addColorStop( 0, colorStyle1 );
							grad.addColorStop( 1, colorStyle2 );
	
						} catch ( exception ) {
	
							grad = colorStyle1;
	
						}
	
						setStrokeStyle( grad );
	
					}
	
				}
	
				_context.stroke();
				_elemBox.expandByScalar( material.linewidth * 2 );
	
			} else if ( material instanceof THREE.LineDashedMaterial ) {
	
				setLineWidth( material.linewidth );
				setLineCap( material.linecap );
				setLineJoin( material.linejoin );
				setStrokeStyle( material.color.getStyle() );
				setDashAndGap( material.dashSize, material.gapSize );
	
				_context.stroke();
	
				_elemBox.expandByScalar( material.linewidth * 2 );
	
				setDashAndGap( null, null );
	
			}
	
		}
	
		function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {
	
			_this.info.render.vertices += 3;
			_this.info.render.faces ++;
	
			setOpacity( material.opacity );
			setBlending( material.blending );
	
			_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
			_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
			_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;
	
			drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );
	
			if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {
	
				_diffuseColor.copy( material.color );
				_emissiveColor.copy( material.emissive );
	
				if ( material.vertexColors === THREE.FaceColors ) {
	
					_diffuseColor.multiply( element.color );
	
				}
	
				if ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {
	
					_color1.copy( _ambientLight );
					_color2.copy( _ambientLight );
					_color3.copy( _ambientLight );
	
					calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
					calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
					calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );
	
					_color1.multiply( _diffuseColor ).add( _emissiveColor );
					_color2.multiply( _diffuseColor ).add( _emissiveColor );
					_color3.multiply( _diffuseColor ).add( _emissiveColor );
					_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );
	
					_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
					clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );
	
				} else {
	
					_color.copy( _ambientLight );
	
					calculateLight( element.centroidModel, element.normalModel, _color );
	
					_color.multiply( _diffuseColor ).add( _emissiveColor );
	
					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );
	
				}
	
			} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {
	
				if ( material.map !== null ) {
	
					if ( material.map.mapping instanceof THREE.UVMapping ) {
	
						_uvs = element.uvs[ 0 ];
						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );
	
					}
	
	
				} else if ( material.envMap !== null ) {
	
					if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {
	
						_vector3.copy( element.vertexNormalsModelView[ uv1 ] );
						_uv1x = 0.5 * _vector3.x + 0.5;
						_uv1y = 0.5 * _vector3.y + 0.5;
	
						_vector3.copy( element.vertexNormalsModelView[ uv2 ] );
						_uv2x = 0.5 * _vector3.x + 0.5;
						_uv2y = 0.5 * _vector3.y + 0.5;
	
						_vector3.copy( element.vertexNormalsModelView[ uv3 ] );
						_uv3x = 0.5 * _vector3.x + 0.5;
						_uv3y = 0.5 * _vector3.y + 0.5;
	
						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );
	
					}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {
	
	
	
					}*/
	
	
				} else {
	
					_color.copy( material.color );
	
					if ( material.vertexColors === THREE.FaceColors ) {
	
						_color.multiply( element.color );
	
					}
	
					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );
	
				}
	
			} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
				_near = _camera.near;
				_far = _camera.far;
	
				_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
				_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
				_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );
	
				_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );
	
			} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
				var normal;
	
				if ( material.shading === THREE.FlatShading ) {
	
					normal = element.normalModelView;
	
					_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );
	
				} else if ( material.shading === THREE.SmoothShading ) {
	
					normal = element.vertexNormalsModelView[ uv1 ];
					_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
					normal = element.vertexNormalsModelView[ uv2 ];
					_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
					normal = element.vertexNormalsModelView[ uv3 ];
					_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
					_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );
	
					_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
					clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );
	
				}
	
			}
	
		}
	
		//
	
		function drawTriangle( x0, y0, x1, y1, x2, y2 ) {
	
			_context.beginPath();
			_context.moveTo( x0, y0 );
			_context.lineTo( x1, y1 );
			_context.lineTo( x2, y2 );
			_context.closePath();
	
		}
	
		function strokePath( color, linewidth, linecap, linejoin ) {
	
			setLineWidth( linewidth );
			setLineCap( linecap );
			setLineJoin( linejoin );
			setStrokeStyle( color.getStyle() );
	
			_context.stroke();
	
			_elemBox.expandByScalar( linewidth * 2 );
	
		}
	
		function fillPath( color ) {
	
			setFillStyle( color.getStyle() );
			_context.fill();
	
		}
	
		function onTextureUpdate ( event ) {
	
			textureToPattern( event.target );
	
		}
	
		function textureToPattern( texture ) {
	
			var repeatX = texture.wrapS === THREE.RepeatWrapping;
			var repeatY = texture.wrapT === THREE.RepeatWrapping;
	
			var image = texture.image;
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = image.width;
			canvas.height = image.height;
	
			var context = canvas.getContext( '2d' );
			context.setTransform( 1, 0, 0, - 1, 0, image.height );
			context.drawImage( image, 0, 0 );
	
			_patterns[ texture.id ] = _context.createPattern(
				canvas, repeatX === true && repeatY === true
					? 'repeat'
					: repeatX === true && repeatY === false
						? 'repeat-x'
						: repeatX === false && repeatY === true
							? 'repeat-y'
							: 'no-repeat'
			);
	
		}
	
		function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {
	
			if ( texture instanceof THREE.DataTexture ) return;
	
			if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {
	
				if ( texture.image !== undefined && texture.image.width > 0 ) {
	
					textureToPattern( texture );
	
				}
	
				texture.addEventListener( 'update', onTextureUpdate );
	
			}
	
			var pattern = _patterns[ texture.id ];
	
			if ( pattern !== undefined ) {
	
				setFillStyle( pattern );
	
			} else {
	
				setFillStyle( 'rgba(0,0,0,1)' );
				_context.fill();
	
				return;
	
			}	
	
			// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
	
			var a, b, c, d, e, f, det, idet,
			offsetX = texture.offset.x / texture.repeat.x,
			offsetY = texture.offset.y / texture.repeat.y,
			width = texture.image.width * texture.repeat.x,
			height = texture.image.height * texture.repeat.y;
	
			u0 = ( u0 + offsetX ) * width;
			v0 = ( v0 + offsetY ) * height;
	
			u1 = ( u1 + offsetX ) * width;
			v1 = ( v1 + offsetY ) * height;
	
			u2 = ( u2 + offsetX ) * width;
			v2 = ( v2 + offsetY ) * height;
	
			x1 -= x0; y1 -= y0;
			x2 -= x0; y2 -= y0;
	
			u1 -= u0; v1 -= v0;
			u2 -= u0; v2 -= v0;
	
			det = u1 * v2 - u2 * v1;
	
			if ( det === 0 ) return;
	
			idet = 1 / det;
	
			a = ( v2 * x1 - v1 * x2 ) * idet;
			b = ( v2 * y1 - v1 * y2 ) * idet;
			c = ( u1 * x2 - u2 * x1 ) * idet;
			d = ( u1 * y2 - u2 * y1 ) * idet;
	
			e = x0 - a * u0 - c * v0;
			f = y0 - b * u0 - d * v0;
	
			_context.save();
			_context.transform( a, b, c, d, e, f );
			_context.fill();
			_context.restore();
	
		}
	
		function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {
	
			// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
	
			var a, b, c, d, e, f, det, idet,
			width = image.width - 1,
			height = image.height - 1;
	
			u0 *= width; v0 *= height;
			u1 *= width; v1 *= height;
			u2 *= width; v2 *= height;
	
			x1 -= x0; y1 -= y0;
			x2 -= x0; y2 -= y0;
	
			u1 -= u0; v1 -= v0;
			u2 -= u0; v2 -= v0;
	
			det = u1 * v2 - u2 * v1;
	
			idet = 1 / det;
	
			a = ( v2 * x1 - v1 * x2 ) * idet;
			b = ( v2 * y1 - v1 * y2 ) * idet;
			c = ( u1 * x2 - u2 * x1 ) * idet;
			d = ( u1 * y2 - u2 * y1 ) * idet;
	
			e = x0 - a * u0 - c * v0;
			f = y0 - b * u0 - d * v0;
	
			_context.save();
			_context.transform( a, b, c, d, e, f );
			_context.clip();
			_context.drawImage( image, 0, 0 );
			_context.restore();
	
		}
	
		function getGradientTexture( color1, color2, color3, color4 ) {
	
			// http://mrdoob.com/blog/post/710
	
			_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
			_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
			_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;
	
			_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
			_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
			_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;
	
			_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
			_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
			_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;
	
			_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
			_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
			_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;
	
			_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
			_gradientMapContext.drawImage( _pixelMap, 0, 0 );
	
			return _gradientMap;
	
		}
	
		// Hide anti-alias gaps
	
		function expand( v1, v2, pixels ) {
	
			var x = v2.x - v1.x, y = v2.y - v1.y,
			det = x * x + y * y, idet;
	
			if ( det === 0 ) return;
	
			idet = pixels / Math.sqrt( det );
	
			x *= idet; y *= idet;
	
			v2.x += x; v2.y += y;
			v1.x -= x; v1.y -= y;
	
		}
	
		// Context cached methods.
	
		function setOpacity( value ) {
	
			if ( _contextGlobalAlpha !== value ) {
	
				_context.globalAlpha = value;
				_contextGlobalAlpha = value;
	
			}
	
		}
	
		function setBlending( value ) {
	
			if ( _contextGlobalCompositeOperation !== value ) {
	
				if ( value === THREE.NormalBlending ) {
	
					_context.globalCompositeOperation = 'source-over';
	
				} else if ( value === THREE.AdditiveBlending ) {
	
					_context.globalCompositeOperation = 'lighter';
	
				} else if ( value === THREE.SubtractiveBlending ) {
	
					_context.globalCompositeOperation = 'darker';
	
				}
	
				_contextGlobalCompositeOperation = value;
	
			}
	
		}
	
		function setLineWidth( value ) {
	
			if ( _contextLineWidth !== value ) {
	
				_context.lineWidth = value;
				_contextLineWidth = value;
	
			}
	
		}
	
		function setLineCap( value ) {
	
			// "butt", "round", "square"
	
			if ( _contextLineCap !== value ) {
	
				_context.lineCap = value;
				_contextLineCap = value;
	
			}
	
		}
	
		function setLineJoin( value ) {
	
			// "round", "bevel", "miter"
	
			if ( _contextLineJoin !== value ) {
	
				_context.lineJoin = value;
				_contextLineJoin = value;
	
			}
	
		}
	
		function setStrokeStyle( value ) {
	
			if ( _contextStrokeStyle !== value ) {
	
				_context.strokeStyle = value;
				_contextStrokeStyle = value;
	
			}
	
		}
	
		function setFillStyle( value ) {
	
			if ( _contextFillStyle !== value ) {
	
				_context.fillStyle = value;
				_contextFillStyle = value;
	
			}
	
		}
	
		function setDashAndGap( dashSizeValue, gapSizeValue ) {
	
			if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {
	
				_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
				_contextDashSize = dashSizeValue;
				_contextGapSize = gapSizeValue;
	
			}
	
		}
	
	};
	
	/**
	 * Shader chunks for WebLG Shader library
	 * 
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.ShaderChunk = {
	
		// FOG
	
		fog_pars_fragment: [
	
			"#ifdef USE_FOG",
	
				"uniform vec3 fogColor;",
	
				"#ifdef FOG_EXP2",
	
					"uniform float fogDensity;",
	
				"#else",
	
					"uniform float fogNear;",
					"uniform float fogFar;",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		fog_fragment: [
	
			"#ifdef USE_FOG",
	
				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
	
				"#ifdef FOG_EXP2",
	
					"const float LOG2 = 1.442695;",
					"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
					"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
	
				"#else",
	
					"float fogFactor = smoothstep( fogNear, fogFar, depth );",
	
				"#endif",
	
				"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
	
			"#endif"
	
		].join("\n"),
	
		// ENVIRONMENT MAP
	
		envmap_pars_fragment: [
	
			"#ifdef USE_ENVMAP",
	
				"uniform float reflectivity;",
				"uniform samplerCube envMap;",
				"uniform float flipEnvMap;",
				"uniform int combine;",
	
				"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
	
					"uniform bool useRefract;",
					"uniform float refractionRatio;",
	
				"#else",
	
					"varying vec3 vReflect;",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		envmap_fragment: [
	
			"#ifdef USE_ENVMAP",
	
				"vec3 reflectVec;",
	
				"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
	
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
	
					"if ( useRefract ) {",
	
						"reflectVec = refract( cameraToVertex, normal, refractionRatio );",
	
					"} else { ",
	
						"reflectVec = reflect( cameraToVertex, normal );",
	
					"}",
	
				"#else",
	
					"reflectVec = vReflect;",
	
				"#endif",
	
				"#ifdef DOUBLE_SIDED",
	
					"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
					"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
	
				"#else",
	
					"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
	
				"#endif",
	
				"#ifdef GAMMA_INPUT",
	
					"cubeColor.xyz *= cubeColor.xyz;",
	
				"#endif",
	
				"if ( combine == 1 ) {",
	
					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",
	
				"} else if ( combine == 2 ) {",
	
					"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",
	
				"} else {",
	
					"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		envmap_pars_vertex: [
	
			"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
	
				"varying vec3 vReflect;",
	
				"uniform float refractionRatio;",
				"uniform bool useRefract;",
	
			"#endif"
	
		].join("\n"),
	
		worldpos_vertex : [
	
			"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",
	
				"#ifdef USE_SKINNING",
	
					"vec4 worldPosition = modelMatrix * skinned;",
	
				"#endif",
	
				"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
	
					"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",
	
				"#endif",
	
				"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
	
					"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		envmap_vertex : [
	
			"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
	
				"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
				"worldNormal = normalize( worldNormal );",
	
				"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",
	
				"if ( useRefract ) {",
	
					"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",
	
				"} else {",
	
					"vReflect = reflect( cameraToVertex, worldNormal );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// COLOR MAP (particles)
	
		map_particle_pars_fragment: [
	
			"#ifdef USE_MAP",
	
				"uniform sampler2D map;",
	
			"#endif"
	
		].join("\n"),
	
	
		map_particle_fragment: [
	
			"#ifdef USE_MAP",
	
				"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",
	
			"#endif"
	
		].join("\n"),
	
		// COLOR MAP (triangles)
	
		map_pars_vertex: [
	
			"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",
	
				"varying vec2 vUv;",
				"uniform vec4 offsetRepeat;",
	
			"#endif"
	
		].join("\n"),
	
		map_pars_fragment: [
	
			"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",
	
				"varying vec2 vUv;",
	
			"#endif",
	
			"#ifdef USE_MAP",
	
				"uniform sampler2D map;",
	
			"#endif"
	
		].join("\n"),
	
		map_vertex: [
	
			"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",
	
				"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",
	
			"#endif"
	
		].join("\n"),
	
		map_fragment: [
	
			"#ifdef USE_MAP",
	
				"vec4 texelColor = texture2D( map, vUv );",
	
				"#ifdef GAMMA_INPUT",
	
					"texelColor.xyz *= texelColor.xyz;",
	
				"#endif",
	
				"gl_FragColor = gl_FragColor * texelColor;",
	
			"#endif"
	
		].join("\n"),
	
		// LIGHT MAP
	
		lightmap_pars_fragment: [
	
			"#ifdef USE_LIGHTMAP",
	
				"varying vec2 vUv2;",
				"uniform sampler2D lightMap;",
	
			"#endif"
	
		].join("\n"),
	
		lightmap_pars_vertex: [
	
			"#ifdef USE_LIGHTMAP",
	
				"varying vec2 vUv2;",
	
			"#endif"
	
		].join("\n"),
	
		lightmap_fragment: [
	
			"#ifdef USE_LIGHTMAP",
	
				"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",
	
			"#endif"
	
		].join("\n"),
	
		lightmap_vertex: [
	
			"#ifdef USE_LIGHTMAP",
	
				"vUv2 = uv2;",
	
			"#endif"
	
		].join("\n"),
	
		// BUMP MAP
	
		bumpmap_pars_fragment: [
	
			"#ifdef USE_BUMPMAP",
	
				"uniform sampler2D bumpMap;",
				"uniform float bumpScale;",
	
				// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
				//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html
	
				// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)
	
				"vec2 dHdxy_fwd() {",
	
					"vec2 dSTdx = dFdx( vUv );",
					"vec2 dSTdy = dFdy( vUv );",
	
					"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
					"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
					"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",
	
					"return vec2( dBx, dBy );",
	
				"}",
	
				"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
	
					"vec3 vSigmaX = dFdx( surf_pos );",
					"vec3 vSigmaY = dFdy( surf_pos );",
					"vec3 vN = surf_norm;",		// normalized
	
					"vec3 R1 = cross( vSigmaY, vN );",
					"vec3 R2 = cross( vN, vSigmaX );",
	
					"float fDet = dot( vSigmaX, R1 );",
	
					"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
					"return normalize( abs( fDet ) * surf_norm - vGrad );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// NORMAL MAP
	
		normalmap_pars_fragment: [
	
			"#ifdef USE_NORMALMAP",
	
				"uniform sampler2D normalMap;",
				"uniform vec2 normalScale;",
	
				// Per-Pixel Tangent Space Normal Mapping
				// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html
	
				"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",
	
					"vec3 q0 = dFdx( eye_pos.xyz );",
					"vec3 q1 = dFdy( eye_pos.xyz );",
					"vec2 st0 = dFdx( vUv.st );",
					"vec2 st1 = dFdy( vUv.st );",
	
					"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
					"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
					"vec3 N = normalize( surf_norm );",
	
					"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
					"mapN.xy = normalScale * mapN.xy;",
					"mat3 tsn = mat3( S, T, N );",
					"return normalize( tsn * mapN );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// SPECULAR MAP
	
		specularmap_pars_fragment: [
	
			"#ifdef USE_SPECULARMAP",
	
				"uniform sampler2D specularMap;",
	
			"#endif"
	
		].join("\n"),
	
		specularmap_fragment: [
	
			"float specularStrength;",
	
			"#ifdef USE_SPECULARMAP",
	
				"vec4 texelSpecular = texture2D( specularMap, vUv );",
				"specularStrength = texelSpecular.r;",
	
			"#else",
	
				"specularStrength = 1.0;",
	
			"#endif"
	
		].join("\n"),
	
		// LIGHTS LAMBERT
	
		lights_lambert_pars_vertex: [
	
			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
	
			"uniform vec3 ambientLightColor;",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
	
			"#endif",
	
			"#ifdef WRAP_AROUND",
	
				"uniform vec3 wrapRGB;",
	
			"#endif"
	
		].join("\n"),
	
		lights_lambert_vertex: [
	
			"vLightFront = vec3( 0.0 );",
	
			"#ifdef DOUBLE_SIDED",
	
				"vLightBack = vec3( 0.0 );",
	
			"#endif",
	
			"transformedNormal = normalize( transformedNormal );",
	
			"#if MAX_DIR_LIGHTS > 0",
	
			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
	
				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",
	
				"float dotProduct = dot( transformedNormal, dirVector );",
				"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	
				"#ifdef DOUBLE_SIDED",
	
					"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
	
					"#ifdef WRAP_AROUND",
	
						"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
	
					"#endif",
	
				"#endif",
	
				"#ifdef WRAP_AROUND",
	
					"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",
	
					"#ifdef DOUBLE_SIDED",
	
						"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",
	
					"#endif",
	
				"#endif",
	
				"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",
	
				"#ifdef DOUBLE_SIDED",
	
					"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",
	
				"#endif",
	
			"}",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
	
					"lVector = normalize( lVector );",
					"float dotProduct = dot( transformedNormal, lVector );",
	
					"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	
					"#ifdef DOUBLE_SIDED",
	
						"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
	
						"#ifdef WRAP_AROUND",
	
							"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
	
						"#endif",
	
					"#endif",
	
					"#ifdef WRAP_AROUND",
	
						"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",
	
						"#ifdef DOUBLE_SIDED",
	
							"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",
	
						"#endif",
	
					"#endif",
	
					"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",
	
					"#ifdef DOUBLE_SIDED",
	
						"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",
	
					"if ( spotEffect > spotLightAngleCos[ i ] ) {",
	
						"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
	
						"float lDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
	
						"lVector = normalize( lVector );",
	
						"float dotProduct = dot( transformedNormal, lVector );",
						"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	
						"#ifdef DOUBLE_SIDED",
	
							"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
	
							"#ifdef WRAP_AROUND",
	
								"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
	
							"#endif",
	
						"#endif",
	
						"#ifdef WRAP_AROUND",
	
							"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
							"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",
	
							"#ifdef DOUBLE_SIDED",
	
								"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",
	
							"#endif",
	
						"#endif",
	
						"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",
	
						"#ifdef DOUBLE_SIDED",
	
							"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",
	
						"#endif",
	
					"}",
	
				"}",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
	
					"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
					"vec3 lVector = normalize( lDirection.xyz );",
	
					"float dotProduct = dot( transformedNormal, lVector );",
	
					"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
					"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",
	
					"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
	
					"#ifdef DOUBLE_SIDED",
	
						"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",
	
			"#ifdef DOUBLE_SIDED",
	
				"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",
	
			"#endif"
	
		].join("\n"),
	
		// LIGHTS PHONG
	
		lights_phong_pars_vertex: [
	
			"#ifndef PHONG_PER_PIXEL",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
				"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
	
				"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
	
			"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
	
				"varying vec3 vWorldPosition;",
	
			"#endif"
	
		].join("\n"),
	
	
		lights_phong_vertex: [
	
			"#ifndef PHONG_PER_PIXEL",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
	
					"vPointLight[ i ] = vec4( lVector, lDistance );",
	
				"}",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
	
					"vSpotLight[ i ] = vec4( lVector, lDistance );",
	
				"}",
	
			"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
	
				"vWorldPosition = worldPosition.xyz;",
	
			"#endif"
	
		].join("\n"),
	
		lights_phong_pars_fragment: [
	
			"uniform vec3 ambientLightColor;",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
	
				"#ifdef PHONG_PER_PIXEL",
	
					"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
					"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
				"#else",
	
					"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
	
				"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
	
				"#ifdef PHONG_PER_PIXEL",
	
					"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
	
				"#else",
	
					"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
	
				"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
	
				"varying vec3 vWorldPosition;",
	
			"#endif",
	
			"#ifdef WRAP_AROUND",
	
				"uniform vec3 wrapRGB;",
	
			"#endif",
	
			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;"
	
		].join("\n"),
	
		lights_phong_fragment: [
	
			"vec3 normal = normalize( vNormal );",
			"vec3 viewPosition = normalize( vViewPosition );",
	
			"#ifdef DOUBLE_SIDED",
	
				"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
	
			"#endif",
	
			"#ifdef USE_NORMALMAP",
	
				"normal = perturbNormal2Arb( -vViewPosition, normal );",
	
			"#elif defined( USE_BUMPMAP )",
	
				"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"vec3 pointDiffuse  = vec3( 0.0 );",
				"vec3 pointSpecular = vec3( 0.0 );",
	
				"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
					"#ifdef PHONG_PER_PIXEL",
	
						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
	
						"float lDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
	
						"lVector = normalize( lVector );",
	
					"#else",
	
						"vec3 lVector = normalize( vPointLight[ i ].xyz );",
						"float lDistance = vPointLight[ i ].w;",
	
					"#endif",
	
					// diffuse
	
					"float dotProduct = dot( normal, lVector );",
	
					"#ifdef WRAP_AROUND",
	
						"float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
	
						"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
	
					"#else",
	
						"float pointDiffuseWeight = max( dotProduct, 0.0 );",
	
					"#endif",
	
					"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",
	
					// specular
	
					"vec3 pointHalfVector = normalize( lVector + viewPosition );",
					"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
					"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
	
					// 2.0 => 2.0001 is hack to work around ANGLE bug
	
					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
					"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",
	
				"}",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"vec3 spotDiffuse  = vec3( 0.0 );",
				"vec3 spotSpecular = vec3( 0.0 );",
	
				"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
					"#ifdef PHONG_PER_PIXEL",
	
						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
	
						"float lDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
	
						"lVector = normalize( lVector );",
	
					"#else",
	
						"vec3 lVector = normalize( vSpotLight[ i ].xyz );",
						"float lDistance = vSpotLight[ i ].w;",
	
					"#endif",
	
					"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
	
					"if ( spotEffect > spotLightAngleCos[ i ] ) {",
	
						"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
	
						// diffuse
	
						"float dotProduct = dot( normal, lVector );",
	
						"#ifdef WRAP_AROUND",
	
							"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
							"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
	
							"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
	
						"#else",
	
							"float spotDiffuseWeight = max( dotProduct, 0.0 );",
	
						"#endif",
	
						"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",
	
						// specular
	
						"vec3 spotHalfVector = normalize( lVector + viewPosition );",
						"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
						"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",
	
						// 2.0 => 2.0001 is hack to work around ANGLE bug
	
						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
						"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
	
					"}",
	
				"}",
	
			"#endif",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"vec3 dirDiffuse  = vec3( 0.0 );",
				"vec3 dirSpecular = vec3( 0.0 );" ,
	
				"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
	
					"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
					"vec3 dirVector = normalize( lDirection.xyz );",
	
					// diffuse
	
					"float dotProduct = dot( normal, dirVector );",
	
					"#ifdef WRAP_AROUND",
	
						"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
	
						"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",
	
					"#else",
	
						"float dirDiffuseWeight = max( dotProduct, 0.0 );",
	
					"#endif",
	
					"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",
	
					// specular
	
					"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
					"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
					"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",
	
						/*
					// fresnel term from skin shader
					"const float F0 = 0.128;",
	
					"float base = 1.0 - dot( viewPosition, dirHalfVector );",
					"float exponential = pow( base, 5.0 );",
	
					"float fresnel = exponential + F0 * ( 1.0 - exponential );",
					*/
	
					/*
					// fresnel term from fresnel shader
					"const float mFresnelBias = 0.08;",
					"const float mFresnelScale = 0.3;",
					"const float mFresnelPower = 5.0;",
	
					"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
					*/
	
					// 2.0 => 2.0001 is hack to work around ANGLE bug
	
					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
					//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",
	
					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
					"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
	
	
				"}",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"vec3 hemiDiffuse  = vec3( 0.0 );",
				"vec3 hemiSpecular = vec3( 0.0 );" ,
	
				"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
	
					"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
					"vec3 lVector = normalize( lDirection.xyz );",
	
					// diffuse
	
					"float dotProduct = dot( normal, lVector );",
					"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
	
					"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
	
					"hemiDiffuse += diffuse * hemiColor;",
	
					// specular (sky light)
	
					"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
					"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
					"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",
	
					// specular (ground light)
	
					"vec3 lVectorGround = -lVector;",
	
					"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
					"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
					"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",
	
					"float dotProductGround = dot( normal, lVectorGround );",
	
					// 2.0 => 2.0001 is hack to work around ANGLE bug
	
					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
					"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
					"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
					"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
	
				"}",
	
			"#endif",
	
			"vec3 totalDiffuse = vec3( 0.0 );",
			"vec3 totalSpecular = vec3( 0.0 );",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"totalDiffuse += dirDiffuse;",
				"totalSpecular += dirSpecular;",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"totalDiffuse += hemiDiffuse;",
				"totalSpecular += hemiSpecular;",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"totalDiffuse += pointDiffuse;",
				"totalSpecular += pointSpecular;",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"totalDiffuse += spotDiffuse;",
				"totalSpecular += spotSpecular;",
	
			"#endif",
	
			"#ifdef METAL",
	
				"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",
	
			"#else",
	
				"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",
	
			"#endif"
	
		].join("\n"),
	
		// VERTEX COLORS
	
		color_pars_fragment: [
	
			"#ifdef USE_COLOR",
	
				"varying vec3 vColor;",
	
			"#endif"
	
		].join("\n"),
	
	
		color_fragment: [
	
			"#ifdef USE_COLOR",
	
				"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",
	
			"#endif"
	
		].join("\n"),
	
		color_pars_vertex: [
	
			"#ifdef USE_COLOR",
	
				"varying vec3 vColor;",
	
			"#endif"
	
		].join("\n"),
	
	
		color_vertex: [
	
			"#ifdef USE_COLOR",
	
				"#ifdef GAMMA_INPUT",
	
					"vColor = color * color;",
	
				"#else",
	
					"vColor = color;",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		// SKINNING
	
		skinning_pars_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"#ifdef BONE_TEXTURE",
	
					"uniform sampler2D boneTexture;",
					"uniform int boneTextureWidth;",
					"uniform int boneTextureHeight;",
	
					"mat4 getBoneMatrix( const in float i ) {",
	
						"float j = i * 4.0;",
						"float x = mod( j, float( boneTextureWidth ) );",
						"float y = floor( j / float( boneTextureWidth ) );",
	
						"float dx = 1.0 / float( boneTextureWidth );",
						"float dy = 1.0 / float( boneTextureHeight );",
	
						"y = dy * ( y + 0.5 );",
	
						"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
						"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
						"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
						"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
	
						"mat4 bone = mat4( v1, v2, v3, v4 );",
	
						"return bone;",
	
					"}",
	
				"#else",
	
					"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",
	
					"mat4 getBoneMatrix( const in float i ) {",
	
						"mat4 bone = boneGlobalMatrices[ int(i) ];",
						"return bone;",
	
					"}",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		skinbase_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
				"mat4 boneMatY = getBoneMatrix( skinIndex.y );",
	
			"#endif"
	
		].join("\n"),
	
		skinning_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"#ifdef USE_MORPHTARGETS",
	
				"vec4 skinVertex = vec4( morphed, 1.0 );",
	
				"#else",
	
				"vec4 skinVertex = vec4( position, 1.0 );",
	
				"#endif",
	
				"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
				"skinned 	  += boneMatY * skinVertex * skinWeight.y;",
	
			"#endif"
	
		].join("\n"),
	
		// MORPHING
	
		morphtarget_pars_vertex: [
	
			"#ifdef USE_MORPHTARGETS",
	
				"#ifndef USE_MORPHNORMALS",
	
				"uniform float morphTargetInfluences[ 8 ];",
	
				"#else",
	
				"uniform float morphTargetInfluences[ 4 ];",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		morphtarget_vertex: [
	
			"#ifdef USE_MORPHTARGETS",
	
				"vec3 morphed = vec3( 0.0 );",
				"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
				"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
				"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
				"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
	
				"#ifndef USE_MORPHNORMALS",
	
				"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
				"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
				"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
				"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
	
				"#endif",
	
				"morphed += position;",
	
			"#endif"
	
		].join("\n"),
	
		default_vertex : [
	
			"vec4 mvPosition;",
	
			"#ifdef USE_SKINNING",
	
				"mvPosition = modelViewMatrix * skinned;",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",
	
				"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",
	
				"mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	
			"#endif",
	
			"gl_Position = projectionMatrix * mvPosition;"
	
		].join("\n"),
	
		morphnormal_vertex: [
	
			"#ifdef USE_MORPHNORMALS",
	
				"vec3 morphedNormal = vec3( 0.0 );",
	
				"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
				"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
				"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
				"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",
	
				"morphedNormal += normal;",
	
			"#endif"
	
		].join("\n"),
	
		skinnormal_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"mat4 skinMatrix = skinWeight.x * boneMatX;",
				"skinMatrix 	+= skinWeight.y * boneMatY;",
	
				"#ifdef USE_MORPHNORMALS",
	
				"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",
	
				"#else",
	
				"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		defaultnormal_vertex: [
	
			"vec3 objectNormal;",
	
			"#ifdef USE_SKINNING",
	
				"objectNormal = skinnedNormal.xyz;",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",
	
				"objectNormal = morphedNormal;",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",
	
				"objectNormal = normal;",
	
			"#endif",
	
			"#ifdef FLIP_SIDED",
	
				"objectNormal = -objectNormal;",
	
			"#endif",
	
			"vec3 transformedNormal = normalMatrix * objectNormal;"
	
		].join("\n"),
	
		// SHADOW MAP
	
		// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
		//  http://spidergl.org/example.php?id=6
		// 	http://fabiensanglard.net/shadowmapping
	
		shadowmap_pars_fragment: [
	
			"#ifdef USE_SHADOWMAP",
	
				"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
				"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",
	
				"uniform float shadowDarkness[ MAX_SHADOWS ];",
				"uniform float shadowBias[ MAX_SHADOWS ];",
	
				"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
	
				"float unpackDepth( const in vec4 rgba_depth ) {",
	
					"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
					"float depth = dot( rgba_depth, bit_shift );",
					"return depth;",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		shadowmap_fragment: [
	
			"#ifdef USE_SHADOWMAP",
	
				"#ifdef SHADOWMAP_DEBUG",
	
					"vec3 frustumColors[3];",
					"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
					"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
					"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",
	
				"#endif",
	
				"#ifdef SHADOWMAP_CASCADE",
	
					"int inFrustumCount = 0;",
	
				"#endif",
	
				"float fDepth;",
				"vec3 shadowColor = vec3( 1.0 );",
	
				"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
	
					"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
	
					// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
					// "if ( all( something, something ) )"  using this instead
	
					"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
					"bool inFrustum = all( inFrustumVec );",
	
					// don't shadow pixels outside of light frustum
					// use just first frustum (for cascades)
					// don't shadow pixels behind far plane of light frustum
	
					"#ifdef SHADOWMAP_CASCADE",
	
						"inFrustumCount += int( inFrustum );",
						"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",
	
					"#else",
	
						"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",
	
					"#endif",
	
					"bool frustumTest = all( frustumTestVec );",
	
					"if ( frustumTest ) {",
	
						"shadowCoord.z += shadowBias[ i ];",
	
						"#if defined( SHADOWMAP_TYPE_PCF )",
	
							// Percentage-close filtering
							// (9 pixel kernel)
							// http://fabiensanglard.net/shadowmappingPCF/
	
							"float shadow = 0.0;",
	
							/*
							// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
							// must enroll loop manually
	
							"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
								"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",
	
									"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",
	
									// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
									//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",
	
									"float fDepth = unpackDepth( rgbaDepth );",
	
									"if ( fDepth < shadowCoord.z )",
										"shadow += 1.0;",
	
							"}",
	
							"shadow /= 9.0;",
	
							*/
	
							"const float shadowDelta = 1.0 / 9.0;",
	
							"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
							"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
	
							"float dx0 = -1.25 * xPixelOffset;",
							"float dy0 = -1.25 * yPixelOffset;",
							"float dx1 = 1.25 * xPixelOffset;",
							"float dy1 = 1.25 * yPixelOffset;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
	
						"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",
	
							// Percentage-close filtering
							// (9 pixel kernel)
							// http://fabiensanglard.net/shadowmappingPCF/
	
							"float shadow = 0.0;",
	
							"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
							"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
	
							"float dx0 = -1.0 * xPixelOffset;",
							"float dy0 = -1.0 * yPixelOffset;",
							"float dx1 = 1.0 * xPixelOffset;",
							"float dy1 = 1.0 * yPixelOffset;",
	
							"mat3 shadowKernel;",
							"mat3 depthKernel;",
	
							"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
							"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
							"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
							"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
							"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
							"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
							"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
							"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
							"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
	
							"vec3 shadowZ = vec3( shadowCoord.z );",
							"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
							"shadowKernel[0] *= vec3(0.25);",
														
							"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
							"shadowKernel[1] *= vec3(0.25);",
	
							"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
							"shadowKernel[2] *= vec3(0.25);",
	
							"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",
	
							"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
							"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
	
							"vec4 shadowValues;",
							"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
							"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
							"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
							"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
	
							"shadow = dot( shadowValues, vec4( 1.0 ) );",
	
							"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
	
						"#else",
	
							"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
							"float fDepth = unpackDepth( rgbaDepth );",
	
							"if ( fDepth < shadowCoord.z )",
	
								// spot with multiple shadows is darker
	
								"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",
	
								// spot with multiple shadows has the same color as single shadow spot
	
								//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",
	
						"#endif",
	
					"}",
	
	
					"#ifdef SHADOWMAP_DEBUG",
	
						"#ifdef SHADOWMAP_CASCADE",
	
							"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",
	
						"#else",
	
							"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",
	
						"#endif",
	
					"#endif",
	
				"}",
	
				"#ifdef GAMMA_OUTPUT",
	
					"shadowColor *= shadowColor;",
	
				"#endif",
	
				"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",
	
			"#endif"
	
		].join("\n"),
	
		shadowmap_pars_vertex: [
	
			"#ifdef USE_SHADOWMAP",
	
				"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
				"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",
	
			"#endif"
	
		].join("\n"),
	
		shadowmap_vertex: [
	
			"#ifdef USE_SHADOWMAP",
	
				"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
	
					"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// ALPHATEST
	
		alphatest_fragment: [
	
			"#ifdef ALPHATEST",
	
				"if ( gl_FragColor.a < ALPHATEST ) discard;",
	
			"#endif"
	
		].join("\n"),
	
		// LINEAR SPACE
	
		linear_to_gamma_fragment: [
	
			"#ifdef GAMMA_OUTPUT",
	
				"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",
	
			"#endif"
	
		].join("\n")
	
	
	};
	/**
	 * Uniform Utilities
	 */
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var u, p, tmp, merged = {};
	
			for ( u = 0; u < uniforms.length; u ++ ) {
	
				tmp = this.clone( uniforms[ u ] );
	
				for ( p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		clone: function ( uniforms_src ) {
	
			var u, p, parameter, parameter_src, uniforms_dst = {};
	
			for ( u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( p in uniforms_src[ u ] ) {
	
					parameter_src = uniforms_src[ u ][ p ];
	
					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.clone();
	
					} else if ( parameter_src instanceof Array ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.slice();
	
					} else {
	
						uniforms_dst[ u ][ p ] = parameter_src;
	
					}
	
				}
	
			}
	
			return uniforms_dst;
	
		}
	
	};
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
	
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"lightMap" : { type: "t", value: null },
			"specularMap" : { type: "t", value: null },
	
			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: -1 },
			"useRefract" : { type: "i", value: 0 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 },
			"combine" : { type: "i", value: 0 },
	
			"morphTargetInfluences" : { type: "f", value: 0 }
	
		},
	
		bump: {
	
			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }
	
		},
	
		normalmap: {
	
			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
		},
	
		fog : {
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		lights: {
	
			"ambientLightColor" : { type: "fv", value: [] },
	
			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },
	
			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },
	
			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
	
			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] }
	
		},
	
		particle: {
	
			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		shadowmap: {
	
			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },
	
			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },
	
			"shadowMatrix" : { type: "m4v", value: [] }
	
		}
	
	};
	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
					"#ifdef USE_ENVMAP",
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					"#endif",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define LAMBERT",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
					"varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float opacity;",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
					"varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
					"#ifdef DOUBLE_SIDED",
	
						//"float isFront = float( gl_FrontFacing );",
						//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",
	
						"if ( gl_FrontFacing )",
							"gl_FragColor.xyz *= vLightFront;",
						"else",
							"gl_FragColor.xyz *= vLightBack;",
	
					"#else",
	
						"gl_FragColor.xyz *= vLightFront;",
	
					"#endif",
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "bump" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define PHONG",
	
				"varying vec3 vViewPosition;",
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					"vNormal = normalize( transformedNormal );",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
					"vViewPosition = -mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform vec3 ambient;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
					THREE.ShaderChunk[ "lights_phong_fragment" ],
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'particle_basic': {
	
			uniforms:  THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "particle" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				"uniform float size;",
				"uniform float scale;",
	
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	
					"#ifdef USE_SIZEATTENUATION",
						"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
					"#else",
						"gl_PointSize = size;",
					"#endif",
	
					"gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 psColor;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( psColor, opacity );",
	
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
	
				{
					"scale":     { type: "f", value: 1 },
					"dashSize":  { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}
	
			] ),
	
			vertexShader: [
	
				"uniform float scale;",
				"attribute float lineDistance;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "color_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
					"vLineDistance = scale * lineDistance;",
	
					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
					"gl_Position = projectionMatrix * mvPosition;",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform float dashSize;",
				"uniform float totalSize;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
	
				"void main() {",
	
					"if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	
						"discard;",
	
					"}",
	
					"gl_FragColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'depth': {
	
			uniforms: {
	
				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"void main() {",
	
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",
	
				"void main() {",
	
					"float depth = gl_FragCoord.z / gl_FragCoord.w;",
					"float color = 1.0 - smoothstep( mNear, mFar, depth );",
					"gl_FragColor = vec4( vec3( color ), opacity );",
	
				"}"
	
			].join("\n")
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
	
				"void main() {",
	
					"vNormal = normalize( normalMatrix * normal );",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float opacity;",
				"varying vec3 vNormal;",
	
				"void main() {",
	
					"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
	
				"}"
	
			].join("\n")
	
		},
	
		/* -------------------------------------------------------------------------
		//	Normal map shader
		//		- Blinn-Phong
		//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
		//		- point and directional lights (use with "lights: true" material option)
		 ------------------------------------------------------------------------- */
	
		'normalmap' : {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
	
				"enableAO"		  : { type: "i", value: 0 },
				"enableDiffuse"	  : { type: "i", value: 0 },
				"enableSpecular"  : { type: "i", value: 0 },
				"enableReflection": { type: "i", value: 0 },
				"enableDisplacement": { type: "i", value: 0 },
	
				"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
				"tDiffuse"	   : { type: "t", value: null },
				"tCube"		   : { type: "t", value: null },
				"tNormal"	   : { type: "t", value: null },
				"tSpecular"	   : { type: "t", value: null },
				"tAO"		   : { type: "t", value: null },
	
				"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },
	
				"uDisplacementBias": { type: "f", value: 0.0 },
				"uDisplacementScale": { type: "f", value: 1.0 },
	
				"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
				"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
				"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
				"shininess": { type: "f", value: 30 },
				"opacity": { type: "f", value: 1 },
	
				"useRefract": { type: "i", value: 0 },
				"refractionRatio": { type: "f", value: 0.98 },
				"reflectivity": { type: "f", value: 0.5 },
	
				"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
				"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },
	
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
	
				}
	
			] ),
	
			fragmentShader: [
	
				"uniform vec3 ambient;",
				"uniform vec3 diffuse;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",
	
				"uniform bool enableDiffuse;",
				"uniform bool enableSpecular;",
				"uniform bool enableAO;",
				"uniform bool enableReflection;",
	
				"uniform sampler2D tDiffuse;",
				"uniform sampler2D tNormal;",
				"uniform sampler2D tSpecular;",
				"uniform sampler2D tAO;",
	
				"uniform samplerCube tCube;",
	
				"uniform vec2 uNormalScale;",
	
				"uniform bool useRefract;",
				"uniform float refractionRatio;",
				"uniform float reflectivity;",
	
				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",
	
				"uniform vec3 ambientLightColor;",
	
				"#if MAX_DIR_LIGHTS > 0",
	
					"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
					"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
	
				"#endif",
	
				"#if MAX_HEMI_LIGHTS > 0",
	
					"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
					"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
					"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
	
				"#endif",
	
				"#if MAX_POINT_LIGHTS > 0",
	
					"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
					"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
					"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
				"#endif",
	
				"#if MAX_SPOT_LIGHTS > 0",
	
					"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
					"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
					"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
					"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
					"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
					"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
	
				"#endif",
	
				"#ifdef WRAP_AROUND",
	
					"uniform vec3 wrapRGB;",
	
				"#endif",
	
				"varying vec3 vWorldPosition;",
				"varying vec3 vViewPosition;",
	
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( vec3( 1.0 ), opacity );",
	
					"vec3 specularTex = vec3( 1.0 );",
	
					"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
					"normalTex.xy *= uNormalScale;",
					"normalTex = normalize( normalTex );",
	
					"if( enableDiffuse ) {",
	
						"#ifdef GAMMA_INPUT",
	
							"vec4 texelColor = texture2D( tDiffuse, vUv );",
							"texelColor.xyz *= texelColor.xyz;",
	
							"gl_FragColor = gl_FragColor * texelColor;",
	
						"#else",
	
							"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",
	
						"#endif",
	
					"}",
	
					"if( enableAO ) {",
	
						"#ifdef GAMMA_INPUT",
	
							"vec4 aoColor = texture2D( tAO, vUv );",
							"aoColor.xyz *= aoColor.xyz;",
	
							"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",
	
						"#else",
	
							"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",
	
						"#endif",
	
					"}",
	
					"if( enableSpecular )",
						"specularTex = texture2D( tSpecular, vUv ).xyz;",
	
					"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
					"vec3 finalNormal = tsb * normalTex;",
	
					"#ifdef FLIP_SIDED",
	
						"finalNormal = -finalNormal;",
	
					"#endif",
	
					"vec3 normal = normalize( finalNormal );",
					"vec3 viewPosition = normalize( vViewPosition );",
	
					// point lights
	
					"#if MAX_POINT_LIGHTS > 0",
	
						"vec3 pointDiffuse = vec3( 0.0 );",
						"vec3 pointSpecular = vec3( 0.0 );",
	
						"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
							"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
							"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",
	
							"float pointDistance = 1.0;",
							"if ( pointLightDistance[ i ] > 0.0 )",
								"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",
	
							"pointVector = normalize( pointVector );",
	
							// diffuse
	
							"#ifdef WRAP_AROUND",
	
								"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
								"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",
	
								"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
	
							"#else",
	
								"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",
	
							"#endif",
	
							"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",
	
							// specular
	
							"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
							"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
							"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
	
							// 2.0 => 2.0001 is hack to work around ANGLE bug
	
							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
							"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
							"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",
	
						"}",
	
					"#endif",
	
					// spot lights
	
					"#if MAX_SPOT_LIGHTS > 0",
	
						"vec3 spotDiffuse = vec3( 0.0 );",
						"vec3 spotSpecular = vec3( 0.0 );",
	
						"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
							"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
							"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",
	
							"float spotDistance = 1.0;",
							"if ( spotLightDistance[ i ] > 0.0 )",
								"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",
	
							"spotVector = normalize( spotVector );",
	
							"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
	
							"if ( spotEffect > spotLightAngleCos[ i ] ) {",
	
								"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
	
								// diffuse
	
								"#ifdef WRAP_AROUND",
	
									"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
									"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",
	
									"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
	
								"#else",
	
									"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",
	
								"#endif",
	
								"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",
	
								// specular
	
								"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
								"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
								"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",
	
								// 2.0 => 2.0001 is hack to work around ANGLE bug
	
								"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
								"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
								"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",
	
							"}",
	
						"}",
	
					"#endif",
	
					// directional lights
	
					"#if MAX_DIR_LIGHTS > 0",
	
						"vec3 dirDiffuse = vec3( 0.0 );",
						"vec3 dirSpecular = vec3( 0.0 );",
	
						"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",
	
							"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
							"vec3 dirVector = normalize( lDirection.xyz );",
	
							// diffuse
	
							"#ifdef WRAP_AROUND",
	
								"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
								"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",
	
								"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",
	
							"#else",
	
								"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",
	
							"#endif",
	
							"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",
	
							// specular
	
							"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
							"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
							"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",
	
							// 2.0 => 2.0001 is hack to work around ANGLE bug
	
							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
							"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
							"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
	
						"}",
	
					"#endif",
	
					// hemisphere lights
	
					"#if MAX_HEMI_LIGHTS > 0",
	
						"vec3 hemiDiffuse  = vec3( 0.0 );",
						"vec3 hemiSpecular = vec3( 0.0 );" ,
	
						"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
	
							"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
							"vec3 lVector = normalize( lDirection.xyz );",
	
							// diffuse
	
							"float dotProduct = dot( normal, lVector );",
							"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
	
							"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
	
							"hemiDiffuse += diffuse * hemiColor;",
	
							// specular (sky light)
	
	
							"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
							"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
							"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",
	
							// specular (ground light)
	
							"vec3 lVectorGround = -lVector;",
	
							"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
							"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
							"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",
	
							"float dotProductGround = dot( normal, lVectorGround );",
	
							// 2.0 => 2.0001 is hack to work around ANGLE bug
	
							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
							"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
							"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
							"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
	
						"}",
	
					"#endif",
	
					// all lights contribution summation
	
					"vec3 totalDiffuse = vec3( 0.0 );",
					"vec3 totalSpecular = vec3( 0.0 );",
	
					"#if MAX_DIR_LIGHTS > 0",
	
						"totalDiffuse += dirDiffuse;",
						"totalSpecular += dirSpecular;",
	
					"#endif",
	
					"#if MAX_HEMI_LIGHTS > 0",
	
						"totalDiffuse += hemiDiffuse;",
						"totalSpecular += hemiSpecular;",
	
					"#endif",
	
					"#if MAX_POINT_LIGHTS > 0",
	
						"totalDiffuse += pointDiffuse;",
						"totalSpecular += pointSpecular;",
	
					"#endif",
	
					"#if MAX_SPOT_LIGHTS > 0",
	
						"totalDiffuse += spotDiffuse;",
						"totalSpecular += spotSpecular;",
	
					"#endif",
	
					"#ifdef METAL",
	
						"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",
	
					"#else",
	
						"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",
	
					"#endif",
	
					"if ( enableReflection ) {",
	
						"vec3 vReflect;",
						"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
	
						"if ( useRefract ) {",
	
							"vReflect = refract( cameraToVertex, normal, refractionRatio );",
	
						"} else {",
	
							"vReflect = reflect( cameraToVertex, normal );",
	
						"}",
	
						"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
	
						"#ifdef GAMMA_INPUT",
	
							"cubeColor.xyz *= cubeColor.xyz;",
	
						"#endif",
	
						"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",
	
					"}",
	
					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n"),
	
			vertexShader: [
	
				"attribute vec4 tangent;",
	
				"uniform vec2 uOffset;",
				"uniform vec2 uRepeat;",
	
				"uniform bool enableDisplacement;",
	
				"#ifdef VERTEX_TEXTURES",
	
					"uniform sampler2D tDisplacement;",
					"uniform float uDisplacementScale;",
					"uniform float uDisplacementBias;",
	
				"#endif",
	
				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",
	
				"varying vec3 vWorldPosition;",
				"varying vec3 vViewPosition;",
	
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
	
					// normal, tangent and binormal vectors
	
					"#ifdef USE_SKINNING",
	
						"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",
	
						"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
						"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",
	
					"#else",
	
						"vNormal = normalize( normalMatrix * normal );",
						"vTangent = normalize( normalMatrix * tangent.xyz );",
	
					"#endif",
	
					"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",
	
					"vUv = uv * uRepeat + uOffset;",
	
					// displacement mapping
	
					"vec3 displacedPosition;",
	
					"#ifdef VERTEX_TEXTURES",
	
						"if ( enableDisplacement ) {",
	
							"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
							"float df = uDisplacementScale * dv.x + uDisplacementBias;",
							"displacedPosition = position + normalize( normal ) * df;",
	
						"} else {",
	
							"#ifdef USE_SKINNING",
	
								"vec4 skinVertex = vec4( position, 1.0 );",
	
								"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
								"skinned 	  += boneMatY * skinVertex * skinWeight.y;",
	
								"displacedPosition  = skinned.xyz;",
	
							"#else",
	
								"displacedPosition = position;",
	
							"#endif",
	
						"}",
	
					"#else",
	
						"#ifdef USE_SKINNING",
	
							"vec4 skinVertex = vec4( position, 1.0 );",
	
							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",
	
							"displacedPosition  = skinned.xyz;",
	
						"#else",
	
							"displacedPosition = position;",
	
						"#endif",
	
					"#endif",
	
					//
	
					"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
					"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",
	
					"gl_Position = projectionMatrix * mvPosition;",
	
					//
	
					"vWorldPosition = worldPosition.xyz;",
					"vViewPosition = -mvPosition.xyz;",
	
					// shadows
	
					"#ifdef USE_SHADOWMAP",
	
						"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
	
							"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
	
						"}",
	
					"#endif",
	
				"}"
	
			].join("\n")
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: -1 } },
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				"void main() {",
	
					"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
					"vWorldPosition = worldPosition.xyz;",
	
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform samplerCube tCube;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				"void main() {",
	
					"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	
				"}"
	
			].join("\n")
	
		},
	
		// Depth encoding into RGBA texture
		// 	based on SpiderGL shadow map example
		// 		http://spidergl.org/example.php?id=6
		// 	originally from
		//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		// 	see also here:
		//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	
		'depthRGBA': {
	
			uniforms: {},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"vec4 pack_depth( const in float depth ) {",
	
					"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
					"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
					"vec4 res = fract( depth * bit_shift );",
					"res -= res.xxyz * bit_mask;",
					"return res;",
	
				"}",
	
				"void main() {",
	
					"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
	
					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
	
				"}"
	
			].join("\n")
	
		}
	
	};
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	
		_precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
		this.devicePixelRatio = parameters.devicePixelRatio !== undefined
					? parameters.devicePixelRatio
					: self.devicePixelRatio !== undefined
						? self.devicePixelRatio
						: 1;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
		this.autoUpdateObjects = true;
	
		// physically based shading
	
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// shadow map
	
		this.shadowMapEnabled = false;
		this.shadowMapAutoUpdate = true;
		this.shadowMapType = THREE.PCFShadowMap;
		this.shadowMapCullFace = THREE.CullFaceFront;
		this.shadowMapDebug = false;
		this.shadowMapCascade = false;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
	
		// custom render plugins
	
		this.renderPluginsPre = [];
		this.renderPluginsPost = [];
	
		// info
	
		this.info = {
	
			memory: {
	
				programs: 0,
				geometries: 0,
				textures: 0
	
			},
	
			render: {
	
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0
	
			}
	
		};
	
		// internal properties
	
		var _this = this,
	
		_programs = [],
		_programs_counter = 0,
	
		// internal state cache
	
		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = -1,
		_currentGeometryGroupHash = null,
		_currentCamera = null,
		_geometryGroupCounter = 0,
	
		_usedTextureUnits = 0,
	
		// GL state cache
	
		_oldDoubleSided = -1,
		_oldFlipSided = -1,
	
		_oldBlending = -1,
	
		_oldBlendEquation = -1,
		_oldBlendSrc = -1,
		_oldBlendDst = -1,
	
		_oldDepthTest = -1,
		_oldDepthWrite = -1,
	
		_oldPolygonOffset = null,
		_oldPolygonOffsetFactor = null,
		_oldPolygonOffsetUnits = null,
	
		_oldLineWidth = null,
	
		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,
	
		_enabledAttributes = {},
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		 // camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
		_projScreenMatrixPS = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_direction = new THREE.Vector3(),
	
		_lightsNeedUpdate = true,
	
		_lights = {
	
			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors: new Array(), positions: new Array() },
			point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
			spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
			hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }
	
		};
	
		// initialize
	
		var _gl;
	
		var _glExtensionTextureFloat;
		var _glExtensionTextureFloatLinear;
		var _glExtensionStandardDerivatives;
		var _glExtensionTextureFilterAnisotropic;
		var _glExtensionCompressedTextureS3TC;
	
		initGL();
	
		setDefaultGLState();
	
		this.context = _gl;
	
		// GPU capabilities
	
		var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
		var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
		var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;
	
		var _supportsVertexTextures = ( _maxVertexTextures > 0 );
		var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;
	
		var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];
	
		//
	
		var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
		var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
		var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );
	
		var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
		var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
		var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );
	
		var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
		var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
		var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );
	
		var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
		var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
		var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );
	
		// clamp precision to maximum available
	
		var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
		var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
	
		if ( _precision === "highp" && ! highpAvailable ) {
	
			if ( mediumpAvailable ) {
	
				_precision = "mediump";
				console.warn( "WebGLRenderer: highp not supported, using mediump" );
	
			} else {
	
				_precision = "lowp";
				console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );
	
			}
	
		}
	
		if ( _precision === "mediump" && ! mediumpAvailable ) {
	
			_precision = "lowp";
			console.warn( "WebGLRenderer: mediump not supported, using lowp" );
	
		}
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.supportsVertexTextures = function () {
	
			return _supportsVertexTextures;
	
		};
	
		this.supportsFloatTextures = function () {
	
			return _glExtensionTextureFloat;
	
		};
	
		this.supportsStandardDerivatives = function () {
	
			return _glExtensionStandardDerivatives;
	
		};
	
		this.supportsCompressedTextureS3TC = function () {
	
			return _glExtensionCompressedTextureS3TC;
	
		};
	
		this.getMaxAnisotropy  = function () {
	
			return _maxAnisotropy;
	
		};
	
		this.getPrecision = function () {
	
			return _precision;
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_canvas.width = width * this.devicePixelRatio;
			_canvas.height = height * this.devicePixelRatio;
	
			if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, _canvas.width, _canvas.height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			_viewportX = x !== undefined ? x : 0;
			_viewportY = y !== undefined ? y : 0;
	
			_viewportWidth = width !== undefined ? width : _canvas.width;
			_viewportHeight = height !== undefined ? height : _canvas.height;
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			_gl.scissor( x, y, width, height );
	
		};
	
		this.enableScissorTest = function ( enable ) {
	
			enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );
	
		};
	
		// Clearing
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.setClearColorHex = function ( hex, alpha ) {
	
			console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
			this.setClearColor( hex, alpha );
	
		};
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			_gl.clear( _gl.COLOR_BUFFER_BIT );
	
		};
	
		this.clearDepth = function () {
	
			_gl.clear( _gl.DEPTH_BUFFER_BIT );
	
		};
	
		this.clearStencil = function () {
	
			_gl.clear( _gl.STENCIL_BUFFER_BIT );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Plugins
	
		this.addPostPlugin = function ( plugin ) {
	
			plugin.init( this );
			this.renderPluginsPost.push( plugin );
	
		};
	
		this.addPrePlugin = function ( plugin ) {
	
			plugin.init( this );
			this.renderPluginsPre.push( plugin );
	
		};
	
		// Rendering
	
		this.updateShadowMap = function ( scene, camera ) {
	
			_currentProgram = null;
			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;
			_lightsNeedUpdate = true;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
	
			this.shadowMapPlugin.update( scene, camera );
	
		};
	
		// Internal functions
	
		// Buffer allocation
	
		function createParticleBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createLineBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglLineDistanceBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createMeshBuffers ( geometryGroup ) {
	
			geometryGroup.__webglVertexBuffer = _gl.createBuffer();
			geometryGroup.__webglNormalBuffer = _gl.createBuffer();
			geometryGroup.__webglTangentBuffer = _gl.createBuffer();
			geometryGroup.__webglColorBuffer = _gl.createBuffer();
			geometryGroup.__webglUVBuffer = _gl.createBuffer();
			geometryGroup.__webglUV2Buffer = _gl.createBuffer();
	
			geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
			geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
	
			geometryGroup.__webglFaceBuffer = _gl.createBuffer();
			geometryGroup.__webglLineBuffer = _gl.createBuffer();
	
			var m, ml;
	
			if ( geometryGroup.numMorphTargets ) {
	
				geometryGroup.__webglMorphTargetsBuffers = [];
	
				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
					geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );
	
				}
	
			}
	
			if ( geometryGroup.numMorphNormals ) {
	
				geometryGroup.__webglMorphNormalsBuffers = [];
	
				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
					geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );
	
				}
	
			}
	
			_this.info.memory.geometries ++;
	
		};
	
		// Events
	
		var onGeometryDispose = function ( event ) {
	
			var geometry = event.target;
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			deallocateGeometry( geometry );
	
		};
	
		var onTextureDispose = function ( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_this.info.memory.textures --;
	
	
		};
	
		var onRenderTargetDispose = function ( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_this.info.memory.textures --;
	
		};
	
		var onMaterialDispose = function ( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		};
	
		// Buffer deallocation
	
		var deleteBuffers = function ( geometry ) {
	
			if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
			if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
			if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
			if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
			if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
			if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );
	
			if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
			if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );
	
			if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
			if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );
	
			if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
			// custom attributes
	
			if ( geometry.__webglCustomAttributesList !== undefined ) {
	
				for ( var id in geometry.__webglCustomAttributesList ) {
	
					_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );
	
				}
	
			}
	
			_this.info.memory.geometries --;
	
		};
	
		var deallocateGeometry = function ( geometry ) {
	
			geometry.__webglInit = undefined;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var attributes = geometry.attributes;
	
				for ( var key in attributes ) {
	
					if ( attributes[ key ].buffer !== undefined ) {
	
						_gl.deleteBuffer( attributes[ key ].buffer );
			
					}
	
				}
	
				_this.info.memory.geometries --;
	
			} else {
	
				if ( geometry.geometryGroups !== undefined ) {
	
					for ( var g in geometry.geometryGroups ) {
	
						var geometryGroup = geometry.geometryGroups[ g ];
	
						if ( geometryGroup.numMorphTargets !== undefined ) {
	
							for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
								_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );
	
							}
	
						}
	
						if ( geometryGroup.numMorphNormals !== undefined ) {
	
							for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
								_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );
	
							}
	
						}
	
						deleteBuffers( geometryGroup );
	
					}
	
				} else {
	
					deleteBuffers( geometry );
	
				}
	
			}
	
		};
	
		var deallocateTexture = function ( texture ) {
	
			if ( texture.image && texture.image.__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( texture.image.__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( ! texture.__webglInit ) return;
	
				texture.__webglInit = false;
				_gl.deleteTexture( texture.__webglTexture );
	
			}
	
		};
	
		var deallocateRenderTarget = function ( renderTarget ) {
	
			if ( !renderTarget || ! renderTarget.__webglTexture ) return;
	
			_gl.deleteTexture( renderTarget.__webglTexture );
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );
	
			}
	
		};
	
		var deallocateMaterial = function ( material ) {
	
			var program = material.program;
	
			if ( program === undefined ) return;
	
			material.program = undefined;
	
			// only deallocate GL program if this was the last use of shared program
			// assumed there is only single copy of any program in the _programs list
			// (that's how it's constructed)
	
			var i, il, programInfo;
			var deleteProgram = false;
	
			for ( i = 0, il = _programs.length; i < il; i ++ ) {
	
				programInfo = _programs[ i ];
	
				if ( programInfo.program === program ) {
	
					programInfo.usedTimes --;
	
					if ( programInfo.usedTimes === 0 ) {
	
						deleteProgram = true;
	
					}
	
					break;
	
				}
	
			}
	
			if ( deleteProgram === true ) {
	
				// avoid using array.splice, this is costlier than creating new array from scratch
	
				var newPrograms = [];
	
				for ( i = 0, il = _programs.length; i < il; i ++ ) {
	
					programInfo = _programs[ i ];
	
					if ( programInfo.program !== program ) {
	
						newPrograms.push( programInfo );
	
					}
	
				}
	
				_programs = newPrograms;
	
				_gl.deleteProgram( program );
	
				_this.info.memory.programs --;
	
			}
	
		};
	
		// Buffer initialization
	
		function initCustomAttributes ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			var material = object.material;
	
			if ( material.attributes ) {
	
				if ( geometry.__webglCustomAttributesList === undefined ) {
	
					geometry.__webglCustomAttributesList = [];
	
				}
	
				for ( var a in material.attributes ) {
	
					var attribute = material.attributes[ a ];
	
					if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {
	
						attribute.__webglInitialized = true;
	
						var size = 1;		// "f" and "i"
	
						if ( attribute.type === "v2" ) size = 2;
						else if ( attribute.type === "v3" ) size = 3;
						else if ( attribute.type === "v4" ) size = 4;
						else if ( attribute.type === "c"  ) size = 3;
	
						attribute.size = size;
	
						attribute.array = new Float32Array( nvertices * size );
	
						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = a;
	
						attribute.needsUpdate = true;
	
					}
	
					geometry.__webglCustomAttributesList.push( attribute );
	
				}
	
			}
	
		};
	
		function initParticleBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
	
			geometry.__sortArray = [];
	
			geometry.__webglParticleCount = nvertices;
	
			initCustomAttributes ( geometry, object );
	
		};
	
		function initLineBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );
	
			geometry.__webglLineCount = nvertices;
	
			initCustomAttributes ( geometry, object );
	
		};
	
		function initMeshBuffers ( geometryGroup, object ) {
	
			var geometry = object.geometry,
				faces3 = geometryGroup.faces3,
	
				nvertices = faces3.length * 3,
				ntris     = faces3.length * 1,
				nlines    = faces3.length * 3,
	
				material = getBufferMaterial( object, geometryGroup ),
	
				uvType = bufferGuessUVType( material ),
				normalType = bufferGuessNormalType( material ),
				vertexColorType = bufferGuessVertexColorType( material );
	
			// console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );
	
			geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
	
			if ( normalType ) {
	
				geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
	
			}
	
			if ( geometry.hasTangents ) {
	
				geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );
	
			}
	
			if ( vertexColorType ) {
	
				geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
	
			}
	
			if ( uvType ) {
	
				if ( geometry.faceVertexUvs.length > 0 ) {
	
					geometryGroup.__uvArray = new Float32Array( nvertices * 2 );
	
				}
	
				if ( geometry.faceVertexUvs.length > 1 ) {
	
					geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );
	
				}
	
			}
	
			if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {
	
				geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
				geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );
	
			}
	
			geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
			geometryGroup.__lineArray = new Uint16Array( nlines * 2 );
	
			var m, ml;
	
			if ( geometryGroup.numMorphTargets ) {
	
				geometryGroup.__morphTargetsArrays = [];
	
				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
					geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );
	
				}
	
			}
	
			if ( geometryGroup.numMorphNormals ) {
	
				geometryGroup.__morphNormalsArrays = [];
	
				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
					geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );
	
				}
	
			}
	
			geometryGroup.__webglFaceCount = ntris * 3;
			geometryGroup.__webglLineCount = nlines * 2;
	
	
			// custom attributes
	
			if ( material.attributes ) {
	
				if ( geometryGroup.__webglCustomAttributesList === undefined ) {
	
					geometryGroup.__webglCustomAttributesList = [];
	
				}
	
				for ( var a in material.attributes ) {
	
					// Do a shallow copy of the attribute object so different geometryGroup chunks use different
					// attribute buffers which are correctly indexed in the setMeshBuffers function
	
					var originalAttribute = material.attributes[ a ];
	
					var attribute = {};
	
					for ( var property in originalAttribute ) {
	
						attribute[ property ] = originalAttribute[ property ];
	
					}
	
					if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {
	
						attribute.__webglInitialized = true;
	
						var size = 1;		// "f" and "i"
	
						if( attribute.type === "v2" ) size = 2;
						else if( attribute.type === "v3" ) size = 3;
						else if( attribute.type === "v4" ) size = 4;
						else if( attribute.type === "c"  ) size = 3;
	
						attribute.size = size;
	
						attribute.array = new Float32Array( nvertices * size );
	
						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = a;
	
						originalAttribute.needsUpdate = true;
						attribute.__original = originalAttribute;
	
					}
	
					geometryGroup.__webglCustomAttributesList.push( attribute );
	
				}
	
			}
	
			geometryGroup.__inittedArrays = true;
	
		};
	
		function getBufferMaterial( object, geometryGroup ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ geometryGroup.materialIndex ]
				: object.material;
	
		};
	
		function materialNeedsSmoothNormals ( material ) {
	
			return material && material.shading !== undefined && material.shading === THREE.SmoothShading;
	
		};
	
		function bufferGuessNormalType ( material ) {
	
			// only MeshBasicMaterial and MeshDepthMaterial don't need normals
	
			if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {
	
				return false;
	
			}
	
			if ( materialNeedsSmoothNormals( material ) ) {
	
				return THREE.SmoothShading;
	
			} else {
	
				return THREE.FlatShading;
	
			}
	
		};
	
		function bufferGuessVertexColorType( material ) {
	
			if ( material.vertexColors ) {
	
				return material.vertexColors;
	
			}
	
			return false;
	
		};
	
		function bufferGuessUVType( material ) {
	
			// material must use some texture to require uvs
	
			if ( material.map ||
			     material.lightMap ||
			     material.bumpMap ||
			     material.normalMap ||
			     material.specularMap ||
			     material instanceof THREE.ShaderMaterial ) {
	
				return true;
	
			}
	
			return false;
	
		};
	
		//
	
		function initDirectBuffers( geometry ) {
	
			var a, attribute, type;
	
			for ( a in geometry.attributes ) {
	
				if ( a === "index" ) {
	
					type = _gl.ELEMENT_ARRAY_BUFFER;
	
				} else {
	
					type = _gl.ARRAY_BUFFER;
	
				}
	
				attribute = geometry.attributes[ a ];
	
				if ( attribute.numItems === undefined ) {
	
					attribute.numItems = attribute.array.length;
	
				}
	
				attribute.buffer = _gl.createBuffer();
	
				_gl.bindBuffer( type, attribute.buffer );
				_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );
	
			}
	
		};
	
		// Buffer setting
	
		function setParticleBuffers ( geometry, hint, object ) {
	
			var v, c, vertex, offset, index, color,
	
			vertices = geometry.vertices,
			vl = vertices.length,
	
			colors = geometry.colors,
			cl = colors.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
	
			sortArray = geometry.__sortArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList,
			i, il,
			a, ca, cal, value,
			customAttribute;
	
			if ( object.sortParticles ) {
	
				_projScreenMatrixPS.copy( _projScreenMatrix );
				_projScreenMatrixPS.multiply( object.matrixWorld );
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					_vector3.copy( vertex );
					_vector3.applyProjection( _projScreenMatrixPS );
	
					sortArray[ v ] = [ _vector3.z, v ];
	
				}
	
				sortArray.sort( numericalSort );
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ sortArray[v][1] ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				for ( c = 0; c < cl; c ++ ) {
	
					offset = c * 3;
	
					color = colors[ sortArray[c][1] ];
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				if ( customAttributes ) {
	
					for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
						customAttribute = customAttributes[ i ];
	
						if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;
	
						offset = 0;
	
						cal = customAttribute.value.length;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								index = sortArray[ ca ][ 1 ];
	
								customAttribute.array[ ca ] = customAttribute.value[ index ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								index = sortArray[ ca ][ 1 ];
	
								value = customAttribute.value[ index ];
	
								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === "c" ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									index = sortArray[ ca ][ 1 ];
	
									value = customAttribute.value[ index ];
	
									customAttribute.array[ offset ]     = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									index = sortArray[ ca ][ 1 ];
	
									value = customAttribute.value[ index ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								index = sortArray[ ca ][ 1 ];
	
								value = customAttribute.value[ index ];
	
								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
					}
	
				}
	
			} else {
	
				if ( dirtyVertices ) {
	
					for ( v = 0; v < vl; v ++ ) {
	
						vertex = vertices[ v ];
	
						offset = v * 3;
	
						vertexArray[ offset ]     = vertex.x;
						vertexArray[ offset + 1 ] = vertex.y;
						vertexArray[ offset + 2 ] = vertex.z;
	
					}
	
				}
	
				if ( dirtyColors ) {
	
					for ( c = 0; c < cl; c ++ ) {
	
						color = colors[ c ];
	
						offset = c * 3;
	
						colorArray[ offset ]     = color.r;
						colorArray[ offset + 1 ] = color.g;
						colorArray[ offset + 2 ] = color.b;
	
					}
	
				}
	
				if ( customAttributes ) {
	
					for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
						customAttribute = customAttributes[ i ];
	
						if ( customAttribute.needsUpdate &&
							 ( customAttribute.boundTo === undefined ||
							   customAttribute.boundTo === "vertices") ) {
	
							cal = customAttribute.value.length;
	
							offset = 0;
	
							if ( customAttribute.size === 1 ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
								}
	
							} else if ( customAttribute.size === 2 ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
	
									offset += 2;
	
								}
	
							} else if ( customAttribute.size === 3 ) {
	
								if ( customAttribute.type === "c" ) {
	
									for ( ca = 0; ca < cal; ca ++ ) {
	
										value = customAttribute.value[ ca ];
	
										customAttribute.array[ offset ] 	= value.r;
										customAttribute.array[ offset + 1 ] = value.g;
										customAttribute.array[ offset + 2 ] = value.b;
	
										offset += 3;
	
									}
	
								} else {
	
									for ( ca = 0; ca < cal; ca ++ ) {
	
										value = customAttribute.value[ ca ];
	
										customAttribute.array[ offset ] 	= value.x;
										customAttribute.array[ offset + 1 ] = value.y;
										customAttribute.array[ offset + 2 ] = value.z;
	
										offset += 3;
	
									}
	
								}
	
							} else if ( customAttribute.size === 4 ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ]      = value.x;
									customAttribute.array[ offset + 1  ] = value.y;
									customAttribute.array[ offset + 2  ] = value.z;
									customAttribute.array[ offset + 3  ] = value.w;
	
									offset += 4;
	
								}
	
							}
	
						}
	
					}
	
				}
	
			}
	
			if ( dirtyVertices || object.sortParticles ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors || object.sortParticles ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate || object.sortParticles ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
					}
	
				}
	
			}
	
	
		};
	
		function setLineBuffers ( geometry, hint ) {
	
			var v, c, d, vertex, offset, color,
	
			vertices = geometry.vertices,
			colors = geometry.colors,
			lineDistances = geometry.lineDistances,
	
			vl = vertices.length,
			cl = colors.length,
			dl = lineDistances.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			lineDistanceArray = geometry.__lineDistanceArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyLineDistances = geometry.lineDistancesNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList,
	
			i, il,
			a, ca, cal, value,
			customAttribute;
	
			if ( dirtyVertices ) {
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors ) {
	
				for ( c = 0; c < cl; c ++ ) {
	
					color = colors[ c ];
	
					offset = c * 3;
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( dirtyLineDistances ) {
	
				for ( d = 0; d < dl; d ++ ) {
	
					lineDistanceArray[ d ] = lineDistances[ d ];
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices" ) ) {
	
						offset = 0;
	
						cal = customAttribute.value.length;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === "c" ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ] 	 = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
					}
	
				}
	
			}
	
		};
	
		function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {
	
			if ( ! geometryGroup.__inittedArrays ) {
	
				return;
	
			}
	
			var normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material ),
			uvType = bufferGuessUVType( material ),
	
			needsSmoothNormals = ( normalType === THREE.SmoothShading );
	
			var f, fl, fi, face,
			vertexNormals, faceNormal, normal,
			vertexColors, faceColor,
			vertexTangents,
			uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
			c1, c2, c3, c4,
			sw1, sw2, sw3, sw4,
			si1, si2, si3, si4,
			sa1, sa2, sa3, sa4,
			sb1, sb2, sb3, sb4,
			m, ml, i, il,
			vn, uvi, uv2i,
			vk, vkl, vka,
			nka, chf, faceVertexNormals,
			a,
	
			vertexIndex = 0,
	
			offset = 0,
			offset_uv = 0,
			offset_uv2 = 0,
			offset_face = 0,
			offset_normal = 0,
			offset_tangent = 0,
			offset_line = 0,
			offset_color = 0,
			offset_skin = 0,
			offset_morphTarget = 0,
			offset_custom = 0,
			offset_customSrc = 0,
	
			value,
	
			vertexArray = geometryGroup.__vertexArray,
			uvArray = geometryGroup.__uvArray,
			uv2Array = geometryGroup.__uv2Array,
			normalArray = geometryGroup.__normalArray,
			tangentArray = geometryGroup.__tangentArray,
			colorArray = geometryGroup.__colorArray,
	
			skinIndexArray = geometryGroup.__skinIndexArray,
			skinWeightArray = geometryGroup.__skinWeightArray,
	
			morphTargetsArrays = geometryGroup.__morphTargetsArrays,
			morphNormalsArrays = geometryGroup.__morphNormalsArrays,
	
			customAttributes = geometryGroup.__webglCustomAttributesList,
			customAttribute,
	
			faceArray = geometryGroup.__faceArray,
			lineArray = geometryGroup.__lineArray,
	
			geometry = object.geometry, // this is shared for all chunks
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyUvs = geometry.uvsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
			dirtyTangents = geometry.tangentsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyMorphTargets = geometry.morphTargetsNeedUpdate,
	
			vertices = geometry.vertices,
			chunk_faces3 = geometryGroup.faces3,
			obj_faces = geometry.faces,
	
			obj_uvs  = geometry.faceVertexUvs[ 0 ],
			obj_uvs2 = geometry.faceVertexUvs[ 1 ],
	
			obj_colors = geometry.colors,
	
			obj_skinIndices = geometry.skinIndices,
			obj_skinWeights = geometry.skinWeights,
	
			morphTargets = geometry.morphTargets,
			morphNormals = geometry.morphNormals;
	
			if ( dirtyVertices ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];
	
					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;
	
					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;
	
					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;
	
					offset += 9;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyMorphTargets ) {
	
				for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {
	
					offset_morphTarget = 0;
	
					for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
						chf = chunk_faces3[ f ];
						face = obj_faces[ chf ];
	
						// morph positions
	
						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];
	
						vka = morphTargetsArrays[ vk ];
	
						vka[ offset_morphTarget ] 	  = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;
	
						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;
	
						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;
	
						// morph normals
	
						if ( material.morphNormals ) {
	
							if ( needsSmoothNormals ) {
	
								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];
	
								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;
	
							} else {
	
								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;
	
							}
	
							nka = morphNormalsArrays[ vk ];
	
							nka[ offset_morphTarget ] 	  = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;
	
							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;
	
							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;
	
						}
	
						//
	
						offset_morphTarget += 9;
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );
	
					if ( material.morphNormals ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
						_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );
	
					}
	
				}
	
			}
	
			if ( obj_skinWeights.length ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					// weights
	
					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];
	
					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;
	
					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;
	
					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;
	
					// indices
	
					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];
	
					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;
	
					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;
	
					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;
	
					offset_skin += 12;
	
				}
	
				if ( offset_skin > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );
	
				}
	
			}
	
			if ( dirtyColors && vertexColorType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					vertexColors = face.vertexColors;
					faceColor = face.color;
	
					if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {
	
						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];
	
					} else {
	
						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;
	
					}
	
					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;
	
					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;
	
					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;
	
					offset_color += 9;
	
				}
	
				if ( offset_color > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
				}
	
			}
	
			if ( dirtyTangents && geometry.hasTangents ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					vertexTangents = face.vertexTangents;
	
					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];
	
					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;
	
					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;
	
					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;
	
					offset_tangent += 12;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );
	
			}
	
			if ( dirtyNormals && normalType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;
	
					if ( vertexNormals.length === 3 && needsSmoothNormals ) {
	
						for ( i = 0; i < 3; i ++ ) {
	
							vn = vertexNormals[ i ];
	
							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;
	
							offset_normal += 3;
	
						}
	
					} else {
	
						for ( i = 0; i < 3; i ++ ) {
	
							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;
	
							offset_normal += 3;
	
						}
	
					}
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );
	
			}
	
			if ( dirtyUvs && obj_uvs && uvType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					fi = chunk_faces3[ f ];
	
					uv = obj_uvs[ fi ];
	
					if ( uv === undefined ) continue;
	
					for ( i = 0; i < 3; i ++ ) {
	
						uvi = uv[ i ];
	
						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;
	
						offset_uv += 2;
	
					}
	
				}
	
				if ( offset_uv > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );
	
				}
	
			}
	
			if ( dirtyUvs && obj_uvs2 && uvType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					fi = chunk_faces3[ f ];
	
					uv2 = obj_uvs2[ fi ];
	
					if ( uv2 === undefined ) continue;
	
					for ( i = 0; i < 3; i ++ ) {
	
						uv2i = uv2[ i ];
	
						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;
	
						offset_uv2 += 2;
	
					}
	
				}
	
				if ( offset_uv2 > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );
	
				}
	
			}
	
			if ( dirtyElements ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					faceArray[ offset_face ] 	 = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 2;
	
					offset_face += 3;
	
					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;
	
					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 2;
	
					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;
	
					offset_line += 6;
	
					vertexIndex += 3;
	
				}
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( ! customAttribute.__original.needsUpdate ) continue;
	
					offset_custom = 0;
					offset_customSrc = 0;
	
					if ( customAttribute.size === 1 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
	
								offset_custom += 3;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								customAttribute.array[ offset_custom ] 	   = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;
	
								offset_custom += 3;
	
							}
	
						}
	
					} else if ( customAttribute.size === 2 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom ] 	   = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								offset_custom += 6;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom ] 	   = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								offset_custom += 6;
	
							}
	
						}
	
					} else if ( customAttribute.size === 3 ) {
	
						var pp;
	
						if ( customAttribute.type === "c" ) {
	
							pp = [ "r", "g", "b" ];
	
						} else {
	
							pp = [ "x", "y", "z" ];
	
						}
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
						} else if ( customAttribute.boundTo === "faceVertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
	
								customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
						}
	
					} else if ( customAttribute.size === 4 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
						} else if ( customAttribute.boundTo === "faceVertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
						}
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
				}
	
			}
	
			if ( dispose ) {
	
				delete geometryGroup.__inittedArrays;
				delete geometryGroup.__colorArray;
				delete geometryGroup.__normalArray;
				delete geometryGroup.__tangentArray;
				delete geometryGroup.__uvArray;
				delete geometryGroup.__uv2Array;
				delete geometryGroup.__faceArray;
				delete geometryGroup.__vertexArray;
				delete geometryGroup.__lineArray;
				delete geometryGroup.__skinIndexArray;
				delete geometryGroup.__skinWeightArray;
	
			}
	
		};
	
		function setDirectBuffers ( geometry, hint, dispose ) {
	
			var attributes = geometry.attributes;
	
			var attributeName, attributeItem;
	
			for ( attributeName in attributes ) {
	
				attributeItem = attributes[ attributeName ];
	
				if ( attributeItem.needsUpdate ) {
	
					if ( attributeName === 'index' ) {
	
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
						_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );
	
					} else {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );
	
					}
	
					attributeItem.needsUpdate = false;
	
				}
	
				if ( dispose && ! attributeItem.dynamic ) {
	
					attributeItem.array = null;
	
				}
	
			}
	
		};
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
			if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
			if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
			if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.position );
				_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );
	
				if ( material.shading === THREE.FlatShading ) {
	
					var nx, ny, nz,
						nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
						normalArray,
						i, il = object.count * 3;
	
					for( i = 0; i < il; i += 9 ) {
	
						normalArray = object.normalArray;
	
						nax  = normalArray[ i ];
						nay  = normalArray[ i + 1 ];
						naz  = normalArray[ i + 2 ];
	
						nbx  = normalArray[ i + 3 ];
						nby  = normalArray[ i + 4 ];
						nbz  = normalArray[ i + 5 ];
	
						ncx  = normalArray[ i + 6 ];
						ncy  = normalArray[ i + 7 ];
						ncz  = normalArray[ i + 8 ];
	
						nx = ( nax + nbx + ncx ) / 3;
						ny = ( nay + nby + ncy ) / 3;
						nz = ( naz + nbz + ncz ) / 3;
	
						normalArray[ i ] 	 = nx;
						normalArray[ i + 1 ] = ny;
						normalArray[ i + 2 ] = nz;
	
						normalArray[ i + 3 ] = nx;
						normalArray[ i + 4 ] = ny;
						normalArray[ i + 5 ] = nz;
	
						normalArray[ i + 6 ] = nx;
						normalArray[ i + 7 ] = ny;
						normalArray[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.normal );
				_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.uv );
				_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.color );
				_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {
	
			if ( material.visible === false ) return;
	
			var linewidth, a, attribute;
			var attributeItem, attributeName, attributePointer, attributeSize;
	
			var program = setProgram( camera, lights, fog, material, object );
	
			var programAttributes = program.attributes;
			var geometryAttributes = geometry.attributes;
	
			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;
	
			if ( geometryHash !== _currentGeometryGroupHash ) {
	
				_currentGeometryGroupHash = geometryHash;
				updateBuffers = true;
	
			}
	
			if ( updateBuffers ) {
	
				disableAttributes();
	
			}
	
			// render mesh
	
			if ( object instanceof THREE.Mesh ) {
	
				var index = geometryAttributes[ "index" ];
	
				// indexed triangles
	
				if ( index ) {
	
					var offsets = geometry.offsets;
	
					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change
	
					if ( offsets.length > 1 ) updateBuffers = true;
	
					for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
						var startIndex = offsets[ i ].index;
	
						if ( updateBuffers ) {
	
							for ( attributeName in programAttributes ) {
	
								attributePointer = programAttributes[ attributeName ];
								attributeItem = geometryAttributes[ attributeName ];
	
								if ( attributePointer >= 0 ) {
	
									if ( attributeItem ) {
	
										attributeSize = attributeItem.itemSize;
										_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
										enableAttribute( attributePointer );
										_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32
	
									} else if ( material.defaultAttributeValues ) {
	
										if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {
	
											_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
										} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {
	
											_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
										}
	
									}
	
								}
	
							}
	
							// indices
	
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
						}
	
						// render indexed triangles
	
						_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16
	
						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
						_this.info.render.faces += offsets[ i ].count / 3;
	
					}
	
				// non-indexed triangles
	
				} else {
	
					if ( updateBuffers ) {
	
						for ( attributeName in programAttributes ) {
	
							if ( attributeName === 'index') continue;
	
							attributePointer = programAttributes[ attributeName ];
							attributeItem = geometryAttributes[ attributeName ];
							
							if ( attributePointer >= 0 ) {
	
								if ( attributeItem ) {
	
									attributeSize = attributeItem.itemSize;
									_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
									enableAttribute( attributePointer );
									_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );
	
								} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {
	
									if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {
	
										_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
									} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {
	
										_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
									}
	
								}
	
							}
	
						}
	
					}
	
					var position = geometry.attributes[ "position" ];
	
					// render non-indexed triangles
	
					_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );
	
					_this.info.render.calls ++;
					_this.info.render.vertices += position.numItems / 3;
					_this.info.render.faces += position.numItems / 3 / 3;
	
				}
	
			// render particles
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				if ( updateBuffers ) {
	
					for ( attributeName in programAttributes ) {
	
						attributePointer = programAttributes[ attributeName ];
						attributeItem = geometryAttributes[ attributeName ];
						
						if ( attributePointer >= 0 ) {
	
							if ( attributeItem ) {
	
								attributeSize = attributeItem.itemSize;
								_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
								enableAttribute( attributePointer );
								_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );
	
							} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {
	
								if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {
	
									_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
								} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {
	
									_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				var position = geometryAttributes[ "position" ];
	
				// render particles
	
				_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );
	
				_this.info.render.calls ++;
				_this.info.render.points += position.numItems / 3;
	
			} else if ( object instanceof THREE.Line ) {
	
				if ( updateBuffers ) {
	
					for ( attributeName in programAttributes ) {
	
						attributePointer = programAttributes[ attributeName ];
						attributeItem = geometryAttributes[ attributeName ];
						
						if ( attributePointer >= 0 ) {
	
							if ( attributeItem ) {
	
								attributeSize = attributeItem.itemSize;
								_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
								enableAttribute( attributePointer );
								_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );
	
							} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {
	
								if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {
	
									_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
								} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {
	
									_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				// render lines
	
				var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;
	
				setLineWidth( material.linewidth );
	
				var position = geometryAttributes[ "position" ];
	
				_gl.drawArrays( primitives, 0, position.numItems / 3 );
	
				_this.info.render.calls ++;
				_this.info.render.points += position.numItems;
	
			}
	
		};
	
		this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {
	
			if ( material.visible === false ) return;
	
			var linewidth, a, attribute, i, il;
	
			var program = setProgram( camera, lights, fog, material, object );
	
			var attributes = program.attributes;
	
			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;
	
			if ( geometryGroupHash !== _currentGeometryGroupHash ) {
	
				_currentGeometryGroupHash = geometryGroupHash;
				updateBuffers = true;
	
			}
	
			if ( updateBuffers ) {
	
				disableAttributes();
	
			}
	
			// vertices
	
			if ( !material.morphTargets && attributes.position >= 0 ) {
	
				if ( updateBuffers ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
					enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
			} else {
	
				if ( object.morphTargetBase ) {
	
					setupMorphTargets( material, geometryGroup, object );
	
				}
	
			}
	
	
			if ( updateBuffers ) {
	
				// custom attributes
	
				// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers
	
				if ( geometryGroup.__webglCustomAttributesList ) {
	
					for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {
	
						attribute = geometryGroup.__webglCustomAttributesList[ i ];
	
						if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
							enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
							_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );
	
						}
	
					}
	
				}
	
	
				// colors
	
				if ( attributes.color >= 0 ) {
	
					if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
						enableAttribute( attributes.color );
						_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
					} else if ( material.defaultAttributeValues ) {
	
	
						_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );
	
					}
	
				}
	
				// normals
	
				if ( attributes.normal >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
					enableAttribute( attributes.normal );
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// tangents
	
				if ( attributes.tangent >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
					enableAttribute( attributes.tangent );
					_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// uvs
	
				if ( attributes.uv >= 0 ) {
	
					if ( object.geometry.faceVertexUvs[0] ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
						enableAttribute( attributes.uv );
						_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
					} else if ( material.defaultAttributeValues ) {
	
	
						_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );
	
					}
	
				}
	
				if ( attributes.uv2 >= 0 ) {
	
					if ( object.geometry.faceVertexUvs[1] ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
						enableAttribute( attributes.uv2 );
						_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );
	
					} else if ( material.defaultAttributeValues ) {
	
	
						_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );
	
					}
	
				}
	
				if ( material.skinning &&
					 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					enableAttribute( attributes.skinIndex );
					_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					enableAttribute( attributes.skinWeight );
					_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// line distances
	
				if ( attributes.lineDistance >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
					enableAttribute( attributes.lineDistance );
					_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );
	
				}
	
			}
	
			// render mesh
	
			if ( object instanceof THREE.Mesh ) {
	
				// wireframe
	
				if ( material.wireframe ) {
	
					setLineWidth( material.wireframeLinewidth );
	
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
					_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );
	
				// triangles
	
				} else {
	
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
					_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );
	
				}
	
				_this.info.render.calls ++;
				_this.info.render.vertices += geometryGroup.__webglFaceCount;
				_this.info.render.faces += geometryGroup.__webglFaceCount / 3;
	
			// render lines
	
			} else if ( object instanceof THREE.Line ) {
	
				var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;
	
				setLineWidth( material.linewidth );
	
				_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );
	
				_this.info.render.calls ++;
	
			// render particles
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );
	
				_this.info.render.calls ++;
				_this.info.render.points += geometryGroup.__webglParticleCount;
	
			}
	
		};
	
		function enableAttribute( attribute ) {
	
			if ( ! _enabledAttributes[ attribute ] ) {
	
				_gl.enableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = true;
	
			}
	
		};
	
		function disableAttributes() {
	
			for ( var attribute in _enabledAttributes ) {
	
				if ( _enabledAttributes[ attribute ] ) {
	
					_gl.disableVertexAttribArray( attribute );
					_enabledAttributes[ attribute ] = false;
	
				}
	
			}
	
		};
	
		function setupMorphTargets ( material, geometryGroup, object ) {
	
			// set base
	
			var attributes = material.program.attributes;
	
			if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			} else if ( attributes.position >= 0 ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.morphTargetForcedOrder.length ) {
	
				// set forced order
	
				var m = 0;
				var order = object.morphTargetForcedOrder;
				var influences = object.morphTargetInfluences;
	
				while ( m < material.numSupportedMorphTargets && m < order.length ) {
	
					if ( attributes[ "morphTarget" + m ] >= 0 ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
					}
	
					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
					}
	
					object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];
	
					m ++;
				}
	
			} else {
	
				// find the most influencing
	
				var influence, activeInfluenceIndices = [];
				var influences = object.morphTargetInfluences;
				var i, il = influences.length;
	
				for ( i = 0; i < il; i ++ ) {
	
					influence = influences[ i ];
	
					if ( influence > 0 ) {
	
						activeInfluenceIndices.push( [ influence, i ] );
	
					}
	
				}
	
				if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {
	
					activeInfluenceIndices.sort( numericalSort );
					activeInfluenceIndices.length = material.numSupportedMorphTargets;
	
				} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {
	
					activeInfluenceIndices.sort( numericalSort );
	
				} else if ( activeInfluenceIndices.length === 0 ) {
	
					activeInfluenceIndices.push( [ 0, 0 ] );
	
				};
	
				var influenceIndex, m = 0;
	
				while ( m < material.numSupportedMorphTargets ) {
	
					if ( activeInfluenceIndices[ m ] ) {
	
						influenceIndex = activeInfluenceIndices[ m ][ 1 ];
	
						if ( attributes[ "morphTarget" + m ] >= 0 ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
							enableAttribute( attributes[ "morphTarget" + m ] );
							_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						}
	
						if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
							enableAttribute( attributes[ "morphNormal" + m ] );
							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
	
						}
	
						object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];
	
					} else {
	
						/*
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						if ( material.morphNormals ) {
	
							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						}
						*/
	
						object.__webglMorphTargetInfluences[ m ] = 0;
	
					}
	
					m ++;
	
				}
	
			}
	
			// load updated influences uniform
	
			if ( material.program.uniforms.morphTargetInfluences !== null ) {
	
				_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );
	
			}
	
		};
	
		// Sorting
	
		function painterSortStable ( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		};
	
		function numericalSort ( a, b ) {
	
			return b[ 0 ] - a[ 0 ];
	
		};
	
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var i, il,
	
			webglObject, object,
			renderList,
	
			lights = scene.__lights,
			fog = scene.fog;
	
			// reset caching for this frame
	
			_currentMaterialId = -1;
			_lightsNeedUpdate = true;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === undefined ) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			// update WebGL objects
	
			if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );
	
			// custom render plugins (pre pass)
	
			renderPlugins( this.renderPluginsPre, scene, camera );
	
			//
	
			_this.info.render.calls = 0;
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_this.info.render.points = 0;
	
			this.setRenderTarget( renderTarget );
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			// set matrices for regular objects (frustum culled)
	
			renderList = scene.__webglObjects;
	
			for ( i = 0, il = renderList.length; i < il; i ++ ) {
	
				webglObject = renderList[ i ];
				object = webglObject.object;
	
				webglObject.id = i;
				webglObject.render = false;
	
				if ( object.visible ) {
	
					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {
	
						setupMatrices( object, camera );
	
						unrollBufferMaterial( webglObject );
	
						webglObject.render = true;
	
						if ( this.sortObjects === true ) {
	
							if ( object.renderDepth !== null ) {
	
								webglObject.z = object.renderDepth;
	
							} else {
	
								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
								webglObject.z = _vector3.z;
	
							}
	
						}
	
					}
	
				}
	
			}
	
			if ( this.sortObjects ) {
	
				renderList.sort( painterSortStable );
	
			}
	
			// set matrices for immediate objects
	
			renderList = scene.__webglObjectsImmediate;
	
			for ( i = 0, il = renderList.length; i < il; i ++ ) {
	
				webglObject = renderList[ i ];
				object = webglObject.object;
	
				if ( object.visible ) {
	
					setupMatrices( object, camera );
	
					unrollImmediateBufferMaterial( webglObject );
	
				}
	
			}
	
			if ( scene.overrideMaterial ) {
	
				var material = scene.overrideMaterial;
	
				this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				this.setDepthTest( material.depthTest );
				this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
				renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
				renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );
	
			} else {
	
				var material = null;
	
				// opaque pass (front-to-back order)
	
				this.setBlending( THREE.NoBlending );
	
				renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
				renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );
	
				// transparent pass (back-to-front order)
	
				renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
				renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );
	
			}
	
			// custom render plugins (post pass)
	
			renderPlugins( this.renderPluginsPost, scene, camera );
	
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {
	
				updateRenderTargetMipmap( renderTarget );
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			this.setDepthTest( true );
			this.setDepthWrite( true );
	
			// _gl.finish();
	
		};
	
		function renderPlugins( plugins, scene, camera ) {
	
			if ( ! plugins.length ) return;
	
			for ( var i = 0, il = plugins.length; i < il; i ++ ) {
	
				// reset state for plugin (to start from clean slate)
	
				_currentProgram = null;
				_currentCamera = null;
	
				_oldBlending = -1;
				_oldDepthTest = -1;
				_oldDepthWrite = -1;
				_oldDoubleSided = -1;
				_oldFlipSided = -1;
				_currentGeometryGroupHash = -1;
				_currentMaterialId = -1;
	
				_lightsNeedUpdate = true;
	
				plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );
	
				// reset state after plugin (anything could have changed)
	
				_currentProgram = null;
				_currentCamera = null;
	
				_oldBlending = -1;
				_oldDepthTest = -1;
				_oldDepthWrite = -1;
				_oldDoubleSided = -1;
				_oldFlipSided = -1;
				_currentGeometryGroupHash = -1;
				_currentMaterialId = -1;
	
				_lightsNeedUpdate = true;
	
			}
	
		};
	
		function renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {
	
			var webglObject, object, buffer, material, start, end, delta;
	
			if ( reverse ) {
	
				start = renderList.length - 1;
				end = -1;
				delta = -1;
	
			} else {
	
				start = 0;
				end = renderList.length;
				delta = 1;
			}
	
			for ( var i = start; i !== end; i += delta ) {
	
				webglObject = renderList[ i ];
	
				if ( webglObject.render ) {
	
					object = webglObject.object;
					buffer = webglObject.buffer;
	
					if ( overrideMaterial ) {
	
						material = overrideMaterial;
	
					} else {
	
						material = webglObject[ materialType ];
	
						if ( ! material ) continue;
	
						if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
	
						_this.setDepthTest( material.depthTest );
						_this.setDepthWrite( material.depthWrite );
						setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
					}
	
					_this.setMaterialFaces( material );
	
					if ( buffer instanceof THREE.BufferGeometry ) {
	
						_this.renderBufferDirect( camera, lights, fog, material, buffer, object );
	
					} else {
	
						_this.renderBuffer( camera, lights, fog, material, buffer, object );
	
					}
	
				}
	
			}
	
		};
	
		function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {
	
			var webglObject, object, material, program;
	
			for ( var i = 0, il = renderList.length; i < il; i ++ ) {
	
				webglObject = renderList[ i ];
				object = webglObject.object;
	
				if ( object.visible ) {
	
					if ( overrideMaterial ) {
	
						material = overrideMaterial;
	
					} else {
	
						material = webglObject[ materialType ];
	
						if ( ! material ) continue;
	
						if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
	
						_this.setDepthTest( material.depthTest );
						_this.setDepthWrite( material.depthWrite );
						setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
					}
	
					_this.renderImmediateObject( camera, lights, fog, material, object );
	
				}
	
			}
	
		};
	
		this.renderImmediateObject = function ( camera, lights, fog, material, object ) {
	
			var program = setProgram( camera, lights, fog, material, object );
	
			_currentGeometryGroupHash = -1;
	
			_this.setMaterialFaces( material );
	
			if ( object.immediateRenderCallback ) {
	
				object.immediateRenderCallback( program, _gl, _frustum );
	
			} else {
	
				object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );
	
			}
	
		};
	
		function unrollImmediateBufferMaterial ( globject ) {
	
			var object = globject.object,
				material = object.material;
	
			if ( material.transparent ) {
	
				globject.transparent = material;
				globject.opaque = null;
	
			} else {
	
				globject.opaque = material;
				globject.transparent = null;
	
			}
	
		};
	
		function unrollBufferMaterial ( globject ) {
	
			var object = globject.object,
				buffer = globject.buffer,
				material, materialIndex, meshMaterial;
	
			meshMaterial = object.material;
	
			if ( meshMaterial instanceof THREE.MeshFaceMaterial ) {
	
				materialIndex = buffer.materialIndex;
	
				material = meshMaterial.materials[ materialIndex ];
	
				if ( material.transparent ) {
	
					globject.transparent = material;
					globject.opaque = null;
	
				} else {
	
					globject.opaque = material;
					globject.transparent = null;
	
				}
	
			} else {
	
				material = meshMaterial;
	
				if ( material ) {
	
					if ( material.transparent ) {
	
						globject.transparent = material;
						globject.opaque = null;
	
					} else {
	
						globject.opaque = material;
						globject.transparent = null;
	
					}
	
				}
	
			}
	
		};
	
		// Geometry splitting
	
		function sortFacesByMaterial ( geometry, material ) {
	
			var f, fl, face, materialIndex, vertices,
				groupHash, hash_map = {};
	
			var numMorphTargets = geometry.morphTargets.length;
			var numMorphNormals = geometry.morphNormals.length;
	
			var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;
	
			geometry.geometryGroups = {};
	
			for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {
	
				face = geometry.faces[ f ];
				materialIndex = usesFaceMaterial ? face.materialIndex : 0;
	
				if ( hash_map[ materialIndex ] === undefined ) {
	
					hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };
	
				}
	
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;
	
				if ( geometry.geometryGroups[ groupHash ] === undefined ) {
	
					geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };
	
				}
	
				vertices = 3;
	
				if ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {
	
					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;
	
					if ( geometry.geometryGroups[ groupHash ] === undefined ) {
	
						geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };
	
					}
	
				}
	
				geometry.geometryGroups[ groupHash ].faces3.push( f );
				geometry.geometryGroups[ groupHash ].vertices += vertices;
	
			}
	
			geometry.geometryGroupsList = [];
	
			for ( var g in geometry.geometryGroups ) {
	
				geometry.geometryGroups[ g ].id = _geometryGroupCounter ++;
	
				geometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );
	
			}
	
		};
	
		// Objects refresh
	
		this.initWebGLObjects = function ( scene ) {
	
			if ( !scene.__webglObjects ) {
	
				scene.__webglObjects = [];
				scene.__webglObjectsImmediate = [];
				scene.__webglSprites = [];
				scene.__webglFlares = [];
	
			}
	
			while ( scene.__objectsAdded.length ) {
	
				addObject( scene.__objectsAdded[ 0 ], scene );
				scene.__objectsAdded.splice( 0, 1 );
	
			}
	
			while ( scene.__objectsRemoved.length ) {
	
				removeObject( scene.__objectsRemoved[ 0 ], scene );
				scene.__objectsRemoved.splice( 0, 1 );
	
			}
	
			// update must be called after objects adding / removal
	
			for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {
	
				var object = scene.__webglObjects[ o ].object;
	
				// TODO: Remove this hack (WebGLRenderer refactoring)
	
				if ( object.__webglInit === undefined ) {
	
					if ( object.__webglActive !== undefined ) {
	
						removeObject( object, scene );
	
					}
	
					addObject( object, scene );
	
				}
	
				updateObject( object );
	
			}
	
		};
	
		// Objects adding
	
		function addObject( object, scene ) {
	
			var g, geometry, material, geometryGroup;
	
			if ( object.__webglInit === undefined ) {
	
				object.__webglInit = true;
	
				object._modelViewMatrix = new THREE.Matrix4();
				object._normalMatrix = new THREE.Matrix3();
	
				if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {
	
					object.geometry.__webglInit = true;
					object.geometry.addEventListener( 'dispose', onGeometryDispose );
	
				}
	
				geometry = object.geometry;
	
				if ( geometry === undefined ) {
	
					// fail silently for now
	
				} else if ( geometry instanceof THREE.BufferGeometry ) {
	
					initDirectBuffers( geometry );
	
				} else if ( object instanceof THREE.Mesh ) {
	
					material = object.material;
	
					if ( geometry.geometryGroups === undefined ) {
	
						sortFacesByMaterial( geometry, material );
	
					}
	
					// create separate VBOs per geometry chunk
	
					for ( g in geometry.geometryGroups ) {
	
						geometryGroup = geometry.geometryGroups[ g ];
	
						// initialise VBO on the first access
	
						if ( ! geometryGroup.__webglVertexBuffer ) {
	
							createMeshBuffers( geometryGroup );
							initMeshBuffers( geometryGroup, object );
	
							geometry.verticesNeedUpdate = true;
							geometry.morphTargetsNeedUpdate = true;
							geometry.elementsNeedUpdate = true;
							geometry.uvsNeedUpdate = true;
							geometry.normalsNeedUpdate = true;
							geometry.tangentsNeedUpdate = true;
							geometry.colorsNeedUpdate = true;
	
						}
	
					}
	
				} else if ( object instanceof THREE.Line ) {
	
					if ( ! geometry.__webglVertexBuffer ) {
	
						createLineBuffers( geometry );
						initLineBuffers( geometry, object );
	
						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
						geometry.lineDistancesNeedUpdate = true;
	
					}
	
				} else if ( object instanceof THREE.ParticleSystem ) {
	
					if ( ! geometry.__webglVertexBuffer ) {
	
						createParticleBuffers( geometry );
						initParticleBuffers( geometry, object );
	
						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
	
					}
	
				}
	
			}
	
			if ( object.__webglActive === undefined ) {
	
				if ( object instanceof THREE.Mesh ) {
	
					geometry = object.geometry;
	
					if ( geometry instanceof THREE.BufferGeometry ) {
	
						addBuffer( scene.__webglObjects, geometry, object );
	
					} else if ( geometry instanceof THREE.Geometry ) {
	
						for ( g in geometry.geometryGroups ) {
	
							geometryGroup = geometry.geometryGroups[ g ];
	
							addBuffer( scene.__webglObjects, geometryGroup, object );
	
						}
	
					}
	
				} else if ( object instanceof THREE.Line ||
							object instanceof THREE.ParticleSystem ) {
	
					geometry = object.geometry;
					addBuffer( scene.__webglObjects, geometry, object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {
	
					addBufferImmediate( scene.__webglObjectsImmediate, object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					scene.__webglSprites.push( object );
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					scene.__webglFlares.push( object );
	
				}
	
				object.__webglActive = true;
	
			}
	
		};
	
		function addBuffer( objlist, buffer, object ) {
	
			objlist.push(
				{
					id: null,
					buffer: buffer,
					object: object,
					opaque: null,
					transparent: null,
					z: 0
				}
			);
	
		};
	
		function addBufferImmediate( objlist, object ) {
	
			objlist.push(
				{
					id: null,
					object: object,
					opaque: null,
					transparent: null,
					z: 0
				}
			);
	
		};
	
		// Objects updates
	
		function updateObject( object ) {
	
			var geometry = object.geometry,
				geometryGroup, customAttributesDirty, material;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );
	
			} else if ( object instanceof THREE.Mesh ) {
	
				// check all geometry groups
	
				for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {
	
					geometryGroup = geometry.geometryGroupsList[ i ];
	
					material = getBufferMaterial( object, geometryGroup );
	
					if ( geometry.buffersNeedUpdate ) {
	
						initMeshBuffers( geometryGroup, object );
	
					}
	
					customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {
	
						setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );
	
					}
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;
	
				geometry.buffersNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
			} else if ( object instanceof THREE.Line ) {
	
				material = getBufferMaterial( object, geometry );
	
				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {
	
					setLineBuffers( geometry, _gl.DYNAMIC_DRAW );
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.lineDistancesNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				material = getBufferMaterial( object, geometry );
	
				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {
	
					setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
			}
	
		};
	
		// Objects updates - custom attributes check
	
		function areCustomAttributesDirty( material ) {
	
			for ( var a in material.attributes ) {
	
				if ( material.attributes[ a ].needsUpdate ) return true;
	
			}
	
			return false;
	
		};
	
		function clearCustomAttributes( material ) {
	
			for ( var a in material.attributes ) {
	
				material.attributes[ a ].needsUpdate = false;
	
			}
	
		};
	
		// Objects removal
	
		function removeObject( object, scene ) {
	
			if ( object instanceof THREE.Mesh  ||
				 object instanceof THREE.ParticleSystem ||
				 object instanceof THREE.Line ) {
	
				removeInstances( scene.__webglObjects, object );
	
			} else if ( object instanceof THREE.Sprite ) {
	
				removeInstancesDirect( scene.__webglSprites, object );
	
			} else if ( object instanceof THREE.LensFlare ) {
	
				removeInstancesDirect( scene.__webglFlares, object );
	
			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {
	
				removeInstances( scene.__webglObjectsImmediate, object );
	
			}
	
			delete object.__webglActive;
	
		};
	
		function removeInstances( objlist, object ) {
	
			for ( var o = objlist.length - 1; o >= 0; o -- ) {
	
				if ( objlist[ o ].object === object ) {
	
					objlist.splice( o, 1 );
	
				}
	
			}
	
		};
	
		function removeInstancesDirect( objlist, object ) {
	
			for ( var o = objlist.length - 1; o >= 0; o -- ) {
	
				if ( objlist[ o ] === object ) {
	
					objlist.splice( o, 1 );
	
				}
	
			}
	
		};
	
		// Materials
	
		this.initMaterial = function ( material, lights, fog, object ) {
	
			material.addEventListener( 'dispose', onMaterialDispose );
	
			var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;
	
			if ( material instanceof THREE.MeshDepthMaterial ) {
	
				shaderID = 'depth';
	
			} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
				shaderID = 'normal';
	
			} else if ( material instanceof THREE.MeshBasicMaterial ) {
	
				shaderID = 'basic';
	
			} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
				shaderID = 'lambert';
	
			} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
				shaderID = 'phong';
	
			} else if ( material instanceof THREE.LineBasicMaterial ) {
	
				shaderID = 'basic';
	
			} else if ( material instanceof THREE.LineDashedMaterial ) {
	
				shaderID = 'dashed';
	
			} else if ( material instanceof THREE.ParticleSystemMaterial ) {
	
				shaderID = 'particle_basic';
	
			}
	
			if ( shaderID ) {
	
				setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );
	
			}
	
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			maxLightCount = allocateLights( lights );
	
			maxShadows = allocateShadows( lights );
	
			maxBones = allocateBones( object );
	
			parameters = {
	
				map: !!material.map,
				envMap: !!material.envMap,
				lightMap: !!material.lightMap,
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				specularMap: !!material.specularMap,
	
				vertexColors: material.vertexColors,
	
				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				sizeAttenuation: material.sizeAttenuation,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: this.maxMorphTargets,
				maxMorphNormals: this.maxMorphNormals,
	
				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,
	
				maxShadows: maxShadows,
				shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
				shadowMapType: this.shadowMapType,
				shadowMapDebug: this.shadowMapDebug,
				shadowMapCascade: this.shadowMapCascade,
	
				alphaTest: material.alphaTest,
				metal: material.metal,
				perPixel: material.perPixel,
				wrapAround: material.wrapAround,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide
	
			};
	
			material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );
	
			var attributes = material.program.attributes;
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				var id, base = "morphTarget";
	
				for ( i = 0; i < this.maxMorphTargets; i ++ ) {
	
					id = base + i;
	
					if ( attributes[ id ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				var id, base = "morphNormal";
	
				for ( i = 0; i < this.maxMorphNormals; i ++ ) {
	
					id = base + i;
	
					if ( attributes[ id ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			material.uniformsList = [];
	
			for ( u in material.uniforms ) {
	
				material.uniformsList.push( [ material.uniforms[ u ], u ] );
	
			}
	
		};
	
		function setMaterialShaders( material, shaders ) {
	
			material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
			material.vertexShader = shaders.vertexShader;
			material.fragmentShader = shaders.fragmentShader;
	
		};
	
		function setProgram( camera, lights, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			if ( material.needsUpdate ) {
	
				if ( material.program ) deallocateMaterial( material );
	
				_this.initMaterial( material, lights, fog, object );
				material.needsUpdate = false;
	
			}
	
			if ( material.morphTargets ) {
	
				if ( ! object.__webglMorphTargetInfluences ) {
	
					object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );
	
				}
	
			}
	
			var refreshMaterial = false;
	
			var program = material.program,
				p_uniforms = program.uniforms,
				m_uniforms = material.uniforms;
	
			if ( program !== _currentProgram ) {
	
				_gl.useProgram( program );
				_currentProgram = program;
	
				refreshMaterial = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				_currentMaterialId = material.id;
				refreshMaterial = true;
	
			}
	
			if ( refreshMaterial || camera !== _currentCamera ) {
	
				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				if ( camera !== _currentCamera ) _currentCamera = camera;
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				if ( _supportsBoneTextures && object.useVertexTexture ) {
	
					if ( p_uniforms.boneTexture !== null ) {
	
						var textureUnit = getTextureUnit();
	
						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.boneTexture, textureUnit );
	
					}
	
					if ( p_uniforms.boneTextureWidth !== null ) {
	
						_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );
	
					}
	
					if ( p_uniforms.boneTextureHeight !== null ) {
	
						_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );
	
					}
	
				} else {
	
					if ( p_uniforms.boneGlobalMatrices !== null ) {
	
						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {
	
					if ( _lightsNeedUpdate ) {
	
						setupLights( program, lights );
						_lightsNeedUpdate = false;
	
					}
	
					refreshUniformsLights( m_uniforms, _lights );
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.ParticleSystemMaterial ) {
	
					refreshUniformsParticle( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				if ( object.receiveShadow && ! material._shadowPass ) {
	
					refreshUniformsShadow( m_uniforms, lights );
	
				}
	
				// load common uniforms
	
				loadUniformsGeneric( program, material.uniformsList );
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {
	
					if ( p_uniforms.cameraPosition !== null ) {
	
						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					if ( p_uniforms.viewMatrix !== null ) {
	
						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );
	
					}
	
				}
	
			}
	
			loadUniformsMatrices( p_uniforms, object );
	
			if ( p_uniforms.modelMatrix !== null ) {
	
				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );
	
			}
	
			return program;
	
		};
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			if ( _this.gammaInput ) {
	
				uniforms.diffuse.value.copyGammaToLinear( material.color );
	
			} else {
	
				uniforms.diffuse.value = material.color;
	
			}
	
			uniforms.map.value = material.map;
			uniforms.lightMap.value = material.lightMap;
			uniforms.specularMap.value = material.specularMap;
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			// uv repeat and offset setting priorities
			//	1. color map
			//	2. specular map
			//	3. normal map
			//	4. bump map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
	
			if ( _this.gammaInput ) {
	
				//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
				uniforms.reflectivity.value = material.reflectivity;
	
			} else {
	
				uniforms.reflectivity.value = material.reflectivity;
	
			}
	
			uniforms.refractionRatio.value = material.refractionRatio;
			uniforms.combine.value = material.combine;
			uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;
	
		};
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		};
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		};
	
		function refreshUniformsParticle ( uniforms, material ) {
	
			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.
	
			uniforms.map.value = material.map;
	
		};
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		};
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.shininess.value = material.shininess;
	
			if ( _this.gammaInput ) {
	
				uniforms.ambient.value.copyGammaToLinear( material.ambient );
				uniforms.emissive.value.copyGammaToLinear( material.emissive );
				uniforms.specular.value.copyGammaToLinear( material.specular );
	
			} else {
	
				uniforms.ambient.value = material.ambient;
				uniforms.emissive.value = material.emissive;
				uniforms.specular.value = material.specular;
	
			}
	
			if ( material.wrapAround ) {
	
				uniforms.wrapRGB.value.copy( material.wrapRGB );
	
			}
	
		};
	
		function refreshUniformsLambert ( uniforms, material ) {
	
			if ( _this.gammaInput ) {
	
				uniforms.ambient.value.copyGammaToLinear( material.ambient );
				uniforms.emissive.value.copyGammaToLinear( material.emissive );
	
			} else {
	
				uniforms.ambient.value = material.ambient;
				uniforms.emissive.value = material.emissive;
	
			}
	
			if ( material.wrapAround ) {
	
				uniforms.wrapRGB.value.copy( material.wrapRGB );
	
			}
	
		};
	
		function refreshUniformsLights ( uniforms, lights ) {
	
			uniforms.ambientLightColor.value = lights.ambient;
	
			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;
	
			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
	
			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
	
			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;
	
		};
	
		function refreshUniformsShadow ( uniforms, lights ) {
	
			if ( uniforms.shadowMatrix ) {
	
				var j = 0;
	
				for ( var i = 0, il = lights.length; i < il; i ++ ) {
	
					var light = lights[ i ];
	
					if ( ! light.castShadow ) continue;
	
					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {
	
						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;
	
						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;
	
						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;
	
						j ++;
	
					}
	
				}
	
			}
	
		};
	
		// Uniforms (load to GPU)
	
		function loadUniformsMatrices ( uniforms, object ) {
	
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );
	
			if ( uniforms.normalMatrix ) {
	
				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );
	
			}
	
		};
	
		function getTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= _maxTextures ) {
	
				console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		};
	
		function loadUniformsGeneric ( program, uniforms ) {
	
			var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;
	
			for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				location = program.uniforms[ uniforms[ j ][ 1 ] ];
				if ( !location ) continue;
	
				uniform = uniforms[ j ][ 0 ];
	
				type = uniform.type;
				value = uniform.value;
	
				if ( type === "i" ) { // single integer
	
					_gl.uniform1i( location, value );
	
				} else if ( type === "f" ) { // single float
	
					_gl.uniform1f( location, value );
	
				} else if ( type === "v2" ) { // single THREE.Vector2
	
					_gl.uniform2f( location, value.x, value.y );
	
				} else if ( type === "v3" ) { // single THREE.Vector3
	
					_gl.uniform3f( location, value.x, value.y, value.z );
	
				} else if ( type === "v4" ) { // single THREE.Vector4
	
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );
	
				} else if ( type === "c" ) { // single THREE.Color
	
					_gl.uniform3f( location, value.r, value.g, value.b );
	
				} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)
	
					_gl.uniform1iv( location, value );
	
				} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)
	
					_gl.uniform3iv( location, value );
	
				} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)
	
					_gl.uniform1fv( location, value );
	
				} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)
	
					_gl.uniform3fv( location, value );
	
				} else if ( type === "v2v" ) { // array of THREE.Vector2
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 2 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						offset = i * 2;
	
						uniform._array[ offset ] 	 = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
	
					}
	
					_gl.uniform2fv( location, uniform._array );
	
				} else if ( type === "v3v" ) { // array of THREE.Vector3
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 3 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						offset = i * 3;
	
						uniform._array[ offset ] 	 = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
	
					}
	
					_gl.uniform3fv( location, uniform._array );
	
				} else if ( type === "v4v" ) { // array of THREE.Vector4
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 4 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						offset = i * 4;
	
						uniform._array[ offset ] 	 = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;
	
					}
	
					_gl.uniform4fv( location, uniform._array );
	
				} else if ( type === "m4") { // single THREE.Matrix4
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 16 );
	
					}
	
					value.flattenToArray( uniform._array );
					_gl.uniformMatrix4fv( location, false, uniform._array );
	
				} else if ( type === "m4v" ) { // array of THREE.Matrix4
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 16 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );
	
					}
	
					_gl.uniformMatrix4fv( location, false, uniform._array );
	
				} else if ( type === "t" ) { // single THREE.Texture (2d or cube)
	
					texture = value;
					textureUnit = getTextureUnit();
	
					_gl.uniform1i( location, textureUnit );
	
					if ( !texture ) continue;
	
					if ( texture.image instanceof Array && texture.image.length === 6 ) {
	
						setCubeTexture( texture, textureUnit );
	
					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
						setCubeTextureDynamic( texture, textureUnit );
	
					} else {
	
						_this.setTexture( texture, textureUnit );
	
					}
	
				} else if ( type === "tv" ) { // array of THREE.Texture (2d)
	
					if ( uniform._array === undefined ) {
	
						uniform._array = [];
	
					}
	
					for( i = 0, il = uniform.value.length; i < il; i ++ ) {
	
						uniform._array[ i ] = getTextureUnit();
	
					}
	
					_gl.uniform1iv( location, uniform._array );
	
					for( i = 0, il = uniform.value.length; i < il; i ++ ) {
	
						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];
	
						if ( !texture ) continue;
	
						_this.setTexture( texture, textureUnit );
	
					}
	
				} else {
	
					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );
	
				}
	
			}
	
		};
	
		function setupMatrices ( object, camera ) {
	
			object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object._normalMatrix.getNormalMatrix( object._modelViewMatrix );
	
		};
	
		//
	
		function setColorGamma( array, offset, color, intensitySq ) {
	
			array[ offset ]     = color.r * color.r * intensitySq;
			array[ offset + 1 ] = color.g * color.g * intensitySq;
			array[ offset + 2 ] = color.b * color.b * intensitySq;
	
		};
	
		function setColorLinear( array, offset, color, intensity ) {
	
			array[ offset ]     = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;
	
		};
	
		function setupLights ( program, lights ) {
	
			var l, ll, light, n,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,  intensitySq,
			position,
			distance,
	
			zlights = _lights,
	
			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,
	
			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
	
			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
	
			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,
	
			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,
	
			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,
	
			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				if ( light.onlyShadow ) continue;
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					if ( ! light.visible ) continue;
	
					if ( _this.gammaInput ) {
	
						r += color.r * color.r;
						g += color.g * color.g;
						b += color.b * color.b;
	
					} else {
	
						r += color.r;
						g += color.g;
						b += color.b;
	
					}
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					dirCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();
	
					// skip lights with undefined direction
					// these create troubles in OpenGL (making pixel black)
	
					if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;
	
					dirOffset = dirLength * 3;
	
					dirPositions[ dirOffset ]     = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;
	
					if ( _this.gammaInput ) {
	
						setColorGamma( dirColors, dirOffset, color, intensity * intensity );
	
					} else {
	
						setColorLinear( dirColors, dirOffset, color, intensity );
	
					}
	
					dirLength += 1;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					pointCount += 1;
	
					if ( ! light.visible ) continue;
	
					pointOffset = pointLength * 3;
	
					if ( _this.gammaInput ) {
	
						setColorGamma( pointColors, pointOffset, color, intensity * intensity );
	
					} else {
	
						setColorLinear( pointColors, pointOffset, color, intensity );
	
					}
	
					_vector3.setFromMatrixPosition( light.matrixWorld );
	
					pointPositions[ pointOffset ]     = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;
	
					pointDistances[ pointLength ] = distance;
	
					pointLength += 1;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					spotCount += 1;
	
					if ( ! light.visible ) continue;
	
					spotOffset = spotLength * 3;
	
					if ( _this.gammaInput ) {
	
						setColorGamma( spotColors, spotOffset, color, intensity * intensity );
	
					} else {
	
						setColorLinear( spotColors, spotOffset, color, intensity );
	
					}
	
					_vector3.setFromMatrixPosition( light.matrixWorld );
	
					spotPositions[ spotOffset ]     = _vector3.x;
					spotPositions[ spotOffset + 1 ] = _vector3.y;
					spotPositions[ spotOffset + 2 ] = _vector3.z;
	
					spotDistances[ spotLength ] = distance;
	
					_direction.copy( _vector3 );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();
	
					spotDirections[ spotOffset ]     = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;
	
					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
	
					spotLength += 1;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					hemiCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.normalize();
	
					// skip lights with undefined direction
					// these create troubles in OpenGL (making pixel black)
	
					if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;
	
					hemiOffset = hemiLength * 3;
	
					hemiPositions[ hemiOffset ]     = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;
	
					skyColor = light.color;
					groundColor = light.groundColor;
	
					if ( _this.gammaInput ) {
	
						intensitySq = intensity * intensity;
	
						setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
						setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );
	
					} else {
	
						setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
						setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );
	
					}
	
					hemiLength += 1;
	
				}
	
			}
	
			// null eventual remains from removed lights
			// (this is to avoid if in shader)
	
			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;
	
			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;
	
			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;
	
		};
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			if ( cullFace === THREE.CullFaceNone ) {
	
				_gl.disable( _gl.CULL_FACE );
	
			} else {
	
				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				if ( cullFace === THREE.CullFaceBack ) {
	
					_gl.cullFace( _gl.BACK );
	
				} else if ( cullFace === THREE.CullFaceFront ) {
	
					_gl.cullFace( _gl.FRONT );
	
				} else {
	
					_gl.cullFace( _gl.FRONT_AND_BACK );
	
				}
	
				_gl.enable( _gl.CULL_FACE );
	
			}
	
		};
	
		this.setMaterialFaces = function ( material ) {
	
			var doubleSided = material.side === THREE.DoubleSide;
			var flipSided = material.side === THREE.BackSide;
	
			if ( _oldDoubleSided !== doubleSided ) {
	
				if ( doubleSided ) {
	
					_gl.disable( _gl.CULL_FACE );
	
				} else {
	
					_gl.enable( _gl.CULL_FACE );
	
				}
	
				_oldDoubleSided = doubleSided;
	
			}
	
			if ( _oldFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				_oldFlipSided = flipSided;
	
			}
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			if ( _oldDepthTest !== depthTest ) {
	
				if ( depthTest ) {
	
					_gl.enable( _gl.DEPTH_TEST );
	
				} else {
	
					_gl.disable( _gl.DEPTH_TEST );
	
				}
	
				_oldDepthTest = depthTest;
	
			}
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			if ( _oldDepthWrite !== depthWrite ) {
	
				_gl.depthMask( depthWrite );
				_oldDepthWrite = depthWrite;
	
			}
	
		};
	
		function setLineWidth ( width ) {
	
			if ( width !== _oldLineWidth ) {
	
				_gl.lineWidth( width );
	
				_oldLineWidth = width;
	
			}
	
		};
	
		function setPolygonOffset ( polygonoffset, factor, units ) {
	
			if ( _oldPolygonOffset !== polygonoffset ) {
	
				if ( polygonoffset ) {
	
					_gl.enable( _gl.POLYGON_OFFSET_FILL );
	
				} else {
	
					_gl.disable( _gl.POLYGON_OFFSET_FILL );
	
				}
	
				_oldPolygonOffset = polygonoffset;
	
			}
	
			if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {
	
				_gl.polygonOffset( factor, units );
	
				_oldPolygonOffsetFactor = factor;
				_oldPolygonOffsetUnits = units;
	
			}
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {
	
			if ( blending !== _oldBlending ) {
	
				if ( blending === THREE.NoBlending ) {
	
					_gl.disable( _gl.BLEND );
	
				} else if ( blending === THREE.AdditiveBlending ) {
	
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );
	
				} else if ( blending === THREE.CustomBlending ) {
	
					_gl.enable( _gl.BLEND );
	
				} else {
	
					_gl.enable( _gl.BLEND );
					_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
					_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );
	
				}
	
				_oldBlending = blending;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				if ( blendEquation !== _oldBlendEquation ) {
	
					_gl.blendEquation( paramThreeToGL( blendEquation ) );
	
					_oldBlendEquation = blendEquation;
	
				}
	
				if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {
	
					_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );
	
					_oldBlendSrc = blendSrc;
					_oldBlendDst = blendDst;
	
				}
	
			} else {
	
				_oldBlendEquation = null;
				_oldBlendSrc = null;
				_oldBlendDst = null;
	
			}
	
		};
	
		// Defines
	
		function generateDefines ( defines ) {
	
			var value, chunk, chunks = [];
	
			for ( var d in defines ) {
	
				value = defines[ d ];
				if ( value === false ) continue;
	
				chunk = "#define " + d + " " + value;
				chunks.push( chunk );
	
			}
	
			return chunks.join( "\n" );
	
		};
	
		// Shaders
	
		function buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {
	
			var p, pl, d, program, code;
			var chunks = [];
	
			// Generate code
	
			if ( shaderID ) {
	
				chunks.push( shaderID );
	
			} else {
	
				chunks.push( fragmentShader );
				chunks.push( vertexShader );
	
			}
	
			for ( d in defines ) {
	
				chunks.push( d );
				chunks.push( defines[ d ] );
	
			}
	
			for ( p in parameters ) {
	
				chunks.push( p );
				chunks.push( parameters[ p ] );
	
			}
	
			code = chunks.join();
	
			// Check if code has been already compiled
	
			for ( p = 0, pl = _programs.length; p < pl; p ++ ) {
	
				var programInfo = _programs[ p ];
	
				if ( programInfo.code === code ) {
	
					// console.log( "Code already compiled." /*: \n\n" + code*/ );
	
					programInfo.usedTimes ++;
	
					return programInfo.program;
	
				}
	
			}
	
			var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
	
			}
	
			// console.log( "building new program " );
	
			//
	
			var customDefines = generateDefines( defines );
	
			//
	
			program = _gl.createProgram();
	
			var prefix_vertex = [
	
				"precision " + _precision + " float;",
				"precision " + _precision + " int;",
	
				customDefines,
	
				_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
	
				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
	
				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,
	
				"#define MAX_SHADOWS " + parameters.maxShadows,
	
				"#define MAX_BONES " + parameters.maxBones,
	
				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",
	
				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
	
				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",
	
				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
	
				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
	
				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",
	
				"attribute vec3 position;",
				"attribute vec3 normal;",
				"attribute vec2 uv;",
				"attribute vec2 uv2;",
	
				"#ifdef USE_COLOR",
	
					"attribute vec3 color;",
	
				"#endif",
	
				"#ifdef USE_MORPHTARGETS",
	
					"attribute vec3 morphTarget0;",
					"attribute vec3 morphTarget1;",
					"attribute vec3 morphTarget2;",
					"attribute vec3 morphTarget3;",
	
					"#ifdef USE_MORPHNORMALS",
	
						"attribute vec3 morphNormal0;",
						"attribute vec3 morphNormal1;",
						"attribute vec3 morphNormal2;",
						"attribute vec3 morphNormal3;",
	
					"#else",
	
						"attribute vec3 morphTarget4;",
						"attribute vec3 morphTarget5;",
						"attribute vec3 morphTarget6;",
						"attribute vec3 morphTarget7;",
	
					"#endif",
	
				"#endif",
	
				"#ifdef USE_SKINNING",
	
					"attribute vec4 skinIndex;",
					"attribute vec4 skinWeight;",
	
				"#endif",
	
				""
	
			].join("\n");
	
			var prefix_fragment = [
	
				"precision " + _precision + " float;",
				"precision " + _precision + " int;",
	
				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",
	
				customDefines,
	
				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,
	
				"#define MAX_SHADOWS " + parameters.maxShadows,
	
				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",
	
				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
	
				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",
	
				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",
	
				parameters.metal ? "#define METAL" : "",
				parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",
	
				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
	
				"uniform mat4 viewMatrix;",
				"uniform vec3 cameraPosition;",
				""
	
			].join("\n");
	
			var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );
			var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );
	
			_gl.attachShader( program, glVertexShader );
			_gl.attachShader( program, glFragmentShader );
	
			//Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			//And, color, for example is often automatically bound to index 0 so disabling it
			if ( index0AttributeName ) {
				_gl.bindAttribLocation( program, 0, index0AttributeName );
			}
	
			_gl.linkProgram( program );
	
			if ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {
	
				console.error( "Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + ", gl error [" + _gl.getError() + "]" );
				console.error( "Program Info Log: " + _gl.getProgramInfoLog( program ) );
			}
	
			// clean up
	
			_gl.deleteShader( glFragmentShader );
			_gl.deleteShader( glVertexShader );
	
			// console.log( prefix_fragment + fragmentShader );
			// console.log( prefix_vertex + vertexShader );
	
			program.uniforms = {};
			program.attributes = {};
	
			var identifiers, u, a, i;
	
			// cache uniform locations
	
			identifiers = [
	
				'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
				'morphTargetInfluences'
	
			];
	
			if ( parameters.useVertexTexture ) {
	
				identifiers.push( 'boneTexture' );
				identifiers.push( 'boneTextureWidth' );
				identifiers.push( 'boneTextureHeight' );
	
			} else {
	
				identifiers.push( 'boneGlobalMatrices' );
	
			}
	
			for ( u in uniforms ) {
	
				identifiers.push( u );
	
			}
	
			cacheUniformLocations( program, identifiers );
	
			// cache attributes locations
	
			identifiers = [
	
				"position", "normal", "uv", "uv2", "tangent", "color",
				"skinIndex", "skinWeight", "lineDistance"
	
			];
	
			for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {
	
				identifiers.push( "morphTarget" + i );
	
			}
	
			for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {
	
				identifiers.push( "morphNormal" + i );
	
			}
	
			for ( a in attributes ) {
	
				identifiers.push( a );
	
			}
	
			cacheAttributeLocations( program, identifiers );
	
			program.id = _programs_counter ++;
	
			_programs.push( { program: program, code: code, usedTimes: 1 } );
	
			_this.info.memory.programs = _programs.length;
	
			return program;
	
		};
	
		// Shader parameters cache
	
		function cacheUniformLocations ( program, identifiers ) {
	
			var i, l, id;
	
			for( i = 0, l = identifiers.length; i < l; i ++ ) {
	
				id = identifiers[ i ];
				program.uniforms[ id ] = _gl.getUniformLocation( program, id );
	
			}
	
		};
	
		function cacheAttributeLocations ( program, identifiers ) {
	
			var i, l, id;
	
			for( i = 0, l = identifiers.length; i < l; i ++ ) {
	
				id = identifiers[ i ];
				program.attributes[ id ] = _gl.getAttribLocation( program, id );
	
			}
	
		};
	
		function addLineNumbers ( string ) {
	
			var chunks = string.split( "\n" );
	
			for ( var i = 0, il = chunks.length; i < il; i ++ ) {
	
				// Chrome reports shader errors on lines
				// starting counting from 1
	
				chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];
	
			}
	
			return chunks.join( "\n" );
	
		};
	
		function getShader ( type, string ) {
	
			var shader;
	
			if ( type === "fragment" ) {
	
				shader = _gl.createShader( _gl.FRAGMENT_SHADER );
	
			} else if ( type === "vertex" ) {
	
				shader = _gl.createShader( _gl.VERTEX_SHADER );
	
			}
	
			_gl.shaderSource( shader, string );
			_gl.compileShader( shader );
	
			if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {
	
				console.error( _gl.getShaderInfoLog( shader ) );
				console.error( addLineNumbers( string ) );
				return null;
	
			}
	
			return shader;
	
		};
	
		// Textures
	
	
		function isPowerOfTwo ( value ) {
	
			return ( value & ( value - 1 ) ) === 0;
	
		};
	
		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {
	
			if ( isImagePowerOfTwo ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
			}
	
			if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {
	
				if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {
	
					_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
					texture.__oldAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		};
	
		this.setTexture = function ( texture, slot ) {
	
			if ( texture.needsUpdate ) {
	
				if ( ! texture.__webglInit ) {
	
					texture.__webglInit = true;
	
					texture.addEventListener( 'dispose', onTextureDispose );
	
					texture.__webglTexture = _gl.createTexture();
	
					_this.info.memory.textures ++;
	
				}
	
				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
	
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
				var image = texture.image,
				isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );
	
				setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );
	
				var mipmap, mipmaps = texture.mipmaps;
	
				if ( texture instanceof THREE.DataTexture ) {
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
					}
	
				} else if ( texture instanceof THREE.CompressedTexture ) {
	
					for( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						if ( texture.format!==THREE.RGBAFormat ) {
							_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
						} else {
							_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
						}
	
					}
	
				} else { // regular Texture (image, video, canvas)
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );
	
					}
	
				}
	
				if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				texture.needsUpdate = false;
	
				if ( texture.onUpdate ) texture.onUpdate();
	
			} else {
	
				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
	
			}
	
		};
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width <= maxSize && image.height <= maxSize ) {
	
				return image;
	
			}
	
			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.
	
			var maxDimension = Math.max( image.width, image.height );
			var newWidth = Math.floor( image.width * maxSize / maxDimension );
			var newHeight = Math.floor( image.height * maxSize / maxDimension );
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = newWidth;
			canvas.height = newHeight;
	
			var ctx = canvas.getContext( "2d" );
			ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );
	
			return canvas;
	
		}
	
		function setCubeTexture ( texture, slot ) {
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.needsUpdate ) {
	
					if ( ! texture.image.__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						texture.image.__webglTextureCube = _gl.createTexture();
	
						_this.info.memory.textures ++;
	
					}
	
					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( _this.autoScaleCubemaps && ! isCompressed ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if( !isCompressed ) {
	
							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
						} else {
							
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
								if ( texture.format!==THREE.RGBAFormat ) {
	
									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
								} else {
									_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
								}
	
							}
						}
					}
	
					if ( texture.generateMipmaps && isImagePowerOfTwo ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					texture.needsUpdate = false;
	
					if ( texture.onUpdate ) texture.onUpdate();
	
				} else {
	
					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );
	
				}
	
			}
	
		};
	
		function setCubeTextureDynamic ( texture, slot ) {
	
			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );
	
		};
	
		// Render targets
	
		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );
	
		};
	
		function setupRenderBuffer ( renderbuffer, renderTarget  ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			/* For some reason this is not working. Defaulting to RGBA4.
			} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
		};
	
		this.setRenderTarget = function ( renderTarget ) {
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( renderTarget && ! renderTarget.__webglFramebuffer ) {
	
				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				renderTarget.__webglTexture = _gl.createTexture();
	
				_this.info.memory.textures ++;
	
				// Setup texture, create render and frame buffers
	
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );
	
				if ( isCube ) {
	
					renderTarget.__webglFramebuffer = [];
					renderTarget.__webglRenderbuffer = [];
	
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
	
						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
						setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );
	
					}
	
					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
				} else {
	
					renderTarget.__webglFramebuffer = _gl.createFramebuffer();
	
					if ( renderTarget.shareDepthFrom ) {
	
						renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
	
					} else {
	
						renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
	
					}
	
					_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );
	
					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
					setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );
	
					if ( renderTarget.shareDepthFrom ) {
	
						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );
	
						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );
	
						}
	
					} else {
	
						setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );
	
					}
	
					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				}
	
				// Release everything
	
				if ( isCube ) {
	
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					_gl.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			var framebuffer, width, height, vx, vy;
	
			if ( renderTarget ) {
	
				if ( isCube ) {
	
					framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTarget.__webglFramebuffer;
	
				}
	
				width = renderTarget.width;
				height = renderTarget.height;
	
				vx = 0;
				vy = 0;
	
			} else {
	
				framebuffer = null;
	
				width = _viewportWidth;
				height = _viewportHeight;
	
				vx = _viewportX;
				vy = _viewportY;
	
			}
	
			if ( framebuffer !== _currentFramebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );
	
				_currentFramebuffer = framebuffer;
	
			}
	
			_currentWidth = width;
			_currentHeight = height;
	
		};
	
		function updateRenderTargetMipmap ( renderTarget ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
			} else {
	
				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				_gl.bindTexture( _gl.TEXTURE_2D, null );
	
			}
	
		};
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		};
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			if ( _glExtensionCompressedTextureS3TC !== undefined ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			return 0;
	
		};
	
		// Allocations
	
		function allocateBones ( object ) {
	
			if ( _supportsBoneTextures && object && object.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader
				//   to be used with multiple objects )
				//
				// 	- leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.bones.length, maxBones );
	
					if ( maxBones < object.bones.length ) {
	
						console.warn( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		};
	
		function allocateLights( lights ) {
	
			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;
	
			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {
	
				var light = lights[ l ];
	
				if ( light.onlyShadow ) continue;
	
				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;
	
			}
	
			return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };
	
		};
	
		function allocateShadows( lights ) {
	
			var maxShadows = 0;
	
			for ( var l = 0, ll = lights.length; l < ll; l++ ) {
	
				var light = lights[ l ];
	
				if ( ! light.castShadow ) continue;
	
				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;
	
			}
	
			return maxShadows;
	
		};
	
		// Initialization
	
		function initGL() {
	
			try {
	
				var attributes = {
					alpha: _alpha,
					premultipliedAlpha: _premultipliedAlpha,
					antialias: _antialias,
					stencil: _stencil,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};
	
				_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
				if ( _gl === null ) {
	
					throw 'Error creating WebGL context.';
	
				}
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
			_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
			_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );
			_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );
	
			_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
	
			_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
	
			if ( ! _glExtensionTextureFloat ) {
	
				console.log( 'THREE.WebGLRenderer: Float textures not supported.' );
	
			}
	
			if ( ! _glExtensionStandardDerivatives ) {
	
				console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );
	
			}
	
			if ( ! _glExtensionTextureFilterAnisotropic ) {
	
				console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );
	
			}
	
			if ( ! _glExtensionCompressedTextureS3TC ) {
	
				console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );
	
			}
	
			if ( _gl.getShaderPrecisionFormat === undefined ) {
	
				_gl.getShaderPrecisionFormat = function() {
	
					return {
						"rangeMin"  : 1,
						"rangeMax"  : 1,
						"precision" : 1
					};
	
				}
			}
	
		};
	
		function setDefaultGLState () {
	
			_gl.clearColor( 0, 0, 0, 1 );
			_gl.clearDepth( 1 );
			_gl.clearStencil( 0 );
	
			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthFunc( _gl.LEQUAL );
	
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( _gl.BACK );
			_gl.enable( _gl.CULL_FACE );
	
			_gl.enable( _gl.BLEND );
			_gl.blendEquation( _gl.FUNC_ADD );
			_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
			
			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		// default plugins (order is important)
	
		this.shadowMapPlugin = new THREE.ShadowMapPlugin();
		this.addPrePlugin( this.shadowMapPlugin );
	
		this.addPostPlugin( new THREE.SpritePlugin() );
		this.addPostPlugin( new THREE.LensFlarePlugin() );
	
	};
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		this.width = width;
		this.height = height;
	
		options = options || {};
	
		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	
		this.generateMipmaps = true;
	
		this.shareDepthFrom = null;
	
	};
	
	THREE.WebGLRenderTarget.prototype = {
	
		constructor: THREE.WebGLRenderTarget,
	
		clone: function () {
	
			var tmp = new THREE.WebGLRenderTarget( this.width, this.height );
	
			tmp.wrapS = this.wrapS;
			tmp.wrapT = this.wrapT;
	
			tmp.magFilter = this.magFilter;
			tmp.minFilter = this.minFilter;
	
			tmp.anisotropy = this.anisotropy;
	
			tmp.offset.copy( this.offset );
			tmp.repeat.copy( this.repeat );
	
			tmp.format = this.format;
			tmp.type = this.type;
	
			tmp.depthBuffer = this.depthBuffer;
			tmp.stencilBuffer = this.stencilBuffer;
	
			tmp.generateMipmaps = this.generateMipmaps;
	
			tmp.shareDepthFrom = this.shareDepthFrom;
	
			return tmp;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableVertex = function () {
	
		this.position = new THREE.Vector3();
		this.positionWorld = new THREE.Vector3();
		this.positionScreen = new THREE.Vector4();
	
		this.visible = true;
	
	};
	
	THREE.RenderableVertex.prototype.copy = function ( vertex ) {
	
		this.positionWorld.copy( vertex.positionWorld );
		this.positionScreen.copy( vertex.positionScreen );
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableFace3 = function () {
	
		this.id = 0;
	
		this.v1 = new THREE.RenderableVertex();
		this.v2 = new THREE.RenderableVertex();
		this.v3 = new THREE.RenderableVertex();
	
		this.centroidModel = new THREE.Vector3();
	
		this.normalModel = new THREE.Vector3();
		this.normalModelView = new THREE.Vector3();
	
		this.vertexNormalsLength = 0;
		this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
		this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	
		this.color = null;
		this.material = null;
		this.uvs = [[]];
	
		this.z = 0;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableObject = function () {
	
		this.id = 0;
	
		this.object = null;
		this.z = 0;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableSprite = function () {
	
		this.id = 0;
	
		this.object = null;
	
		this.x = 0;
		this.y = 0;
		this.z = 0;
	
		this.rotation = 0;
		this.scale = new THREE.Vector2();
	
		this.material = null;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableLine = function () {
	
		this.id = 0;
	
		this.v1 = new THREE.RenderableVertex();
		this.v2 = new THREE.RenderableVertex();
	
		this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
		this.material = null;
	
		this.z = 0;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.GeometryUtils = {
	
		// Merge two geometries or geometry and geometry from object (using object's transform)
	
		merge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {
	
			var matrix, normalMatrix,
			vertexOffset = geometry1.vertices.length,
			uvPosition = geometry1.faceVertexUvs[ 0 ].length,
			geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
			vertices1 = geometry1.vertices,
			vertices2 = geometry2.vertices,
			faces1 = geometry1.faces,
			faces2 = geometry2.faces,
			uvs1 = geometry1.faceVertexUvs[ 0 ],
			uvs2 = geometry2.faceVertexUvs[ 0 ];
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( object2 instanceof THREE.Mesh ) {
	
				object2.matrixAutoUpdate && object2.updateMatrix();
	
				matrix = object2.matrix;
	
				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faceCopy.centroid.copy( face.centroid );
	
				if ( matrix ) {
	
					faceCopy.centroid.applyMatrix4( matrix );
	
				}
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		// Get random point in triangle (via barycentric coordinates)
		// 	(uniform distribution)
		// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle
	
		randomPointInTriangle: function () {
	
			var vector = new THREE.Vector3();
	
			return function ( vectorA, vectorB, vectorC ) {
	
				var point = new THREE.Vector3();
	
				var a = THREE.Math.random16();
				var b = THREE.Math.random16();
	
				if ( ( a + b ) > 1 ) {
	
					a = 1 - a;
					b = 1 - b;
	
				}
	
				var c = 1 - a - b;
	
				point.copy( vectorA );
				point.multiplyScalar( a );
	
				vector.copy( vectorB );
				vector.multiplyScalar( b );
	
				point.add( vector );
	
				vector.copy( vectorC );
				vector.multiplyScalar( c );
	
				point.add( vector );
	
				return point;
	
			};
	
		}(),
	
		// Get random point in face (triangle / quad)
		// (uniform distribution)
	
		randomPointInFace: function ( face, geometry, useCachedAreas ) {
	
			var vA, vB, vC, vD;
	
			vA = geometry.vertices[ face.a ];
			vB = geometry.vertices[ face.b ];
			vC = geometry.vertices[ face.c ];
	
			return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );
	
		},
	
		// Get uniformly distributed random points in mesh
		// 	- create array with cumulative sums of face areas
		//  - pick random number from 0 to total area
		//  - find corresponding place in area array by binary search
		//	- get random point in face
	
		randomPointsInGeometry: function ( geometry, n ) {
	
			var face, i,
				faces = geometry.faces,
				vertices = geometry.vertices,
				il = faces.length,
				totalArea = 0,
				cumulativeAreas = [],
				vA, vB, vC, vD;
	
			// precompute face areas
	
			for ( i = 0; i < il; i ++ ) {
	
				face = faces[ i ];
	
				vA = vertices[ face.a ];
				vB = vertices[ face.b ];
				vC = vertices[ face.c ];
	
				face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );
	
				totalArea += face._area;
	
				cumulativeAreas[ i ] = totalArea;
	
			}
	
			// binary search cumulative areas array
	
			function binarySearchIndices( value ) {
	
				function binarySearch( start, end ) {
	
					// return closest larger index
					// if exact number is not found
	
					if ( end < start )
						return start;
	
					var mid = start + Math.floor( ( end - start ) / 2 );
	
					if ( cumulativeAreas[ mid ] > value ) {
	
						return binarySearch( start, mid - 1 );
	
					} else if ( cumulativeAreas[ mid ] < value ) {
	
						return binarySearch( mid + 1, end );
	
					} else {
	
						return mid;
	
					}
	
				}
	
				var result = binarySearch( 0, cumulativeAreas.length - 1 )
				return result;
	
			}
	
			// pick random face weighted by face area
	
			var r, index,
				result = [];
	
			var stats = {};
	
			for ( i = 0; i < n; i ++ ) {
	
				r = THREE.Math.random16() * totalArea;
	
				index = binarySearchIndices( r );
	
				result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );
	
				if ( ! stats[ index ] ) {
	
					stats[ index ] = 1;
	
				} else {
	
					stats[ index ] += 1;
	
				}
	
			}
	
			return result;
	
		},
	
		// Get triangle area (half of parallelogram)
		//	http://mathworld.wolfram.com/TriangleArea.html
	
		triangleArea: function () {
	
			var vector1 = new THREE.Vector3();
			var vector2 = new THREE.Vector3();
	
			return function ( vectorA, vectorB, vectorC ) {
	
				vector1.subVectors( vectorB, vectorA );
				vector2.subVectors( vectorC, vectorA );
				vector1.cross( vector2 );
	
				return 0.5 * vector1.length();
	
			};
	
		}(),
	
		// Center geometry so that 0,0,0 is in center of bounding box
	
		center: function ( geometry ) {
	
			geometry.computeBoundingBox();
	
			var bb = geometry.boundingBox;
	
			var offset = new THREE.Vector3();
	
			offset.addVectors( bb.min, bb.max );
			offset.multiplyScalar( -0.5 );
	
			geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
			geometry.computeBoundingBox();
	
			return offset;
	
		},
	
		triangulateQuads: function ( geometry ) {
	
			var i, il, j, jl;
	
			var faces = [];
			var faceVertexUvs = [];
	
			for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {
	
				faceVertexUvs[ i ] = [];
	
			}
	
			for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {
	
				var face = geometry.faces[ i ];
	
				faces.push( face );
	
				for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {
	
					faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );
	
				}
	
			}
	
			geometry.faces = faces;
			geometry.faceVertexUvs = faceVertexUvs;
	
			geometry.computeCentroids();
			geometry.computeFaceNormals();
			geometry.computeVertexNormals();
	
			if ( geometry.hasTangents ) geometry.computeTangents();
	
		}
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageUtils = {
	
		crossOrigin: undefined,
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;
	
			var texture = new THREE.Texture( undefined, mapping );
	
			var image = loader.load( url, function () {
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture );
	
			} );
	
			texture.image = image;
			texture.sourceFile = url;
	
			return texture;
	
		},
	
		loadCompressedTexture: function ( url, mapping, onLoad, onError ) {
	
			var texture = new THREE.CompressedTexture();
			texture.mapping = mapping;
	
			var request = new XMLHttpRequest();
	
			request.onload = function () {
	
				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
				texture.format = dds.format;
	
				texture.mipmaps = dds.mipmaps;
				texture.image.width = dds.width;
				texture.image.height = dds.height;
	
				// gl.generateMipmap fails for compressed textures
				// mipmaps must be embedded in the DDS file
				// or texture filters must not use mipmapping
	
				texture.generateMipmaps = false;
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture );
	
			}
	
			request.onerror = onError;
	
			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );
	
			return texture;
	
		},
	
		loadTextureCube: function ( array, mapping, onLoad, onError ) {
	
			var images = [];
			images.loadCount = 0;
	
			var texture = new THREE.Texture();
			texture.image = images;
			if ( mapping !== undefined ) texture.mapping = mapping;
	
			// no flipping needed for cube textures
	
			texture.flipY = false;
	
			for ( var i = 0, il = array.length; i < il; ++ i ) {
	
				var cubeImage = new Image();
				images[ i ] = cubeImage;
	
				cubeImage.onload = function () {
	
					images.loadCount += 1;
	
					if ( images.loadCount === 6 ) {
	
						texture.needsUpdate = true;
						if ( onLoad ) onLoad( texture );
	
					}
	
				};
	
				cubeImage.onerror = onError;
	
				cubeImage.crossOrigin = this.crossOrigin;
				cubeImage.src = array[ i ];
	
			}
	
			return texture;
	
		},
	
		loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {
	
			var images = [];
			images.loadCount = 0;
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
			if ( mapping !== undefined ) texture.mapping = mapping;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			texture.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			texture.generateMipmaps = false;
	
			var generateCubeFaceCallback = function ( rq, img ) {
	
				return function () {
	
					var buffer = rq.response;
					var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
					img.format = dds.format;
	
					img.mipmaps = dds.mipmaps;
					img.width = dds.width;
					img.height = dds.height;
	
					images.loadCount += 1;
	
					if ( images.loadCount === 6 ) {
	
						texture.format = dds.format;
						texture.needsUpdate = true;
						if ( onLoad ) onLoad( texture );
	
					}
	
				}
	
			}
	
			// compressed cubemap textures as 6 separate DDS files
	
			if ( array instanceof Array ) {
	
				for ( var i = 0, il = array.length; i < il; ++ i ) {
	
					var cubeImage = {};
					images[ i ] = cubeImage;
	
					var request = new XMLHttpRequest();
	
					request.onload = generateCubeFaceCallback( request, cubeImage );
					request.onerror = onError;
	
					var url = array[ i ];
	
					request.open( 'GET', url, true );
					request.responseType = "arraybuffer";
					request.send( null );
	
				}
	
			// compressed cubemap texture stored in a single DDS file
	
			} else {
	
				var url = array;
				var request = new XMLHttpRequest();
	
				request.onload = function( ) {
	
					var buffer = request.response;
					var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
					if ( dds.isCubemap ) {
	
						var faces = dds.mipmaps.length / dds.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < dds.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
								images[ f ].format = dds.format;
								images[ f ].width = dds.width;
								images[ f ].height = dds.height;
	
							}
	
						}
	
						texture.format = dds.format;
						texture.needsUpdate = true;
						if ( onLoad ) onLoad( texture );
	
					}
	
				}
	
				request.onerror = onError;
	
				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );
	
			}
	
			return texture;
	
		},
	
		loadDDSTexture: function ( url, mapping, onLoad, onError ) {
	
			var images = [];
			images.loadCount = 0;
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
			if ( mapping !== undefined ) texture.mapping = mapping;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			texture.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			texture.generateMipmaps = false;
	
			{
				var request = new XMLHttpRequest();
	
				request.onload = function( ) {
	
					var buffer = request.response;
					var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
					if ( dds.isCubemap ) {
	
						var faces = dds.mipmaps.length / dds.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < dds.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
								images[ f ].format = dds.format;
								images[ f ].width = dds.width;
								images[ f ].height = dds.height;
	
							}
	
						}
	
	
					} else {
						texture.image.width = dds.width;
						texture.image.height = dds.height;
						texture.mipmaps = dds.mipmaps;
					}
	
					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );
	
				}
	
				request.onerror = onError;
	
				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );
	
			}
	
			return texture;
	
		},
	
		parseDDS: function ( buffer, loadMipmaps ) {
	
			var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };
	
			// Adapted from @toji's DDS utils
			//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
	
			// All values and structures referenced from:
			// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
	
			var DDS_MAGIC = 0x20534444;
	
			var DDSD_CAPS = 0x1,
				DDSD_HEIGHT = 0x2,
				DDSD_WIDTH = 0x4,
				DDSD_PITCH = 0x8,
				DDSD_PIXELFORMAT = 0x1000,
				DDSD_MIPMAPCOUNT = 0x20000,
				DDSD_LINEARSIZE = 0x80000,
				DDSD_DEPTH = 0x800000;
	
			var DDSCAPS_COMPLEX = 0x8,
				DDSCAPS_MIPMAP = 0x400000,
				DDSCAPS_TEXTURE = 0x1000;
	
			var DDSCAPS2_CUBEMAP = 0x200,
				DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
				DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
				DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
				DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
				DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
				DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
				DDSCAPS2_VOLUME = 0x200000;
	
			var DDPF_ALPHAPIXELS = 0x1,
				DDPF_ALPHA = 0x2,
				DDPF_FOURCC = 0x4,
				DDPF_RGB = 0x40,
				DDPF_YUV = 0x200,
				DDPF_LUMINANCE = 0x20000;
	
			function fourCCToInt32( value ) {
	
				return value.charCodeAt(0) +
					(value.charCodeAt(1) << 8) +
					(value.charCodeAt(2) << 16) +
					(value.charCodeAt(3) << 24);
	
			}
	
			function int32ToFourCC( value ) {
	
				return String.fromCharCode(
					value & 0xff,
					(value >> 8) & 0xff,
					(value >> 16) & 0xff,
					(value >> 24) & 0xff
				);
			}
	
			function loadARGBMip( buffer, dataOffset, width, height ) {
				var dataLength = width*height*4;
				var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
				var byteArray = new Uint8Array( dataLength );
				var dst = 0;
				var src = 0;
				for ( var y = 0; y < height; y++ ) {
					for ( var x = 0; x < width; x++ ) {
						var b = srcBuffer[src]; src++;
						var g = srcBuffer[src]; src++;
						var r = srcBuffer[src]; src++;
						var a = srcBuffer[src]; src++;
						byteArray[dst] = r; dst++;	//r
						byteArray[dst] = g; dst++;	//g
						byteArray[dst] = b; dst++;	//b
						byteArray[dst] = a; dst++;	//a
					}
				}
				return byteArray;
			}
	
			var FOURCC_DXT1 = fourCCToInt32("DXT1");
			var FOURCC_DXT3 = fourCCToInt32("DXT3");
			var FOURCC_DXT5 = fourCCToInt32("DXT5");
	
			var headerLengthInt = 31; // The header length in 32 bit ints
	
			// Offsets into the header array
	
			var off_magic = 0;
	
			var off_size = 1;
			var off_flags = 2;
			var off_height = 3;
			var off_width = 4;
	
			var off_mipmapCount = 7;
	
			var off_pfFlags = 20;
			var off_pfFourCC = 21;
			var off_RGBBitCount = 22;
			var off_RBitMask = 23;
			var off_GBitMask = 24;
			var off_BBitMask = 25;
			var off_ABitMask = 26;
	
			var off_caps = 27;
			var off_caps2 = 28;
			var off_caps3 = 29;
			var off_caps4 = 30;
	
			// Parse header
	
			var header = new Int32Array( buffer, 0, headerLengthInt );
	
			if ( header[ off_magic ] !== DDS_MAGIC ) {
	
				console.error( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
				return dds;
	
			}
	
			if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {
	
				console.error( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
				return dds;
	
			}
	
			var blockBytes;
	
			var fourCC = header[ off_pfFourCC ];
	
			var isRGBAUncompressed = false;
	
			switch ( fourCC ) {
	
				case FOURCC_DXT1:
	
					blockBytes = 8;
					dds.format = THREE.RGB_S3TC_DXT1_Format;
					break;
	
				case FOURCC_DXT3:
	
					blockBytes = 16;
					dds.format = THREE.RGBA_S3TC_DXT3_Format;
					break;
	
				case FOURCC_DXT5:
	
					blockBytes = 16;
					dds.format = THREE.RGBA_S3TC_DXT5_Format;
					break;
	
				default:
	
					if( header[off_RGBBitCount] ==32 
						&& header[off_RBitMask]&0xff0000
						&& header[off_GBitMask]&0xff00 
						&& header[off_BBitMask]&0xff
						&& header[off_ABitMask]&0xff000000  ) {
						isRGBAUncompressed = true;
						blockBytes = 64;
						dds.format = THREE.RGBAFormat;
					} else {
						console.error( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
						return dds;
					}
			}
	
			dds.mipmapCount = 1;
	
			if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {
	
				dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );
	
			}
	
			//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.
	
			dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;
	
			dds.width = header[ off_width ];
			dds.height = header[ off_height ];
	
			var dataOffset = header[ off_size ] + 4;
	
			// Extract mipmaps buffers
	
			var width = dds.width;
			var height = dds.height;
	
			var faces = dds.isCubemap ? 6 : 1;
	
			for ( var face = 0; face < faces; face ++ ) {
	
				for ( var i = 0; i < dds.mipmapCount; i ++ ) {
	
					if( isRGBAUncompressed ) {
						var byteArray = loadARGBMip( buffer, dataOffset, width, height );
						var dataLength = byteArray.length;
					} else {
						var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
						var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
					}
					
					var mipmap = { "data": byteArray, "width": width, "height": height };
					dds.mipmaps.push( mipmap );
	
					dataOffset += dataLength;
	
					width = Math.max( width * 0.5, 1 );
					height = Math.max( height * 0.5, 1 );
	
				}
	
				width = dds.width;
				height = dds.height;
	
			}
	
			return dds;
	
		},
	
		getNormalMap: function ( image, depth ) {
	
			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/
	
			var cross = function ( a, b ) {
	
				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];
	
			}
	
			var subtract = function ( a, b ) {
	
				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];
	
			}
	
			var normalize = function ( a ) {
	
				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];
	
			}
	
			depth = depth | 1;
	
			var width = image.width;
			var height = image.height;
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;
	
			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );
	
			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;
	
			for ( var x = 0; x < width; x ++ ) {
	
				for ( var y = 0; y < height; y ++ ) {
	
					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;
	
					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );
	
					var normals = [];
					var num_points = points.length;
	
					for ( var i = 0; i < num_points; i ++ ) {
	
						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );
	
					}
	
					var normal = [ 0, 0, 0 ];
	
					for ( var i = 0; i < normals.length; i ++ ) {
	
						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];
	
					}
	
					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;
	
					var idx = ( y * width + x ) * 4;
	
					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;
	
				}
	
			}
	
			context.putImageData( imageData, 0, 0 );
	
			return canvas;
	
		},
	
		generateDataTexture: function ( width, height, color ) {
	
			var size = width * height;
			var data = new Uint8Array( 3 * size );
	
			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );
	
			for ( var i = 0; i < size; i ++ ) {
	
				data[ i * 3 ] 	  = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;
	
			}
	
			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;
	
			return texture;
	
		}
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Object3D();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach : function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 * 	typeface.js and canvastext
	 * 		For converting fonts and rendering with javascript
	 *		http://typeface.neocracy.org
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */
	
	THREE.FontUtils = {
	
		faces : {},
	
		// Just for now. face[weight][style]
	
		face : "helvetiker",
		weight: "normal",
		style : "normal",
		size : 150,
		divisions : 10,
	
		getFace : function() {
	
			return this.faces[ this.face ][ this.weight ][ this.style ];
	
		},
	
		loadFace : function( data ) {
	
			var family = data.familyName.toLowerCase();
	
			var ThreeFont = this;
	
			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};
	
			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;
	
			var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;
	
			return data;
	
		},
	
		drawText : function( text ) {
	
			var characterPts = [], allPts = [];
	
			// RenderText
	
			var i, p,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;
	
			var fontPaths = [];
	
			for ( i = 0; i < length; i ++ ) {
	
				var path = new THREE.Path();
	
				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;
	
				fontPaths.push( ret.path );
	
			}
	
			// get the width
	
			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }
	
			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;
	
			//extract.paths = fontPaths;
			//extract.offset = width;
	
			return { paths : fontPaths, offset : width };
	
		},
	
	
	
	
		extractGlyphPoints : function( c, face, scale, offset, path ) {
	
			var pts = [];
	
			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];
	
			if ( !glyph ) return;
	
			if ( glyph.o ) {
	
				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;
	
				scaleX = scale;
				scaleY = scale;
	
				for ( i = 0; i < length; ) {
	
					action = outline[ i ++ ];
	
					//console.log( action );
	
					switch( action ) {
	
					case 'm':
	
						// Move To
	
						x = outline[ i++ ] * scaleX + offset;
						y = outline[ i++ ] * scaleY;
	
						path.moveTo( x, y );
						break;
	
					case 'l':
	
						// Line To
	
						x = outline[ i++ ] * scaleX + offset;
						y = outline[ i++ ] * scaleY;
						path.lineTo(x,y);
						break;
	
					case 'q':
	
						// QuadraticCurveTo
	
						cpx  = outline[ i++ ] * scaleX + offset;
						cpy  = outline[ i++ ] * scaleY;
						cpx1 = outline[ i++ ] * scaleX + offset;
						cpy1 = outline[ i++ ] * scaleY;
	
						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
	
						laste = pts[ pts.length - 1 ];
	
						if ( laste ) {
	
							cpx0 = laste.x;
							cpy0 = laste.y;
	
							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {
	
								var t = i2 / divisions;
								var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
						  }
	
					  }
	
					  break;
	
					case 'b':
	
						// Cubic Bezier Curve
	
						cpx  = outline[ i++ ] *  scaleX + offset;
						cpy  = outline[ i++ ] *  scaleY;
						cpx1 = outline[ i++ ] *  scaleX + offset;
						cpy1 = outline[ i++ ] * -scaleY;
						cpx2 = outline[ i++ ] *  scaleX + offset;
						cpy2 = outline[ i++ ] * -scaleY;
	
						path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );
	
						laste = pts[ pts.length - 1 ];
	
						if ( laste ) {
	
							cpx0 = laste.x;
							cpy0 = laste.y;
	
							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {
	
								var t = i2 / divisions;
								var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
	
							}
	
						}
	
						break;
	
					}
	
				}
			}
	
	
	
			return { offset: glyph.ha*scale, path:path};
		}
	
	};
	
	
	THREE.FontUtils.generateShapes = function( text, parameters ) {
	
		// Parameters 
	
		parameters = parameters || {};
	
		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;
	
		var font = parameters.font !== undefined ? parameters.font : "helvetiker";
		var weight = parameters.weight !== undefined ? parameters.weight : "normal";
		var style = parameters.style !== undefined ? parameters.style : "normal";
	
		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;
	
		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;
	
		// Get a Font data json object
	
		var data = THREE.FontUtils.drawText( text );
	
		var paths = data.paths;
		var shapes = [];
	
		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
		}
	
		return shapes;
	
	};
	
	
	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */
	
	
	( function( namespace ) {
	
		var EPSILON = 0.0000000001;
	
		// takes in an contour array and returns
	
		var process = function( contour, indices ) {
	
			var n = contour.length;
	
			if ( n < 3 ) return null;
	
			var result = [],
				verts = [],
				vertIndices = [];
	
			/* we want a counter-clockwise polygon in verts */
	
			var u, v, w;
	
			if ( area( contour ) > 0.0 ) {
	
				for ( v = 0; v < n; v++ ) verts[ v ] = v;
	
			} else {
	
				for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;
	
			}
	
			var nv = n;
	
			/*  remove nv - 2 vertices, creating 1 triangle every time */
	
			var count = 2 * nv;   /* error detection */
	
			for( v = nv - 1; nv > 2; ) {
	
				/* if we loop, it is probably a non-simple polygon */
	
				if ( ( count-- ) <= 0 ) {
	
					//** Triangulate: ERROR - probable bad polygon!
	
					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.log( "Warning, unable to triangulate polygon!" );
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
				/* three consecutive vertices in current polygon, <u,v,w> */
	
				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
				if ( snip( contour, u, v, w, nv, verts ) ) {
	
					var a, b, c, s, t;
	
					/* true names of the vertices */
	
					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];
	
					/* output Triangle */
	
					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );
	
	
					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
					/* remove v from the remaining polygon */
	
					for( s = v, t = v + 1; t < nv; s++, t++ ) {
	
						verts[ s ] = verts[ t ];
	
					}
	
					nv--;
	
					/* reset error detection counter */
	
					count = 2 * nv;
	
				}
	
			}
	
			if ( indices ) return vertIndices;
			return result;
	
		};
	
		// calculate area of the contour polygon
	
		var area = function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for( var p = n - 1, q = 0; q < n; p = q++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		};
	
		var snip = function ( contour, u, v, w, n, verts ) {
	
			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;
	
			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;
	
			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;
	
			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;
	
			if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;
	
			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;
	
			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;
	
			for ( p = 0; p < n; p++ ) {
	
				if( (p === u) || (p === v) || (p === w) ) continue;
	
				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y
	
				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;
	
				// see if p is inside triangle abc
	
				aCROSSbp = aX*bpy - aY*bpx;
				cCROSSap = cX*apy - cY*apx;
				bCROSScp = bX*cpy - bY*cpx;
	
				if ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;
	
			}
	
			return true;
	
		};
	
	
		namespace.Triangulate = process;
		namespace.Triangulate.area = area;
	
		return namespace;
	
	})(THREE.FontUtils);
	
	// To use the typeface.js face files, hook up the API
	self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	THREE.typeface_js = self._typeface_js;
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]
	
	THREE.Curve.prototype.getPoint = function ( t ) {
	
		console.log( "Warning, getPoint() not implemented!" );
		return null;
	
	};
	
	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]
	
	THREE.Curve.prototype.getPointAt = function ( u ) {
	
		var t = this.getUtoTmapping( u );
		return this.getPoint( t );
	
	};
	
	// Get sequence of points using getPoint( t )
	
	THREE.Curve.prototype.getPoints = function ( divisions ) {
	
		if ( !divisions ) divisions = 5;
	
		var d, pts = [];
	
		for ( d = 0; d <= divisions; d ++ ) {
	
			pts.push( this.getPoint( d / divisions ) );
	
		}
	
		return pts;
	
	};
	
	// Get sequence of points using getPointAt( u )
	
	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {
	
		if ( !divisions ) divisions = 5;
	
		var d, pts = [];
	
		for ( d = 0; d <= divisions; d ++ ) {
	
			pts.push( this.getPointAt( d / divisions ) );
	
		}
	
		return pts;
	
	};
	
	// Get total curve arc length
	
	THREE.Curve.prototype.getLength = function () {
	
		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];
	
	};
	
	// Get list of cumulative segment lengths
	
	THREE.Curve.prototype.getLengths = function ( divisions ) {
	
		if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;
	
		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length == divisions + 1 )
			&& !this.needsUpdate) {
	
			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;
	
		}
	
		this.needsUpdate = false;
	
		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;
	
		cache.push( 0 );
	
		for ( p = 1; p <= divisions; p ++ ) {
	
			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;
	
		}
	
		this.cacheArcLengths = cache;
	
		return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
	};
	
	
	THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = true;
		this.getLengths();
	};
	
	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
	
	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {
	
		var arcLengths = this.getLengths();
	
		var i = 0, il = arcLengths.length;
	
		var targetArcLength; // The targeted u distance value to get
	
		if ( distance ) {
	
			targetArcLength = distance;
	
		} else {
	
			targetArcLength = u * arcLengths[ il - 1 ];
	
		}
	
		//var time = Date.now();
	
		// binary search for the index with largest value smaller than target u distance
	
		var low = 0, high = il - 1, comparison;
	
		while ( low <= high ) {
	
			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
			comparison = arcLengths[ i ] - targetArcLength;
	
			if ( comparison < 0 ) {
	
				low = i + 1;
				continue;
	
			} else if ( comparison > 0 ) {
	
				high = i - 1;
				continue;
	
			} else {
	
				high = i;
				break;
	
				// DONE
	
			}
	
		}
	
		i = high;
	
		//console.log('b' , i, low, high, Date.now()- time);
	
		if ( arcLengths[ i ] == targetArcLength ) {
	
			var t = i / ( il - 1 );
			return t;
	
		}
	
		// we could get finer grain at lengths, or use simple interpolatation between two points
	
		var lengthBefore = arcLengths[ i ];
	    var lengthAfter = arcLengths[ i + 1 ];
	
	    var segmentLength = lengthAfter - lengthBefore;
	
	    // determine where we are between the 'before' and 'after' points
	
	    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
	    // add that fractional amount to t
	
	    var t = ( i + segmentFraction ) / ( il -1 );
	
		return t;
	
	};
	
	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation
	
	THREE.Curve.prototype.getTangent = function( t ) {
	
		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;
	
		// Capping in case of danger
	
		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;
	
		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );
	
		var vec = pt2.clone().sub(pt1);
		return vec.normalize();
	
	};
	
	
	THREE.Curve.prototype.getTangentAt = function ( u ) {
	
		var t = this.getUtoTmapping( u );
		return this.getTangent( t );
	
	};
	
	
	
	
	
	/**************************************************************
	 *	Utils
	 **************************************************************/
	
	THREE.Curve.Utils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function (t, p0, p1, p2, p3 ) {
	
			return -3 * p0 * (1 - t) * (1 - t)  +
				3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
				6 * t *  p2 * (1-t) - 3 * t * t * p2 +
				3 * t * t * p3;
		},
	
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
			var h01 = -6 * t * t + 6 * t; 	// − 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 − t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
		this.bends = [];
		
		this.autoClose = false; // Automatically closes the path
	};
	
	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.CurvePath.prototype.add = function ( curve ) {
	
		this.curves.push( curve );
	
	};
	
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	
	THREE.CurvePath.prototype.closePath = function() {
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[0].getPoint(0);
		var endPoint = this.curves[this.curves.length-1].getPoint(1);
		
		if (!startPoint.equals(endPoint)) {
			this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
		}
		
	};
	
	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	
	THREE.CurvePath.prototype.getPoint = function( t ) {
	
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;
	
		// To think about boundaries points.
	
		while ( i < curveLengths.length ) {
	
			if ( curveLengths[ i ] >= d ) {
	
				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];
	
				var u = 1 - diff / curve.getLength();
	
				return curve.getPointAt( u );
	
				break;
			}
	
			i ++;
	
		}
	
		return null;
	
		// loop where sum != 0, sum > d , sum+1 <d
	
	};
	
	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/
	
	
	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	
	THREE.CurvePath.prototype.getLength = function() {
	
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	
	};
	
	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	
	THREE.CurvePath.prototype.getCurveLengths = function() {
	
		// We use cache values if curves and cache array are same length
	
		if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {
	
			return this.cacheLengths;
	
		};
	
		// Get length of subsurve
		// Push sums into cached array
	
		var lengths = [], sums = 0;
		var i, il = this.curves.length;
	
		for ( i = 0; i < il; i ++ ) {
	
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
	
		}
	
		this.cacheLengths = lengths;
	
		return lengths;
	
	};
	
	
	
	// Returns min and max coordinates, as well as centroid
	
	THREE.CurvePath.prototype.getBoundingBox = function () {
	
		var points = this.getPoints();
	
		var maxX, maxY, maxZ;
		var minX, minY, minZ;
	
		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;
	
		var p, i, il, sum;
	
		var v3 = points[0] instanceof THREE.Vector3;
	
		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
	
		for ( i = 0, il = points.length; i < il; i ++ ) {
	
			p = points[ i ];
	
			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;
	
			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;
	
			if ( v3 ) {
	
				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;
	
			}
	
			sum.add( p );
	
		}
	
		var ret = {
	
			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY,
			centroid: sum.divideScalar( il )
	
		};
	
		if ( v3 ) {
	
			ret.maxZ = maxZ;
			ret.minZ = minZ;
	
		}
	
		return ret;
	
	};
	
	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/
	
	/// Generate geometry from path points (for Line or ParticleSystem objects)
	
	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {
	
		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	// Generate geometry from equidistance sampling along the path
	
	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {
	
		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	THREE.CurvePath.prototype.createGeometry = function( points ) {
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < points.length; i ++ ) {
	
			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );
	
		}
	
		return geometry;
	
	};
	
	
	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/
	
	// Wrap path / Bend modifiers?
	
	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {
	
		this.bends.push( bendpath );
	
	};
	
	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {
	
		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;
	
		if ( !bends ) {
	
			bends = this.bends;
	
		}
	
		for ( i = 0, il = bends.length; i < il; i ++ ) {
	
			oldPts = this.getWrapPoints( oldPts, bends[ i ] );
	
		}
	
		return oldPts;
	
	};
	
	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {
	
		var oldPts = this.getSpacedPoints( segments );
	
		var i, il;
	
		if ( !bends ) {
	
			bends = this.bends;
	
		}
	
		for ( i = 0, il = bends.length; i < il; i ++ ) {
	
			oldPts = this.getWrapPoints( oldPts, bends[ i ] );
	
		}
	
		return oldPts;
	
	};
	
	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html
	
	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {
	
		var bounds = this.getBoundingBox();
	
		var i, il, p, oldX, oldY, xNorm;
	
		for ( i = 0, il = oldPts.length; i < il; i ++ ) {
	
			p = oldPts[ i ];
	
			oldX = p.x;
			oldY = p.y;
	
			xNorm = oldX / bounds.maxX;
	
			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance
	
			xNorm = path.getUtoTmapping( xNorm, oldX );
	
			// check for out of bounds?
	
			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( -normal.y, normal.x ).multiplyScalar( oldY );
	
			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;
	
		}
	
		return oldPts;
	
	};
	
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Gyroscope = function () {
	
		THREE.Object3D.call( this );
	
	};
	
	THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {
	
		this.matrixAutoUpdate && this.updateMatrix();
	
		// update matrixWorld
	
		if ( this.matrixWorldNeedsUpdate || force ) {
	
			if ( this.parent ) {
	
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				this.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );
				this.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );
	
				this.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );
	
	
			} else {
	
				this.matrixWorld.copy( this.matrix );
	
			}
	
	
			this.matrixWorldNeedsUpdate = false;
	
			force = true;
	
		}
	
		// update children
	
		for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
			this.children[ i ].updateMatrixWorld( force );
	
		}
	
	};
	
	THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
	THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
	THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
	THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
	THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
	THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
	
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call(this);
	
		this.actions = [];
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	
	THREE.PathActions = {
	
		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};
	
	// TODO Clean up PATH API
	
	// Create path using straight lines to connect all points
	// - vectors: array of Vector2
	
	THREE.Path.prototype.fromPoints = function ( vectors ) {
	
		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {
	
			this.lineTo( vectors[ v ].x, vectors[ v ].y );
	
		};
	
	};
	
	// startPath() endPath()?
	
	THREE.Path.prototype.moveTo = function ( x, y ) {
	
		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.lineTo = function ( x, y ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {
	
		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );
	
		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );
	
	};
	
	// FUTURE: Change the API or follow canvas API?
	
	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absarc(aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	 };
	
	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	
	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var args = Array.prototype.slice.call( arguments );
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise );
		this.curves.push( curve );
	
		var lastPoint = curve.getPoint(1);
		args.push(lastPoint.x);
		args.push(lastPoint.y);
	
		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );
	
	 };
	
	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {
	
		if ( ! divisions ) divisions = 40;
	
		var points = [];
	
		for ( var i = 0; i < divisions; i ++ ) {
	
			points.push( this.getPoint( i / divisions ) );
	
			//if( !this.getPoint( i / divisions ) ) throw "DIE";
	
		}
	
		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }
	
		return points;
	
	};
	
	/* Return an array of vectors based on contour of the path */
	
	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {
	
		if (this.useSpacedPoints) {
			console.log('tata');
			return this.getSpacedPoints( divisions, closedPath );
		}
	
		divisions = divisions || 12;
	
		var points = [];
	
		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;
	
		for ( i = 0, il = this.actions.length; i < il; i ++ ) {
	
			item = this.actions[ i ];
	
			action = item.action;
			args = item.args;
	
			switch( action ) {
	
			case THREE.PathActions.MOVE_TO:
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case THREE.PathActions.LINE_TO:
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case THREE.PathActions.QUADRATIC_CURVE_TO:
	
				cpx  = args[ 2 ];
				cpy  = args[ 3 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
				for ( j = 1; j <= divisions; j ++ ) {
	
					t = j / divisions;
	
					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case THREE.PathActions.BEZIER_CURVE_TO:
	
				cpx  = args[ 4 ];
				cpy  = args[ 5 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
	
				for ( j = 1; j <= divisions; j ++ ) {
	
					t = j / divisions;
	
					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case THREE.PathActions.CSPLINE_THRU:
	
				laste = this.actions[ i - 1 ].args;
	
				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];
	
				var n = divisions * args[ 0 ].length;
	
				spts = spts.concat( args[ 0 ] );
	
				var spline = new THREE.SplineCurve( spts );
	
				for ( j = 1; j <= n; j ++ ) {
	
					points.push( spline.getPointAt( j / n ) ) ;
	
				}
	
				break;
	
			case THREE.PathActions.ARC:
	
				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !!args[ 5 ];
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( j = 1; j <= tdivisions; j ++ ) {
	
					t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
			  break;
			  
			case THREE.PathActions.ELLIPSE:
	
				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !!args[ 6 ];
	
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( j = 1; j <= tdivisions; j ++ ) {
	
					t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
			  break;
	
			} // end switch
	
		}
	
	
	
		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1];
		var EPSILON = 0.0000000001;
		if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
				 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
			points.splice( points.length - 1, 1);
		if ( closedPath ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	// Breaks path into shapes
	
	THREE.Path.prototype.toShapes = function( isCCW ) {
	
		var i, il, item, action, args;
	
		var subPaths = [], lastPath = new THREE.Path();
	
		for ( i = 0, il = this.actions.length; i < il; i ++ ) {
	
			item = this.actions[ i ];
	
			args = item.args;
			action = item.action;
	
			if ( action == THREE.PathActions.MOVE_TO ) {
	
				if ( lastPath.actions.length != 0 ) {
	
					subPaths.push( lastPath );
					lastPath = new THREE.Path();
	
				}
	
			}
	
			lastPath[ action ].apply( lastPath, args );
	
		}
	
		if ( lastPath.actions.length != 0 ) {
	
			subPaths.push( lastPath );
	
		}
	
		// console.log(subPaths);
	
		if ( subPaths.length == 0 ) return [];
	
		var solid, tmpPath, tmpShape, shapes = [];
	
		if ( subPaths.length == 1) {
	
			tmpPath = subPaths[0];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
	
		}
	
		var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? !holesFirst : holesFirst;
	
		// console.log("Holes first", holesFirst);
	
		if ( holesFirst ) {
	
			tmpShape = new THREE.Shape();
	
			for ( i = 0, il = subPaths.length; i < il; i ++ ) {
	
				tmpPath = subPaths[ i ];
				solid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );
				solid = isCCW ? !solid : solid;
	
				if ( solid ) {
	
					tmpShape.actions = tmpPath.actions;
					tmpShape.curves = tmpPath.curves;
	
					shapes.push( tmpShape );
					tmpShape = new THREE.Shape();
	
					//console.log('cw', i);
	
				} else {
	
					tmpShape.holes.push( tmpPath );
	
					//console.log('ccw', i);
	
				}
	
			}
	
		} else {
	
			// Shapes first
			tmpShape = undefined;
	
			for ( i = 0, il = subPaths.length; i < il; i ++ ) {
	
				tmpPath = subPaths[ i ];
				solid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );
				solid = isCCW ? !solid : solid;
	
				if ( solid ) {
	
					if ( tmpShape ) shapes.push( tmpShape );
	
					tmpShape = new THREE.Shape();
					tmpShape.actions = tmpPath.actions;
					tmpShape.curves = tmpPath.curves;
	
				} else {
	
					tmpShape.holes.push( tmpPath );
	
				}
	
			}
	
			shapes.push( tmpShape );
	
		}
	
		//console.log("shape", shapes);
	
		return shapes;
	
	};
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	
	// Convenience method to return ExtrudeGeometry
	
	THREE.Shape.prototype.extrude = function ( options ) {
	
		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;
	
	};
	
	// Convenience method to return ShapeGeometry
	
	THREE.Shape.prototype.makeGeometry = function ( options ) {
	
		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;
	
	};
	
	// Get points of holes
	
	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {
	
		var i, il = this.holes.length, holesPts = [];
	
		for ( i = 0; i < il; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );
	
		}
	
		return holesPts;
	
	};
	
	// Get points of holes (spaced by regular distance)
	
	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {
	
		var i, il = this.holes.length, holesPts = [];
	
		for ( i = 0; i < il; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );
	
		}
	
		return holesPts;
	
	};
	
	
	// Get points of shape and holes (keypoints based on segments parameter)
	
	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {
	
		return {
	
			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )
	
		};
	
	};
	
	THREE.Shape.prototype.extractPoints = function ( divisions ) {
	
		if (this.useSpacedPoints) {
			return this.extractAllSpacedPoints(divisions);
		}
	
		return this.extractAllPoints(divisions);
	
	};
	
	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };
	
	// Get points of shape and holes (spaced by regular distance)
	
	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {
	
		return {
	
			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )
	
		};
	
	};
	
	/**************************************************************
	 *	Utils
	 **************************************************************/
	
	THREE.Shape.Utils = {
	
		/*
			contour - array of vector2 for contour
			holes   - array of array of vector2
		*/
	
		removeHoles: function ( contour, holes ) {
	
			var shape = contour.concat(); // work on this shape
			var allpoints = shape.concat();
	
			/* For each isolated shape, find the closest points and break to the hole to allow triangulation */
	
	
			var prevShapeVert, nextShapeVert,
				prevHoleVert, nextHoleVert,
				holeIndex, shapeIndex,
				shapeId, shapeGroup,
				h, h2,
				hole, shortest, d,
				p, pts1, pts2,
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2,
				verts = [];
	
			for ( h = 0; h < holes.length; h ++ ) {
	
				hole = holes[ h ];
	
				/*
				shapeholes[ h ].concat(); // preserves original
				holes.push( hole );
				*/
	
				Array.prototype.push.apply( allpoints, hole );
	
				shortest = Number.POSITIVE_INFINITY;
	
	
				// Find the shortest pair of pts between shape and hole
	
				// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)
				// Using distanceToSquared() intead of distanceTo() should speed a little
				// since running square roots operations are reduced.
	
				for ( h2 = 0; h2 < hole.length; h2 ++ ) {
	
					pts1 = hole[ h2 ];
					var dist = [];
	
					for ( p = 0; p < shape.length; p++ ) {
	
						pts2 = shape[ p ];
						d = pts1.distanceToSquared( pts2 );
						dist.push( d );
	
						if ( d < shortest ) {
	
							shortest = d;
							holeIndex = h2;
							shapeIndex = p;
	
						}
	
					}
	
				}
	
				//console.log("shortest", shortest, dist);
	
				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;
	
				var areaapts = [
	
					hole[ holeIndex ],
					shape[ shapeIndex ],
					shape[ prevShapeVert ]
	
				];
	
				var areaa = THREE.FontUtils.Triangulate.area( areaapts );
	
				var areabpts = [
	
					hole[ holeIndex ],
					hole[ prevHoleVert ],
					shape[ shapeIndex ]
	
				];
	
				var areab = THREE.FontUtils.Triangulate.area( areabpts );
	
				var shapeOffset = 1;
				var holeOffset = -1;
	
				var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
				shapeIndex += shapeOffset;
				holeIndex += holeOffset;
	
				if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
				shapeIndex %= shape.length;
	
				if ( holeIndex < 0 ) { holeIndex += hole.length;  }
				holeIndex %= hole.length;
	
				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;
	
				areaapts = [
	
					hole[ holeIndex ],
					shape[ shapeIndex ],
					shape[ prevShapeVert ]
	
				];
	
				var areaa2 = THREE.FontUtils.Triangulate.area( areaapts );
	
				areabpts = [
	
					hole[ holeIndex ],
					hole[ prevHoleVert ],
					shape[ shapeIndex ]
	
				];
	
				var areab2 = THREE.FontUtils.Triangulate.area( areabpts );
				//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));
	
				if ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {
	
					// In case areas are not correct.
					//console.log("USE THIS");
	
					shapeIndex = oldShapeIndex;
					holeIndex = oldHoleIndex ;
	
					if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
					shapeIndex %= shape.length;
	
					if ( holeIndex < 0 ) { holeIndex += hole.length;  }
					holeIndex %= hole.length;
	
					prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
					prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;
	
				} else {
	
					//console.log("USE THAT ")
	
				}
	
				tmpShape1 = shape.slice( 0, shapeIndex );
				tmpShape2 = shape.slice( shapeIndex );
				tmpHole1 = hole.slice( holeIndex );
				tmpHole2 = hole.slice( 0, holeIndex );
	
				// Should check orders here again?
	
				var trianglea = [
	
					hole[ holeIndex ],
					shape[ shapeIndex ],
					shape[ prevShapeVert ]
	
				];
	
				var triangleb = [
	
					hole[ holeIndex ] ,
					hole[ prevHoleVert ],
					shape[ shapeIndex ]
	
				];
	
				verts.push( trianglea );
				verts.push( triangleb );
	
				shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
			}
	
			return {
	
				shape:shape, 		/* shape with no holes */
				isolatedPts: verts, /* isolated faces */
				allpoints: allpoints
	
			}
	
	
		},
	
		triangulateShape: function ( contour, holes ) {
	
			var shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );
	
			var shape = shapeWithoutHoles.shape,
				allpoints = shapeWithoutHoles.allpoints,
				isolatedPts = shapeWithoutHoles.isolatedPts;
	
			var triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			//console.log( "triangles",triangles, triangles.length );
			//console.log( "allpoints",allpoints, allpoints.length );
	
			var i, il, f, face,
				key, index,
				allPointsMap = {},
				isolatedPointsMap = {};
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					console.log( "Duplicate point", key );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			// check isolated points vertices against all points map
	
			for ( i = 0, il = isolatedPts.length; i < il; i ++ ) {
	
				face = isolatedPts[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat( isolatedPts );
	
		}, // end triangulate shapes
	
		/*
		triangulate2 : function( pts, holes ) {
	
			// For use with Poly2Tri.js
	
			var allpts = pts.concat();
			var shape = [];
			for (var p in pts) {
				shape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));
			}
	
			var swctx = new js.poly2tri.SweepContext(shape);
	
			for (var h in holes) {
				var aHole = holes[h];
				var newHole = []
				for (i in aHole) {
					newHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));
					allpts.push(aHole[i]);
				}
				swctx.AddHole(newHole);
			}
	
			var find;
			var findIndexForPt = function (pt) {
				find = new THREE.Vector2(pt.x, pt.y);
				var p;
				for (p=0, pl = allpts.length; p<pl; p++) {
					if (allpts[p].equals(find)) return p;
				}
				return -1;
			};
	
			// triangulate
			js.poly2tri.sweep.Triangulate(swctx);
	
			var triangles =  swctx.GetTriangles();
			var tr ;
			var facesPts = [];
			for (var t in triangles) {
				tr =  triangles[t];
				facesPts.push([
					findIndexForPt(tr.GetPoint(0)),
					findIndexForPt(tr.GetPoint(1)),
					findIndexForPt(tr.GetPoint(2))
						]);
			}
	
	
		//	console.log(facesPts);
		//	console.log("triangles", triangles.length, triangles);
	
			// Returns array of faces with 3 element each
		return facesPts;
		},
	*/
	
		isClockWise: function ( pts ) {
	
			return THREE.FontUtils.Triangulate.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2p0: function ( t, p ) {
	
			var k = 1 - t;
			return k * k * p;
	
		},
	
		b2p1: function ( t, p ) {
	
			return 2 * ( 1 - t ) * t * p;
	
		},
	
		b2p2: function ( t, p ) {
	
			return t * t * p;
	
		},
	
		b2: function ( t, p0, p1, p2 ) {
	
			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );
	
		},
	
		// Cubic Bezier Functions
	
		b3p0: function ( t, p ) {
	
			var k = 1 - t;
			return k * k * k * p;
	
		},
	
		b3p1: function ( t, p ) {
	
			var k = 1 - t;
			return 3 * k * k * t * p;
	
		},
	
		b3p2: function ( t, p ) {
	
			var k = 1 - t;
			return 3 * k * t * t * p;
	
		},
	
		b3p3: function ( t, p ) {
	
			return t * t * t * p;
	
		},
	
		b3: function ( t, p0, p1, p2, p3 ) {
	
			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );
	
		}
	
	};
	
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub(this.v1);
	
		return tangent.normalize();
	
	};
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var tx, ty;
	
		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var tx, ty;
	
		tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );
	
		// returns unit vector
	
		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();
	
		return tangent;
	
	};
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var tx, ty;
	
		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tx, ty;
	
		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
	
		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();
	
		return tangent;
	
	};
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = (points == undefined) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var v = new THREE.Vector2();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;
	
		intPoint = Math.floor( point );
		weight = point - intPoint;
	
		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;
	
		v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
		v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
	
		return v;
	
	};
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.EllipseCurve.prototype.getPoint = function ( t ) {
	
		var angle;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
	
		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;
	
		if ( this.aClockwise === true ) {
	
			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );
	
		} else {
	
			angle = this.aStartAngle + t * deltaAngle;
	
		}
	
		var tx = this.aX + this.xRadius * Math.cos( angle );
		var ty = this.aY + this.yRadius * Math.sin( angle );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var r = new THREE.Vector3();
	
	
			r.subVectors( this.v2, this.v1 ); // diff
			r.multiplyScalar( t );
			r.add( this.v1 );
	
			return r;
	
		}
	
	);
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var tx, ty, tz;
	
			tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	);
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var tx, ty, tz;
	
			tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	);
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */) {
	
			this.points = (points == undefined) ? [] : points;
	
		},
	
		function ( t ) {
	
			var v = new THREE.Vector3();
			var c = [];
			var points = this.points, point, intPoint, weight;
			point = ( points.length - 1 ) * t;
	
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;
	
			var pt0 = points[ c[0] ],
				pt1 = points[ c[1] ],
				pt2 = points[ c[2] ],
				pt3 = points[ c[3] ];
	
			v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
			v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
			v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);
	
			return v;
	
		}
	
	);
	
	
	// THREE.SplineCurve3.prototype.getTangent = function(t) {
	// 		var v = new THREE.Vector3();
	// 		var c = [];
	// 		var points = this.points, point, intPoint, weight;
	// 		point = ( points.length - 1 ) * t;
	
	// 		intPoint = Math.floor( point );
	// 		weight = point - intPoint;
	
	// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	// 		c[ 1 ] = intPoint;
	// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
	// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;
	
	// 		var pt0 = points[ c[0] ],
	// 			pt1 = points[ c[1] ],
	// 			pt2 = points[ c[2] ],
	// 			pt3 = points[ c[3] ];
	
	// 	// t = weight;
	// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
	// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
	// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );
	
	// 	return v;
	
	// }
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */) {
	
			this.points = (points == undefined) ? [] : points;
	
		},
	
	    function ( t ) {
	
	        var v = new THREE.Vector3();
	        var c = [];
	        var points = this.points, point, intPoint, weight;
	        point = ( points.length - 0 ) * t;
	            // This needs to be from 0-length +1
	
	        intPoint = Math.floor( point );
	        weight = point - intPoint;
	
	        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	        c[ 0 ] = ( intPoint - 1 ) % points.length;
	        c[ 1 ] = ( intPoint ) % points.length;
	        c[ 2 ] = ( intPoint + 1 ) % points.length;
	        c[ 3 ] = ( intPoint + 2 ) % points.length;
	
	        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
	        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );
	
	        return v;
	
	    }
	
	);
	/**
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.AnimationHandler = (function() {
	
		var playing = [];
		var library = {};
		var that    = {};
	
	
		//--- update ---
	
		that.update = function( deltaTimeMS ) {
	
			for( var i = 0; i < playing.length; i ++ )
				playing[ i ].update( deltaTimeMS );
	
		};
	
	
		//--- add ---
	
		that.addToUpdate = function( animation ) {
	
			if ( playing.indexOf( animation ) === -1 )
				playing.push( animation );
	
		};
	
	
		//--- remove ---
	
		that.removeFromUpdate = function( animation ) {
	
			var index = playing.indexOf( animation );
	
			if( index !== -1 )
				playing.splice( index, 1 );
	
		};
	
	
		//--- add ---
	
		that.add = function( data ) {
	
			if ( library[ data.name ] !== undefined )
				console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );
	
			library[ data.name ] = data;
			initData( data );
	
		};
	
	
		//--- get ---
	
		that.get = function( name ) {
	
			if ( typeof name === "string" ) {
	
				if ( library[ name ] ) {
	
					return library[ name ];
	
				} else {
	
					console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
					return null;
	
				}
	
			} else {
	
				// todo: add simple tween library
	
			}
	
		};
	
		//--- parse ---
	
		that.parse = function( root ) {
	
			// setup hierarchy
	
			var hierarchy = [];
	
			if ( root instanceof THREE.SkinnedMesh ) {
	
				for( var b = 0; b < root.bones.length; b++ ) {
	
					hierarchy.push( root.bones[ b ] );
	
				}
	
			} else {
	
				parseRecurseHierarchy( root, hierarchy );
	
			}
	
			return hierarchy;
	
		};
	
		var parseRecurseHierarchy = function( root, hierarchy ) {
	
			hierarchy.push( root );
	
			for( var c = 0; c < root.children.length; c++ )
				parseRecurseHierarchy( root.children[ c ], hierarchy );
	
		}
	
	
		//--- init data ---
	
		var initData = function( data ) {
	
			if( data.initialized === true )
				return;
	
	
			// loop through all keys
	
			for( var h = 0; h < data.hierarchy.length; h ++ ) {
	
				for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					// remove minus times
	
					if( data.hierarchy[ h ].keys[ k ].time < 0 )
						data.hierarchy[ h ].keys[ k ].time = 0;
	
	
					// create quaternions
	
					if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {
	
						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );
	
					}
	
				}
	
	
				// prepare morph target keys
	
				if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {
	
					// get all used
	
					var usedMorphTargets = {};
	
					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {
	
							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = -1;
	
						}
	
					}
	
					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;
	
	
					// set all used on all frames
	
					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
						var influences = {};
	
						for ( var morphTargetName in usedMorphTargets ) {
	
							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {
	
								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {
	
									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;
	
								}
	
							}
	
							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {
	
								influences[ morphTargetName ] = 0;
	
							}
	
						}
	
						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;
	
					}
	
				}
	
	
				// remove all keys that are on the same time
	
				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {
	
						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;
	
					}
	
				}
	
	
				// set index
	
				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					data.hierarchy[ h ].keys[ k ].index = k;
	
				}
	
			}
	
	
			// JIT
	
			var lengthInFrames = parseInt( data.length * data.fps, 10 );
	
			data.JIT = {};
			data.JIT.hierarchy = [];
	
			for( var h = 0; h < data.hierarchy.length; h ++ )
				data.JIT.hierarchy.push( new Array( lengthInFrames ) );
	
	
			// done
	
			data.initialized = true;
	
		};
	
	
		// interpolation types
	
		that.LINEAR = 0;
		that.CATMULLROM = 1;
		that.CATMULLROM_FORWARD = 2;
	
		return that;
	
	}());
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Animation = function ( root, name, interpolationType ) {
	
		this.root = root;
		this.data = THREE.AnimationHandler.get( name );
		this.hierarchy = THREE.AnimationHandler.parse( root );
	
		this.currentTime = 0;
		this.timeScale = 1;
	
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;
	
		this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;
	
		this.points = [];
		this.target = new THREE.Vector3();
	
	};
	
	THREE.Animation.prototype.play = function ( loop, startTimeMS ) {
	
		if ( this.isPlaying === false ) {
	
			this.isPlaying = true;
			this.loop = loop !== undefined ? loop : true;
			this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
	
			// reset key cache
	
			var h, hl = this.hierarchy.length,
				object;
	
			for ( h = 0; h < hl; h ++ ) {
	
				object = this.hierarchy[ h ];
	
				object.matrixAutoUpdate = true;
	
				if ( object.animationCache === undefined ) {
	
					object.animationCache = {};
					object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
					object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
					object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
	
				}
	
				var prevKey = object.animationCache.prevKey;
				var nextKey = object.animationCache.nextKey;
	
				prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
				prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
				prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];
	
				nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
				nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
				nextKey.scl = this.getNextKeyWith( "scl", h, 1 );
	
			}
	
			this.update( 0 );
	
		}
	
		this.isPaused = false;
	
		THREE.AnimationHandler.addToUpdate( this );
	
	};
	
	
	THREE.Animation.prototype.pause = function() {
	
		if ( this.isPaused === true ) {
	
			THREE.AnimationHandler.addToUpdate( this );
	
		} else {
	
			THREE.AnimationHandler.removeFromUpdate( this );
	
		}
	
		this.isPaused = !this.isPaused;
	
	};
	
	
	THREE.Animation.prototype.stop = function() {
	
		this.isPlaying = false;
		this.isPaused  = false;
		THREE.AnimationHandler.removeFromUpdate( this );
	
	};
	
	
	THREE.Animation.prototype.update = function ( deltaTimeMS ) {
	
		// early out
	
		if ( this.isPlaying === false ) return;
	
	
		// vars
	
		var types = [ "pos", "rot", "scl" ];
		var type;
		var scale;
		var vector;
		var prevXYZ, nextXYZ;
		var prevKey, nextKey;
		var object;
		var animationCache;
		var frame;
		var JIThierarchy = this.data.JIT.hierarchy;
		var currentTime, unloopedCurrentTime;
		var currentPoint, forwardPoint, angle;
	
	
		this.currentTime += deltaTimeMS * this.timeScale;
	
		unloopedCurrentTime = this.currentTime;
	
		// Mod operation fails on floats
		// was this supposed to be in frames?
		while ( this.currentTime > this.data.length ) {
	
			this.currentTime -= this.data.length;
	
		}
	
		currentTime = this.currentTime = this.currentTime % this.data.length;
	
		
		frame = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
	
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
			object = this.hierarchy[ h ];
			animationCache = object.animationCache;
	
			// loop through pos/rot/scl
	
			for ( var t = 0; t < 3; t ++ ) {
	
				// get keys
	
				type    = types[ t ];
				prevKey = animationCache.prevKey[ type ];
				nextKey = animationCache.nextKey[ type ];
	
				// switch keys?
				
				if ( nextKey.time <= unloopedCurrentTime ) {
	
					// did we loop?
	
					if ( currentTime <= unloopedCurrentTime ) {
	
						if ( this.loop ) {
	
							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );
	
							// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever
							while ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index) {
	
								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
							}
	
						} else {
	
							this.stop();
							return;
	
						}
	
					} else {
	
						do {
	
							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
						} while ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index )
						// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever
	
					}
	
					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;
	
				}
	
	
				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;
	
				scale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
				prevXYZ = prevKey[ type ];
				nextXYZ = nextKey[ type ];
	
	
				// check scale error
	
				if ( scale < 0 || scale > 1 ) {
	
					console.log( "THREE.Animation.update: Warning! Scale out of bounds:" + scale + " on bone " + h );
					scale = scale < 0 ? 0 : 1;
	
				}
	
				// interpolate
	
				if ( type === "pos" ) {
	
					vector = object.position;
	
					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {
	
						vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
							    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
						this.points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						this.points[ 1 ] = prevXYZ;
						this.points[ 2 ] = nextXYZ;
						this.points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];
	
						scale = scale * 0.33 + 0.33;
	
						currentPoint = this.interpolateCatmullRom( this.points, scale );
	
						vector.x = currentPoint[ 0 ];
						vector.y = currentPoint[ 1 ];
						vector.z = currentPoint[ 2 ];
	
						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
							forwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );
	
							this.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							this.target.sub( vector );
							this.target.y = 0;
							this.target.normalize();
	
							angle = Math.atan2( this.target.x, this.target.z );
							object.rotation.set( 0, angle, 0 );
	
						}
	
					}
	
				} else if ( type === "rot" ) {
	
					THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );
	
				} else if ( type === "scl" ) {
	
					vector = object.scale;
	
					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
				}
	
			}
	
		}
	
	};
	
	// Catmull-Rom spline
	
	THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {
	
		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;
	
		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
	
		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];
	
		w2 = weight * weight;
		w3 = weight * w2;
	
		v3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );
	
		return v3;
	
	};
	
	THREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {
	
		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;
	
		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
	};
	
	
	
	// Get next key with
	
	THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
	
		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
			key = key < keys.length - 1 ? key : keys.length - 1;
	
		} else {
	
			key = key % keys.length;
	
		}
	
		for ( ; key < keys.length; key++ ) {
	
			if ( keys[ key ][ type ] !== undefined ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return this.data.hierarchy[ h ].keys[ 0 ];
	
	};
	
	// Get previous key with
	
	THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
	
		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
			key = key > 0 ? key : 0;
	
		} else {
	
			key = key >= 0 ? key : key + keys.length;
	
		}
	
	
		for ( ; key >= 0; key -- ) {
	
			if ( keys[ key ][ type ] !== undefined ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return this.data.hierarchy[ h ].keys[ keys.length - 1 ];
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */
	
	THREE.KeyFrameAnimation = function( root, data, JITCompile ) {
	
		this.root = root;
		this.data = THREE.AnimationHandler.get( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;
		this.JITCompile = JITCompile !== undefined ? JITCompile : true;
	
		// initialize to first keyframes
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {
	
			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				obj = this.hierarchy[h];
	
			if ( keys.length && sids ) {
	
				for ( var s = 0; s < sids.length; s++ ) {
	
					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );
	
					if ( next ) {
	
						next.apply( sid );
	
					}
	
				}
	
				obj.matrixAutoUpdate = false;
				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;
	
			}
	
		}
	
	};
	
	// Play
	
	THREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {
	
		if( !this.isPlaying ) {
	
			this.isPlaying = true;
			this.loop = loop !== undefined ? loop : true;
			this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
			this.startTimeMs = startTimeMS;
			this.startTime = 10000000;
			this.endTime = -this.startTime;
	
	
			// reset key cache
	
			var h, hl = this.hierarchy.length,
				object,
				node;
	
			for ( h = 0; h < hl; h++ ) {
	
				object = this.hierarchy[ h ];
				node = this.data.hierarchy[ h ];
	
				if ( node.animationCache === undefined ) {
	
					node.animationCache = {};
					node.animationCache.prevKey = null;
					node.animationCache.nextKey = null;
					node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
	
				}
	
				var keys = this.data.hierarchy[h].keys;
	
				if (keys.length) {
	
					node.animationCache.prevKey = keys[ 0 ];
					node.animationCache.nextKey = keys[ 1 ];
	
					this.startTime = Math.min( keys[0].time, this.startTime );
					this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );
	
				}
	
			}
	
			this.update( 0 );
	
		}
	
		this.isPaused = false;
	
		THREE.AnimationHandler.addToUpdate( this );
	
	};
	
	
	
	// Pause
	
	THREE.KeyFrameAnimation.prototype.pause = function() {
	
		if( this.isPaused ) {
	
			THREE.AnimationHandler.addToUpdate( this );
	
		} else {
	
			THREE.AnimationHandler.removeFromUpdate( this );
	
		}
	
		this.isPaused = !this.isPaused;
	
	};
	
	
	// Stop
	
	THREE.KeyFrameAnimation.prototype.stop = function() {
	
		this.isPlaying = false;
		this.isPaused  = false;
		THREE.AnimationHandler.removeFromUpdate( this );
	
	
		// reset JIT matrix and remove cache
	
		for ( var h = 0; h < this.data.hierarchy.length; h++ ) {
	        
	        var obj = this.hierarchy[ h ];
			var node = this.data.hierarchy[ h ];
	
			if ( node.animationCache !== undefined ) {
	
				var original = node.animationCache.originalMatrix;
	
				if( obj instanceof THREE.Bone ) {
	
					original.copy( obj.skinMatrix );
					obj.skinMatrix = original;
	
				} else {
	
					original.copy( obj.matrix );
					obj.matrix = original;
	
				}
	
				delete node.animationCache;
	
			}
	
		}
	
	};
	
	
	// Update
	
	THREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {
	
		// early out
	
		if( !this.isPlaying ) return;
	
	
		// vars
	
		var prevKey, nextKey;
		var object;
		var node;
		var frame;
		var JIThierarchy = this.data.JIT.hierarchy;
		var currentTime, unloopedCurrentTime;
		var looped;
	
	
		// update
	
		this.currentTime += deltaTimeMS * this.timeScale;
	
		unloopedCurrentTime = this.currentTime;
		currentTime         = this.currentTime = this.currentTime % this.data.length;
	
		// if looped around, the current time should be based on the startTime
		if ( currentTime < this.startTimeMs ) {
	
			currentTime = this.currentTime = this.startTimeMs + currentTime;
	
		}
	
		frame               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
		looped 				= currentTime < unloopedCurrentTime;
	
		if ( looped && !this.loop ) {
	
			// Set the animation to the last keyframes and stop
			for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {
	
				var keys = this.data.hierarchy[h].keys,
					sids = this.data.hierarchy[h].sids,
					end = keys.length-1,
					obj = this.hierarchy[h];
	
				if ( keys.length ) {
	
					for ( var s = 0; s < sids.length; s++ ) {
	
						var sid = sids[ s ],
							prev = this.getPrevKeyWith( sid, h, end );
	
						if ( prev ) {
							prev.apply( sid );
	
						}
	
					}
	
					this.data.hierarchy[h].node.updateMatrix();
					obj.matrixWorldNeedsUpdate = true;
	
				}
	
			}
	
			this.stop();
			return;
	
		}
	
		// check pre-infinity
		if ( currentTime < this.startTime ) {
	
			return;
	
		}
	
		// update
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {
	
			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];
	
			var keys = node.keys,
				animationCache = node.animationCache;
	
			// use JIT?
	
			if ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {
	
				if( object instanceof THREE.Bone ) {
	
					object.skinMatrix = JIThierarchy[ h ][ frame ];
					object.matrixWorldNeedsUpdate = false;
	
				} else {
	
					object.matrix = JIThierarchy[ h ][ frame ];
					object.matrixWorldNeedsUpdate = true;
	
				}
	
			// use interpolation
	
			} else if ( keys.length ) {
	
				// make sure so original matrix and not JIT matrix is set
	
				if ( this.JITCompile && animationCache ) {
	
					if( object instanceof THREE.Bone ) {
	
						object.skinMatrix = animationCache.originalMatrix;
	
					} else {
	
						object.matrix = animationCache.originalMatrix;
	
					}
	
				}
	
				prevKey = animationCache.prevKey;
				nextKey = animationCache.nextKey;
	
				if ( prevKey && nextKey ) {
	
					// switch keys?
	
					if ( nextKey.time <= unloopedCurrentTime ) {
	
						// did we loop?
	
						if ( looped && this.loop ) {
	
							prevKey = keys[ 0 ];
							nextKey = keys[ 1 ];
	
							while ( nextKey.time < currentTime ) {
	
								prevKey = nextKey;
								nextKey = keys[ prevKey.index + 1 ];
	
							}
	
						} else if ( !looped ) {
	
							var lastIndex = keys.length - 1;
	
							while ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {
	
								prevKey = nextKey;
								nextKey = keys[ prevKey.index + 1 ];
	
							}
	
						}
	
						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;
	
					}
	                if(nextKey.time >= currentTime)
	                    prevKey.interpolate( nextKey, currentTime );
	                else
	                    prevKey.interpolate( nextKey, nextKey.time);
	
				}
	
				this.data.hierarchy[h].node.updateMatrix();
				object.matrixWorldNeedsUpdate = true;
	
			}
	
		}
	
		// update JIT?
	
		if ( this.JITCompile ) {
	
			if ( JIThierarchy[ 0 ][ frame ] === undefined ) {
	
				this.hierarchy[ 0 ].updateMatrixWorld( true );
	
				for ( var h = 0; h < this.hierarchy.length; h++ ) {
	
					if( this.hierarchy[ h ] instanceof THREE.Bone ) {
	
						JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();
	
					} else {
	
						JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();
	
					}
	
				}
	
			}
	
		}
	
	};
	
	// Get next key with
	
	THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
		key = key % keys.length;
	
		for ( ; key < keys.length; key++ ) {
	
			if ( keys[ key ].hasTarget( sid ) ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return keys[ 0 ];
	
	};
	
	// Get previous key with
	
	THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
		key = key >= 0 ? key : key + keys.length;
	
		for ( ; key >= 0; key-- ) {
	
			if ( keys[ key ].hasTarget( sid ) ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return keys[ keys.length - 1 ];
	
	};
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, -1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, -1, 0 );
		cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, -1 );
		cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, -1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, -1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
		this.add( cameraNZ );
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;
	
			renderTarget.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	
	/**
	 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
	 *
	 *	A general perpose camera, for setting FOV, Lens Focal Length,
	 *		and switching between perspective and orthographic views easily.
	 *		Use this only if you do not wish to manage
	 *		both a Orthographic and Perspective Camera
	 *
	 */
	
	
	THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {
	
		THREE.Camera.call( this );
	
		this.fov = fov;
	
		this.left = -width / 2;
		this.right = width / 2
		this.top = height / 2;
		this.bottom = -height / 2;
	
		// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects
	
		this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
		this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );
	
		this.zoom = 1;
	
		this.toPerspective();
	
		var aspect = width/height;
	
	};
	
	THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );
	
	THREE.CombinedCamera.prototype.toPerspective = function () {
	
		// Switches to the Perspective Camera
	
		this.near = this.cameraP.near;
		this.far = this.cameraP.far;
	
		this.cameraP.fov =  this.fov / this.zoom ;
	
		this.cameraP.updateProjectionMatrix();
	
		this.projectionMatrix = this.cameraP.projectionMatrix;
	
		this.inPerspectiveMode = true;
		this.inOrthographicMode = false;
	
	};
	
	THREE.CombinedCamera.prototype.toOrthographic = function () {
	
		// Switches to the Orthographic camera estimating viewport from Perspective
	
		var fov = this.fov;
		var aspect = this.cameraP.aspect;
		var near = this.cameraP.near;
		var far = this.cameraP.far;
	
		// The size that we set is the mid plane of the viewing frustum
	
		var hyperfocus = ( near + far ) / 2;
	
		var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
		var planeHeight = 2 * halfHeight;
		var planeWidth = planeHeight * aspect;
		var halfWidth = planeWidth / 2;
	
		halfHeight /= this.zoom;
		halfWidth /= this.zoom;
	
		this.cameraO.left = -halfWidth;
		this.cameraO.right = halfWidth;
		this.cameraO.top = halfHeight;
		this.cameraO.bottom = -halfHeight;
	
		// this.cameraO.left = -farHalfWidth;
		// this.cameraO.right = farHalfWidth;
		// this.cameraO.top = farHalfHeight;
		// this.cameraO.bottom = -farHalfHeight;
	
		// this.cameraO.left = this.left / this.zoom;
		// this.cameraO.right = this.right / this.zoom;
		// this.cameraO.top = this.top / this.zoom;
		// this.cameraO.bottom = this.bottom / this.zoom;
	
		this.cameraO.updateProjectionMatrix();
	
		this.near = this.cameraO.near;
		this.far = this.cameraO.far;
		this.projectionMatrix = this.cameraO.projectionMatrix;
	
		this.inPerspectiveMode = false;
		this.inOrthographicMode = true;
	
	};
	
	
	THREE.CombinedCamera.prototype.setSize = function( width, height ) {
	
		this.cameraP.aspect = width / height;
		this.left = -width / 2;
		this.right = width / 2
		this.top = height / 2;
		this.bottom = -height / 2;
	
	};
	
	
	THREE.CombinedCamera.prototype.setFov = function( fov ) {
	
		this.fov = fov;
	
		if ( this.inPerspectiveMode ) {
	
			this.toPerspective();
	
		} else {
	
			this.toOrthographic();
	
		}
	
	};
	
	// For mantaining similar API with PerspectiveCamera
	
	THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {
	
		if ( this.inPerspectiveMode ) {
	
			this.toPerspective();
	
		} else {
	
			this.toPerspective();
			this.toOrthographic();
	
		}
	
	};
	
	/*
	* Uses Focal Length (in mm) to estimate and set FOV
	* 35mm (fullframe) camera is used if frame size is not specified;
	* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	*/
	THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	
		this.setFov( fov );
	
		return fov;
	};
	
	
	THREE.CombinedCamera.prototype.setZoom = function( zoom ) {
	
		this.zoom = zoom;
	
		if ( this.inPerspectiveMode ) {
	
			this.toPerspective();
	
		} else {
	
			this.toOrthographic();
	
		}
	
	};
	
	THREE.CombinedCamera.prototype.toFrontView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = 0;
		this.rotation.z = 0;
	
		// should we be modifing the matrix instead?
	
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toBackView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = Math.PI;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toLeftView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = - Math.PI / 2;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toRightView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = Math.PI / 2;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toTopView = function() {
	
		this.rotation.x = - Math.PI / 2;
		this.rotation.y = 0;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toBottomView = function() {
	
		this.rotation.x = Math.PI / 2;
		this.rotation.y = 0;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.radius = radius = radius || 50;
		this.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
		this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );
	
		this.vertices.push(center);
		uvs.push( centerUV );
	
		for ( i = 0; i <= segments; i ++ ) {
	
			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;
	
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
	
			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 1; i <= segments; i ++ ) {
	
			var v1 = i;
			var v2 = i + 1 ;
			var v3 = 0;
	
			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );
	
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		var scope = this;
	
		this.width = width;
		this.height = height;
		this.depth = depth;
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;
	
		var width_half = this.width / 2;
		var height_half = this.height / 2;
		var depth_half = this.depth / 2;
	
		buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz
	
		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {
	
			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;
	
			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {
	
				w = 'z';
	
			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {
	
				w = 'y';
				gridY = scope.depthSegments;
	
			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {
	
				w = 'x';
				gridX = scope.depthSegments;
	
			}
	
			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();
	
			normal[ w ] = depth > 0 ? 1 : - 1;
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;
	
					scope.vertices.push( vector );
	
				}
	
			}
	
			for ( iy = 0; iy < gridY; iy++ ) {
	
				for ( ix = 0; ix < gridX; ix++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );
	
					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
				}
	
			}
	
		}
	
		this.computeCentroids();
		this.mergeVertices();
	
	};
	
	THREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {
	
		THREE.Geometry.call( this );
	
		this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
		this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		this.height = height = height !== undefined ? height : 100;
	
		this.radialSegments = radialSegments = radialSegments || 8;
		this.heightSegments = heightSegments = heightSegments || 1;
	
		this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;
	
		var heightHalf = height / 2;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * Math.PI * 2 );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * Math.PI * 2 );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;
	
		for ( x = 0; x < radialSegments; x ++ ) {
	
			if ( radiusTop !== 0 ) {
	
				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();
	
			} else {
	
				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();
	
			}
	
			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();
	
			for ( y = 0; y < heightSegments; y ++ ) {
	
				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];
	
				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();
	
				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();
	
				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
			}
	
		}
	
		// top cap
	
		if ( openEnded === false && radiusTop > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );
	
				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		// bottom cap
	
		if ( openEnded === false && radiusBottom > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );
	
				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
	}
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  material: <int> // material index for front and back faces
	 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
			shapes = [];
			return;
		}
	
		THREE.Geometry.call( this );
	
		shapes = shapes instanceof Array ? shapes : [ shapes ];
	
		this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();
	
		this.addShapeList( shapes, options );
	
		this.computeCentroids();
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
			var shape = shapes[ s ];
			this.addShape( shape, options );
		}
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		var material = options.material;
		var extrudeMaterial = options.extrudeMaterial;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var shapebb = this.shapebb;
		//shapebb = shape.getBoundingBox();
	
	
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initalization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
		var bevelPoints = [];
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( !vec ) console.log( "die" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length,
			cont, clen = contour.length;
	
	
		// Find directions for point movement
	
		var RAD_TO_DEGREES = 180 / Math.PI;
	
	
		function getBevelVec( pt_i, pt_j, pt_k ) {
	
			// Algorithm 2
	
			return getBevelVec2( pt_i, pt_j, pt_k );
	
		}
	
		function getBevelVec1( pt_i, pt_j, pt_k ) {
	
			var anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );
			var angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );
	
			if ( anglea > angleb ) {
	
				angleb += Math.PI * 2;
	
			}
	
			var anglec = ( anglea + angleb ) / 2;
	
	
			//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);
	
			var x = - Math.cos( anglec );
			var y = - Math.sin( anglec );
	
			var vec = new THREE.Vector2( x, y ); //.normalize();
	
			return vec;
	
		}
	
		function getBevelVec2( pt_i, pt_j, pt_k ) {
	
			var a = THREE.ExtrudeGeometry.__v1,
				b = THREE.ExtrudeGeometry.__v2,
				v_hat = THREE.ExtrudeGeometry.__v3,
				w_hat = THREE.ExtrudeGeometry.__v4,
				p = THREE.ExtrudeGeometry.__v5,
				q = THREE.ExtrudeGeometry.__v6,
				v, w,
				v_dot_w_hat, q_sub_p_dot_w_hat,
				s, intersection;
	
			// good reading for line-line intersection
			// http://sputsoft.com/blog/2010/03/line-line-intersection.html
	
			// define a as vector j->i
			// define b as vectot k->i
	
			a.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );
			b.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );
	
			// get unit vectors
	
			v = a.normalize();
			w = b.normalize();
	
			// normals from pt i
	
			v_hat.set( -v.y, v.x );
			w_hat.set( w.y, -w.x );
	
			// pts from i
	
			p.copy( pt_i ).add( v_hat );
			q.copy( pt_i ).add( w_hat );
	
			if ( p.equals( q ) ) {
	
				//console.log("Warning: lines are straight");
				return w_hat.clone();
	
			}
	
			// Points from j, k. helps prevents points cross overover most of the time
	
			p.copy( pt_j ).add( v_hat );
			q.copy( pt_k ).add( w_hat );
	
			v_dot_w_hat = v.dot( w_hat );
			q_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );
	
			// We should not reach these conditions
	
			if ( v_dot_w_hat === 0 ) {
	
				console.log( "Either infinite or no solutions!" );
	
				if ( q_sub_p_dot_w_hat === 0 ) {
	
					console.log( "Its finite solutions." );
	
				} else {
	
					console.log( "Too bad, no solutions." );
	
				}
	
			}
	
			s = q_sub_p_dot_w_hat / v_dot_w_hat;
	
			if ( s < 0 ) {
	
				// in case of emergecy, revert to algorithm 1.
	
				return getBevelVec1( pt_i, pt_j, pt_k );
	
			}
	
			intersection = v.multiplyScalar( s ).add( p );
	
			return intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly
	
		}
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			var pt_i = contour[ i ];
			var pt_j = contour[ j ];
			var pt_k = contour[ k ];
	
			contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
		//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
			//bs = bevelSize * t ; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				//vert = scalePt( contour[ i ], contourCentroid, bs, false );
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
					//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );
	
					v( vert.x, vert.y,  -z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( !extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
				binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);
	
				position2.copy( extrudePts[0] ).add(normal).add(binormal);
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( !extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[s] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( !extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0 ; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ], true );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );
	
				}
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length;  h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( --i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c, isBottom ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			// normal, color, material
			scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
	
			var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );
	
	 		scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
	 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
	 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );
	
	 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
	 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );
	
	 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
	 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
			var ax = geometry.vertices[ indexA ].x,
				ay = geometry.vertices[ indexA ].y,
	
				bx = geometry.vertices[ indexB ].x,
				by = geometry.vertices[ indexB ].y,
	
				cx = geometry.vertices[ indexC ].x,
				cy = geometry.vertices[ indexC ].y;
	
			return [
				new THREE.Vector2( ax, ay ),
				new THREE.Vector2( bx, by ),
				new THREE.Vector2( cx, cy )
			];
	
		},
	
		generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
	
			return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );
	
		},
	
		generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
		                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
		                              contourIndex1, contourIndex2 ) {
	
			var ax = geometry.vertices[ indexA ].x,
				ay = geometry.vertices[ indexA ].y,
				az = geometry.vertices[ indexA ].z,
	
				bx = geometry.vertices[ indexB ].x,
				by = geometry.vertices[ indexB ].y,
				bz = geometry.vertices[ indexB ].z,
	
				cx = geometry.vertices[ indexC ].x,
				cy = geometry.vertices[ indexC ].y,
				cz = geometry.vertices[ indexC ].z,
	
				dx = geometry.vertices[ indexD ].x,
				dy = geometry.vertices[ indexD ].y,
				dz = geometry.vertices[ indexD ].z;
	
			if ( Math.abs( ay - by ) < 0.01 ) {
				return [
					new THREE.Vector2( ax, 1 - az ),
					new THREE.Vector2( bx, 1 - bz ),
					new THREE.Vector2( cx, 1 - cz ),
					new THREE.Vector2( dx, 1 - dz )
				];
			} else {
				return [
					new THREE.Vector2( ay, 1 - az ),
					new THREE.Vector2( by, 1 - bz ),
					new THREE.Vector2( cy, 1 - cz ),
					new THREE.Vector2( dy, 1 - dz )
				];
			}
		}
	};
	
	THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		if ( shapes instanceof Array === false ) shapes = [ shapes ];
	
		this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();
	
		this.addShapeList( shapes, options );
	
		this.computeCentroids();
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		var shapebb = this.shapebb;
	
		//
	
		var i, l, hole, s;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = !THREE.Shape.Utils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.Shape.Utils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );
	
		// Vertices
	
		var contour = vertices;
	
		for ( i = 0, l = holes.length; i < l; i++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
		var cont, clen = contour.length;
	
		for ( i = 0; i < vlen; i++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );
	
		}
	
	};
	
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */
	
	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;
	
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
	
		for ( var i = 0, il = segments; i <= il; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var c = Math.cos( phi ),
				s = Math.sin( phi );
	
			for ( var j = 0, jl = points.length; j < jl; j ++ ) {
	
				var pt = points[ j ];
	
				var vertex = new THREE.Vector3();
	
				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;
	
				this.vertices.push( vertex );
	
			}
	
		}
	
		var np = points.length;
	
		for ( var i = 0, il = segments; i < il; i ++ ) {
	
			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {
	
				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;
	
				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;
	
				this.faces.push( new THREE.Face3( a, b, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
	
			}
	
		}
	
		this.mergeVertices();
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.Geometry.call( this );
	
		this.width = width;
		this.height = height;
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
	
		var ix, iz;
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = this.widthSegments;
		var gridZ = this.heightSegments;
	
		var gridX1 = gridX + 1;
		var gridZ1 = gridZ + 1;
	
		var segment_width = this.width / gridX;
		var segment_height = this.height / gridZ;
	
		var normal = new THREE.Vector3( 0, 0, 1 );
	
		for ( iz = 0; iz < gridZ1; iz ++ ) {
	
			for ( ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
				var y = iz * segment_height - height_half;
	
				this.vertices.push( new THREE.Vector3( x, - y, 0 ) );
	
			}
	
		}
	
		for ( iz = 0; iz < gridZ; iz ++ ) {
	
			for ( ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iz;
				var b = ix + gridX1 * ( iz + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
				var d = ( ix + 1 ) + gridX1 * iz;
	
				var uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );
	
				var face = new THREE.Face3( a, b, d );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
	
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				face = new THREE.Face3( b, c, d );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
	
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeCentroids();
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author Kaleb Murphy
	 */
	
	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;
	
		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	
		for ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring
	
			for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle
	
				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
	
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
			}
	
			radius += radiusStep;
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring
	
			var thetaSegment = i * thetaSegments;
	
			for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle
	
				var segment = o + thetaSegment;
	
				var v1 = segment + i;
				var v2 = segment + thetaSegments + i;
				var v3 = segment + thetaSegments + 1 + i;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);
	
				v1 = segment + i;
				v2 = segment + thetaSegments + 1 + i;
				v3 = segment + 1 + i;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);
	
			}
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.radius = radius = radius || 50;
	
		this.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		this.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
		this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
		this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			for ( x = 0; x <= widthSegments; x ++ ) {
	
				var u = x / widthSegments;
				var v = y / heightSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		for ( y = 0; y < this.heightSegments; y ++ ) {
	
			for ( x = 0; x < this.widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				var n1 = this.vertices[ v1 ].clone().normalize();
				var n2 = this.vertices[ v2 ].clone().normalize();
				var n3 = this.vertices[ v3 ].clone().normalize();
				var n4 = this.vertices[ v4 ].clone().normalize();
	
				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x ].clone();
				var uv4 = uvs[ y + 1 ][ x + 1 ].clone();
	
				if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {
	
					uv1.x = ( uv1.x + uv2.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );
	
				} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {
	
					uv3.x = ( uv3.x + uv4.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
				} else {
	
					this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
					this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
				}
	
			}
	
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */
	
	/*	Usage Examples
	
		// TextGeometry wrapper
	
		var text3d = new TextGeometry( text, options );
	
		// Complete manner
	
		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );
	
	*/
	
	
	THREE.TextGeometry = function ( text, parameters ) {
	
		parameters = parameters || {};
	
		var textShapes = THREE.FontUtils.generateShapes( text, parameters );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		THREE.ExtrudeGeometry.call( this, textShapes, parameters );
	
	};
	
	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		var scope = this;
	
		this.radius = radius || 100;
		this.tube = tube || 40;
		this.radialSegments = radialSegments || 8;
		this.tubularSegments = tubularSegments || 6;
		this.arc = arc || Math.PI * 2;
	
		var center = new THREE.Vector3(), uvs = [], normals = [];
	
		for ( var j = 0; j <= this.radialSegments; j ++ ) {
	
			for ( var i = 0; i <= this.tubularSegments; i ++ ) {
	
				var u = i / this.tubularSegments * this.arc;
				var v = j / this.radialSegments * Math.PI * 2;
	
				center.x = this.radius * Math.cos( u );
				center.y = this.radius * Math.sin( u );
	
				var vertex = new THREE.Vector3();
				vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = this.tube * Math.sin( v );
	
				this.vertices.push( vertex );
	
				uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );
	
			}
	
		}
	
	
		for ( var j = 1; j <= this.radialSegments; j ++ ) {
	
			for ( var i = 1; i <= this.tubularSegments; i ++ ) {
	
				var a = ( this.tubularSegments + 1 ) * j + i - 1;
				var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( this.tubularSegments + 1 ) * j + i;
	
				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );
	
				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
	
			}
	
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		var scope = this;
	
		this.radius = radius || 100;
		this.tube = tube || 40;
		this.radialSegments = radialSegments || 64;
		this.tubularSegments = tubularSegments || 8;
		this.p = p || 2;
		this.q = q || 3;
		this.heightScale = heightScale || 1;
		this.grid = new Array( this.radialSegments );
	
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();
	
		for ( var i = 0; i < this.radialSegments; ++ i ) {
	
			this.grid[ i ] = new Array( this.tubularSegments );
			var u = i / this.radialSegments * 2 * this.p * Math.PI;
			var p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );
			var p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );
	
			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();
	
			for ( var j = 0; j < this.tubularSegments; ++ j ) {
	
				var v = j / this.tubularSegments * 2 * Math.PI;
				var cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = this.tube * Math.sin( v );
	
				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;
	
				this.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;
	
			}
	
		}
	
		for ( var i = 0; i < this.radialSegments; ++ i ) {
	
			for ( var j = 0; j < this.tubularSegments; ++ j ) {
	
				var ip = ( i + 1 ) % this.radialSegments;
				var jp = ( j + 1 ) % this.tubularSegments;
	
				var a = this.grid[ i ][ j ];
				var b = this.grid[ ip ][ j ];
				var c = this.grid[ ip ][ jp ];
				var d = this.grid[ i ][ jp ];
	
				var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
				var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
		function getPos( u, in_q, in_p, radius, heightScale ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );
	
			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {
	
		THREE.Geometry.call( this );
	
		this.path = path;
		this.segments = segments || 64;
		this.radius = radius || 1;
		this.radialSegments = radialSegments || 8;
		this.closed = closed || false;
	
		this.grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = this.segments + 1,
	
			x, y, z,
			tx, ty, tz,
			u, v,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
	
		// consruct the grid
	
		for ( i = 0; i < numpoints; i++ ) {
	
			this.grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			for ( j = 0; j < this.radialSegments; j++ ) {
	
				v = j / this.radialSegments * 2 * Math.PI;
	
				cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = this.radius * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < this.segments; i++ ) {
	
			for ( j = 0; j < this.radialSegments; j++ ) {
	
				ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
				jp = (j + 1) % this.radialSegments;
	
				a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = this.grid[ ip ][ j ];
				c = this.grid[ ip ][ jp ];
				d = this.grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / this.segments, j / this.radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );
				uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
	
		var	tangent = new THREE.Vector3(),
			normal = new THREE.Vector3(),
			binormal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,
	
			tx, ty, tz,
			i, u, v;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
	
		function initialNormal3() {
			// select an initial normal vector perpenicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
				smallest = tx;
				normal.set( 1, 0, 0 );
			}
	
			if ( ty <= smallest ) {
				smallest = ty;
				normal.set( 0, 1, 0 );
			}
	
			if ( tz <= smallest ) {
				normal.set( 0, 0, 1 );
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i++ ) {
	
			normals[ i ] = normals[ i-1 ].clone();
	
			binormals[ i ] = binormals[ i-1 ].clone();
	
			vec.crossVectors( tangents[ i-1 ], tangents[ i ] );
	
			if ( vec.length() > epsilon ) {
	
				vec.normalize();
	
				theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {
	
				theta = -theta;
	
			}
	
			for ( i = 1; i < numpoints; i++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	};
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
			prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );
	
		}
	
		var midpoints = [], p = this.vertices;
	
		var f = [];
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var v1 = p[ faces[ i ][ 0 ] ];
			var v2 = p[ faces[ i ][ 1 ] ];
			var v3 = p[ faces[ i ][ 2 ] ];
	
			f[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
	
		}
	
		for ( var i = 0, l = f.length; i < l; i ++ ) {
	
			subdivide(f[ i ], detail);
	
		}
	
	
		// Handle case when face straddles the seam
	
		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
	
			var uvs = this.faceVertexUvs[ 0 ][ i ];
	
			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;
	
			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );
	
			if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary
	
				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;
	
			}
	
		}
	
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Merge vertices
	
		this.mergeVertices();
	
		this.computeCentroids();
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3 ) {
	
			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
			that.faces.push( face );
	
			var azi = azimuth( face.centroid );
	
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );
	
		}
	
	
		// Analytically subdivide a face to the required detail level.
	
		function subdivide(face, detail ) {
	
			var cols = Math.pow(2, detail);
			var cells = Math.pow(4, detail);
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];
	
			// Construct all of the vertices for this subdivision.
	
			for ( var i = 0 ; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;
	
				for ( var j = 0; j <= rows; j ++) {
	
					if ( j == 0 && i == cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );
	
					}
	
				}
	
			}
	
			// Construct all of the faces.
	
			for ( var i = 0; i < cols ; i ++ ) {
	
				for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 == 0 ) {
	
						make(
							v[ i ][ k + 1],
							v[ i + 1 ][ k ],
							v[ i ][ k ]
						);
	
					} else {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1][ k + 1],
							v[ i + 1 ][ k ]
						);
	
					}
	
				}
	
			}
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, -vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();
	
		}
	
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		this.radius = radius;
		this.detail = detail;
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
			[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
			[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
		];
	
		var faces = [
			[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
			[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
			[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
			[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
		];
	
		var faces = [
			[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
		];
	
		var faces = [
			[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks ) {
	
		THREE.Geometry.call( this );
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		var i, il, j, p;
		var u, v;
	
		var stackCount = stacks + 1;
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j + 1;
				d = (i + 1) * sliceCount + j;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
	
				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );
	
				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		size = size || 1;
	
		var geometry = new THREE.Geometry();
	
		geometry.vertices.push(
			new THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),
			new THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),
			new THREE.Vector3(), new THREE.Vector3( 0, 0, size )
		);
	
		geometry.colors.push(
			new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
			new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
			new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
		);
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  hex - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	THREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {
	
		// dir is assumed to be normalized
	
		THREE.Object3D.call( this );
	
		if ( hex === undefined ) hex = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.position = origin;
	
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
		lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );
	
		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );
	
		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
	
		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );
	
		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );
	
	};
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.ArrowHelper.prototype.setDirection = function () {
	
		var axis = new THREE.Vector3();
		var radians;
	
		return function ( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}();
	
	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.line.scale.set( 1, length, 1 );
		this.line.updateMatrix();
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( hex ) {
	
		this.line.material.color.setHex( hex );
		this.cone.material.color.setHex( hex );
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BoxHelper = function ( object ) {
	
		//   5____4
		// 1/___0/|
		// | 6__|_7
		// 2/___3/
	
		var vertices = [
			new THREE.Vector3(   1,   1,   1 ),
			new THREE.Vector3( - 1,   1,   1 ),
			new THREE.Vector3( - 1, - 1,   1 ),
			new THREE.Vector3(   1, - 1,   1 ),
	
			new THREE.Vector3(   1,   1, - 1 ),
			new THREE.Vector3( - 1,   1, - 1 ),
			new THREE.Vector3( - 1, - 1, - 1 ),
			new THREE.Vector3(   1, - 1, - 1 )
		];
	
		this.vertices = vertices;
	
		// TODO: Wouldn't be nice if Line had .segments?
	
		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			vertices[ 0 ], vertices[ 1 ],
			vertices[ 1 ], vertices[ 2 ],
			vertices[ 2 ], vertices[ 3 ],
			vertices[ 3 ], vertices[ 0 ],
	
			vertices[ 4 ], vertices[ 5 ],
			vertices[ 5 ], vertices[ 6 ],
			vertices[ 6 ], vertices[ 7 ],
			vertices[ 7 ], vertices[ 4 ],
	
			vertices[ 0 ], vertices[ 4 ],
			vertices[ 1 ], vertices[ 5 ],
			vertices[ 2 ], vertices[ 6 ],
			vertices[ 3 ], vertices[ 7 ]
		);
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );
	
		if ( object !== undefined ) {
	
			this.update( object );
	
		}
	
	};
	
	THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.BoxHelper.prototype.update = function ( object ) {
	
		var geometry = object.geometry;
	
		if ( geometry.boundingBox === null ) {
	
			geometry.computeBoundingBox();
	
		}
	
		var min = geometry.boundingBox.min;
		var max = geometry.boundingBox.max;
		var vertices = this.vertices;
	
		vertices[ 0 ].set( max.x, max.y, max.z );
		vertices[ 1 ].set( min.x, max.y, max.z );
		vertices[ 2 ].set( min.x, min.y, max.z );
		vertices[ 3 ].set( max.x, min.y, max.z );
		vertices[ 4 ].set( max.x, max.y, min.z );
		vertices[ 5 ].set( min.x, max.y, min.z );
		vertices[ 6 ].set( min.x, min.y, min.z );
		vertices[ 7 ].set( max.x, min.y, min.z );
	
		this.geometry.computeBoundingSphere();
		this.geometry.verticesNeedUpdate = true;
	
		this.matrixAutoUpdate = false;
		this.matrixWorld = object.matrixWorld;
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	// a helper to show the world-axis-aligned bounding box for an object
	
	THREE.BoundingBoxHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0x888888;
	
		this.object = object;
	
		this.box = new THREE.Box3();
	
		THREE.Mesh.call( this, new THREE.CubeGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );
	
	};
	
	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.BoundingBoxHelper.prototype.update = function () {
	
		this.box.setFromObject( this.object );
	
		this.box.size( this.scale );
	
		this.box.center( this.position );
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	
		var pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( geometry.vertices.length - 1 );
	
		}
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
		this.camera = camera;
		this.matrixWorld = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.CameraHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();
		var projector = new THREE.Projector();
	
		return function () {
	
			var scope = this;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( "c", 0, 0, -1 );
			setPoint( "t", 0, 0,  1 );
	
			// near
	
			setPoint( "n1", -w, -h, -1 );
			setPoint( "n2",  w, -h, -1 );
			setPoint( "n3", -w,  h, -1 );
			setPoint( "n4",  w,  h, -1 );
	
			// far
	
			setPoint( "f1", -w, -h, 1 );
			setPoint( "f2",  w, -h, 1 );
			setPoint( "f3", -w,  h, 1 );
			setPoint( "f4",  w,  h, 1 );
	
			// up
	
			setPoint( "u1",  w * 0.7, h * 1.1, -1 );
			setPoint( "u2", -w * 0.7, h * 1.1, -1 );
			setPoint( "u3",        0, h * 2,   -1 );
	
			// cross
	
			setPoint( "cf1", -w,  0, 1 );
			setPoint( "cf2",  w,  0, 1 );
			setPoint( "cf3",  0, -h, 1 );
			setPoint( "cf4",  0,  h, 1 );
	
			setPoint( "cn1", -w,  0, -1 );
			setPoint( "cn2",  w,  0, -1 );
			setPoint( "cn3",  0, -h, -1 );
			setPoint( "cn4",  0,  h, -1 );
	
			function setPoint( point, x, y, z ) {
	
				vector.set( x, y, z );
				projector.unprojectVector( vector, camera );
	
				var points = scope.pointMap[ point ];
	
				if ( points !== undefined ) {
	
					for ( var i = 0, il = points.length; i < il; i ++ ) {
	
						scope.geometry.vertices[ points[ i ] ].copy( vector );
	
					}
	
				}
	
			}
	
			this.geometry.verticesNeedUpdate = true;
	
		};
	
	}();
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.DirectionalLightHelper = function ( light, size ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrixWorld = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		size = size || 1;
		var geometry = new THREE.PlaneGeometry( size, size );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.lightPlane = new THREE.Mesh( geometry, material );
		this.add( this.lightPlane );
	
		geometry = new THREE.Geometry();
		geometry.vertices.push( new THREE.Vector3() );
		geometry.vertices.push( new THREE.Vector3() );
	
		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );
	
		this.update();
	
	};
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.DirectionalLightHelper.prototype.dispose = function () {
		
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	};
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();
	
		return function () {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );
	
		}
	
	}();
	
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.EdgesHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };
	
		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();
	
		var geometry2 = object.geometry.clone();
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
		var numEdges = 0;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );
	
				var key = edge.toString();
	
				if ( hash[ key ] === undefined ) {
	
					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
					numEdges ++;
	
				} else {
	
					hash[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );
	
		var coords = geometry.attributes.position.array;
	
		var index = 0;
	
		for ( var key in hash ) {
	
			var h = hash[ key ];
	
			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK
	
				var vertex = vertices[ h.vert1 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;
	
				vertex = vertices[ h.vert2 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
		this.matrixWorld = object.matrixWorld;
	
	};
	
	THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		var geometry = new THREE.Geometry();
	
		var faces = this.object.geometry.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
	
		this.normalMatrix = new THREE.Matrix3();
	
		this.update();
	
	};
	
	THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.FaceNormalsHelper.prototype.update = ( function ( object ) {
	
		var v1 = new THREE.Vector3();
	
		return function ( object ) {
	
			this.object.updateMatrixWorld( true );
	
			this.normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var vertices = this.geometry.vertices;
	
			var faces = this.object.geometry.faces;
	
			var worldMatrix = this.object.matrixWorld;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				v1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );
	
				var idx = 2 * i;
	
				vertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );
	
				vertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );
	
			}
	
			this.geometry.verticesNeedUpdate = true;
	
			return this;
	
		}
	
	}());
	
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GridHelper = function ( size, step ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );
	
		for ( var i = - size; i <= size; i += step ) {
	
			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);
	
			var color = i === 0 ? this.color1 : this.color2;
	
			geometry.colors.push( color, color, color, color );
	
		}
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
	};
	
	THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {
	
		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );
	
		this.geometry.colorsNeedUpdate = true;
	
	}
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrixWorld = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.colors = [ new THREE.Color(), new THREE.Color() ];
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
	
		for ( var i = 0, il = 8; i < il; i ++ ) {
	
			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
		}
	
		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );
	
		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );
	
		this.update();
	
	};
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.HemisphereLightHelper.prototype.dispose = function () {
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	};
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
	
		return function () {
	
			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;
	
		}
	
	}();
	
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		THREE.Mesh.call( this, geometry, material );
	
		this.matrixWorld = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	};
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.PointLightHelper.prototype.dispose = function () {
		
		this.geometry.dispose();
		this.material.dispose();
	};
	
	THREE.PointLightHelper.prototype.update = function () {
	
		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.SpotLightHelper = function ( light ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrixWorld = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );
	
		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
	
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		
		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	};
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.SpotLightHelper.prototype.dispose = function () {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();
	
		return function () {
	
			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector2.sub( vector ) );
	
			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		};
	
	}();
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		var geometry = new THREE.Geometry();
	
		var vertices = object.geometry.vertices;
	
		var faces = object.geometry.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
	
		this.normalMatrix = new THREE.Matrix3();
	
		this.update();
	
	};
	
	THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {
	
		var v1 = new THREE.Vector3();
	
		return function( object ) {
	
			var keys = [ 'a', 'b', 'c', 'd' ];
	
			this.object.updateMatrixWorld( true );
	
			this.normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var vertices = this.geometry.vertices;
	
			var verts = this.object.geometry.vertices;
	
			var faces = this.object.geometry.faces;
	
			var worldMatrix = this.object.matrixWorld;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];
	
					var normal = face.vertexNormals[ j ];
	
					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );
	
					v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );
	
					v1.add( vertices[ idx ] );
					idx = idx + 1;
	
					vertices[ idx ].copy( v1 );
					idx = idx + 1;
	
				}
	
			}
	
			this.geometry.verticesNeedUpdate = true;
	
			return this;
	
		}
	
	}());
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0x0000ff;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		var geometry = new THREE.Geometry();
	
		var vertices = object.geometry.vertices;
	
		var faces = object.geometry.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {
	
		var v1 = new THREE.Vector3();
	
		return function( object ) {
	
			var keys = [ 'a', 'b', 'c', 'd' ];
	
			this.object.updateMatrixWorld( true );
	
			var vertices = this.geometry.vertices;
	
			var verts = this.object.geometry.vertices;
	
			var faces = this.object.geometry.faces;
	
			var worldMatrix = this.object.matrixWorld;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {
	
					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];
	
					var tangent = face.vertexTangents[ j ];
	
					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );
	
					v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );
	
					v1.add( vertices[ idx ] );
					idx = idx + 1;
	
					vertices[ idx ].copy( v1 );
					idx = idx + 1;
	
				}
	
			}
	
			this.geometry.verticesNeedUpdate = true;
	
			return this;
	
		}
	
	}());
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };
	
		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();
	
		if ( object.geometry instanceof THREE.Geometry ) {
	
			var vertices = object.geometry.vertices;
			var faces = object.geometry.faces;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;
	
					}
	
				}
	
			}
	
			geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );
	
			var coords = geometry.attributes.position.array;
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var vertex = vertices[ edges [ 2 * i + j] ];
	
					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;
	
				}
	
			}
	
		} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry
	
			var vertices = object.geometry.attributes.position.array;
			var indices = object.geometry.attributes.index.array;
			var offsets = object.geometry.offsets;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );
	
			for ( var o = 0, ol = offsets.length; o < ol; ++ o ) {
	
				var start = offsets[ o ].start;
				var count = offsets[ o ].count;
				var index = offsets[ o ].index;
	
				for ( var i = start, il = start + count; i < il; i += 3 ) {
	
					for ( var j = 0; j < 3; j ++ ) {
	
						edge[ 0 ] = index + indices[ i + j ];
						edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );
	
						var key = edge.toString();
	
						if ( hash[ key ] === undefined ) {
	
							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;
	
						}
	
					}
	
				}
	
			}
	
			geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );
	
			var coords = geometry.attributes.position.array;
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var index = 6 * i + 3 * j;
					var index2 = 3 * edges[ 2 * i + j];
					coords[ index + 0 ] = vertices[ index2 ];
					coords[ index + 1 ] = vertices[ index2 + 1 ];
					coords[ index + 2 ] = vertices[ index2 + 2 ];
	
				}
	
			}
	
		} else if ( object.geometry instanceof THREE.BufferGeometry	) { // non-indexed BufferGeometry
	
			var vertices = object.geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;
	
			geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );
	
			var coords = geometry.attributes.position.array;
	
			for ( var i = 0, l = numTris; i < l; i ++ ) {
	
				for ( var j = 0; j < 3; j ++ ) {
	
					var index = 18 * i + 6 * j;
	
					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];
	
					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];
	
				}
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
		this.matrixWorld = object.matrixWorld;
	
	};
	
	THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function () {
	
		THREE.Object3D.call( this );
	
		this.render = function ( renderCallback ) { };
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	
	
	/*
	 * Add: adds another flare
	 */
	
	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {
	
		if( size === undefined ) size = -1;
		if( distance === undefined ) distance = 0;
		if( opacity === undefined ) opacity = 1;
		if( color === undefined ) color = new THREE.Color( 0xffffff );
		if( blending === undefined ) blending = THREE.NormalBlending;
	
		distance = Math.min( distance, Math.max( 0, distance ) );
	
		this.lensFlares.push( { texture: texture, 			// THREE.Texture
			                    size: size, 				// size in pixels (-1 = use texture.width)
			                    distance: distance, 		// distance (0-1) from light source (0=at light source)
			                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
			                    scale: 1, 					// scale
			                    rotation: 1, 				// rotation
			                    opacity: opacity,			// opacity
								color: color,				// color
			                    blending: blending } );		// blending
	
	};
	
	
	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */
	
	THREE.LensFlare.prototype.updateLensFlares = function () {
	
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = -this.positionScreen.x * 2;
		var vecY = -this.positionScreen.y * 2;
	
		for( f = 0; f < fl; f ++ ) {
	
			flare = this.lensFlares[ f ];
	
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
	
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
		}
	
	};
	
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			startFrame: start,
			endFrame: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)(\d+)/;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
				var num = chunks[ 2 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = -1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = -1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			console.warn( "animation[" + name + "] undefined" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= -1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
		}
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function () {
	
		var _gl, _renderer, _precision, _lensFlare = {};
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			_precision = renderer.getPrecision();
	
			_lensFlare.vertices = new Float32Array( 8 + 8 );
			_lensFlare.faces = new Uint16Array( 6 );
	
			var i = 0;
			_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
			_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.
	
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;
	
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
	
			_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
			_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;
	
			i = 0;
			_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
			_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;
	
			// buffers
	
			_lensFlare.vertexBuffer     = _gl.createBuffer();
			_lensFlare.elementBuffer    = _gl.createBuffer();
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );
	
			// textures
	
			_lensFlare.tempTexture      = _gl.createTexture();
			_lensFlare.occlusionTexture = _gl.createTexture();
	
			_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
			_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );
	
			_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
			_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );
	
			if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {
	
				_lensFlare.hasVertexTexture = false;
				_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );
	
			} else {
	
				_lensFlare.hasVertexTexture = true;
				_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );
	
			}
	
			_lensFlare.attributes = {};
			_lensFlare.uniforms = {};
	
			_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
			_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );
	
			_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
			_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
			_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
			_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
			_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
			_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
			_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
			_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );
	
		};
	
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 *         Then _lensFlare.update_lensFlares() is called to re-position and
		 *         update transparency of flares. Then they are rendered.
		 *
		 */
	
		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {
	
			var flares = scene.__webglFlares,
				nFlares = flares.length;
	
			if ( ! nFlares ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;
	
			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			var uniforms = _lensFlare.uniforms,
				attributes = _lensFlare.attributes;
	
			// set _lensFlare program and reset blending
	
			_gl.useProgram( _lensFlare.program );
	
			_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
			_gl.enableVertexAttribArray( _lensFlare.attributes.uv );
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/unforms
	
			_gl.uniform1i( uniforms.occlusionMap, 0 );
			_gl.uniform1i( uniforms.map, 1 );
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
			_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
	
			_gl.disable( _gl.CULL_FACE );
			_gl.depthMask( false );
	
			var i, j, jl, flare, sprite;
	
			for ( i = 0; i < nFlares; i ++ ) {
	
				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition )
	
				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
	
				// screen cull
	
				if ( _lensFlare.hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {
	
					// save current RGB to temp texture
	
					_gl.activeTexture( _gl.TEXTURE1 );
					_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
					_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// render pink quad
	
					_gl.uniform1i( uniforms.renderType, 0 );
					_gl.uniform2f( uniforms.scale, scale.x, scale.y );
					_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					_gl.disable( _gl.BLEND );
					_gl.enable( _gl.DEPTH_TEST );
	
					_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					_gl.activeTexture( _gl.TEXTURE0 );
					_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
					_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// restore graphics
	
					_gl.uniform1i( uniforms.renderType, 1 );
					_gl.disable( _gl.DEPTH_TEST );
	
					_gl.activeTexture( _gl.TEXTURE1 );
					_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
					_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition )
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					_gl.uniform1i( uniforms.renderType, 2 );
					_gl.enable( _gl.BLEND );
	
					for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewportHeight;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							_gl.uniform2f( uniforms.scale, scale.x, scale.y );
							_gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							_gl.uniform1f( uniforms.opacity, sprite.opacity );
							_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							_renderer.setTexture( sprite.texture, 1 );
	
							_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			_gl.enable( _gl.CULL_FACE );
			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthMask( true );
	
		};
	
		function createProgram ( shader, precision ) {
	
			var program = _gl.createProgram();
	
			var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
			var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
	
			var prefix = "precision " + precision + " float;\n";
	
			_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			_gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			_gl.compileShader( fragmentShader );
			_gl.compileShader( vertexShader );
	
			_gl.attachShader( program, fragmentShader );
			_gl.attachShader( program, vertexShader );
	
			_gl.linkProgram( program );
	
			return program;
	
		};
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ShadowMapPlugin = function () {
	
		var _gl,
		_renderer,
		_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,
	
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),
	
		_matrixPosition = new THREE.Vector3();
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			var depthShader = THREE.ShaderLib[ "depthRGBA" ];
			var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
			_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
			_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
			_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
			_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );
	
			_depthMaterial._shadowPass = true;
			_depthMaterialMorph._shadowPass = true;
			_depthMaterialSkin._shadowPass = true;
			_depthMaterialMorphSkin._shadowPass = true;
	
		};
	
		this.render = function ( scene, camera ) {
	
			if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;
	
			this.update( scene, camera );
	
		};
	
		this.update = function ( scene, camera ) {
	
			var i, il, j, jl, n,
	
			shadowMap, shadowMatrix, shadowCamera,
			program, buffer, material,
			webglObject, object, light,
			renderList,
	
			lights = [],
			k = 0,
	
			fog = null;
	
			// set GL state for depth map
	
			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );
	
			_gl.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
	
			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.FRONT );
	
			} else {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.setDepthTest( true );
	
			// preprocess lights
			// 	- skip lights that are not casting shadows
			//	- create virtual lights for cascaded shadow maps
	
			for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {
	
				light = scene.__lights[ i ];
	
				if ( ! light.castShadow ) continue;
	
				if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {
	
					for ( n = 0; n < light.shadowCascadeCount; n ++ ) {
	
						var virtualLight;
	
						if ( ! light.shadowCascadeArray[ n ] ) {
	
							virtualLight = createVirtualLight( light, n );
							virtualLight.originalCamera = camera;
	
							var gyro = new THREE.Gyroscope();
							gyro.position = light.shadowCascadeOffset;
	
							gyro.add( virtualLight );
							gyro.add( virtualLight.target );
	
							camera.add( gyro );
	
							light.shadowCascadeArray[ n ] = virtualLight;
	
							console.log( "Created virtualLight", virtualLight );
	
						} else {
	
							virtualLight = light.shadowCascadeArray[ n ];
	
						}
	
						updateVirtualLight( light, n );
	
						lights[ k ] = virtualLight;
						k ++;
	
					}
	
				} else {
	
					lights[ k ] = light;
					k ++;
	
				}
	
			}
	
			// render depth map
	
			for ( i = 0, il = lights.length; i < il; i ++ ) {
	
				light = lights[ i ];
	
				if ( ! light.shadowMap ) {
	
					var shadowFilter = THREE.LinearFilter;
	
					if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {
	
						shadowFilter = THREE.NearestFilter;
	
					}
	
					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };
	
					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );
	
					light.shadowMatrix = new THREE.Matrix4();
	
				}
	
				if ( ! light.shadowCamera ) {
	
					if ( light instanceof THREE.SpotLight ) {
	
						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );
	
					} else if ( light instanceof THREE.DirectionalLight ) {
	
						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );
	
					} else {
	
						console.error( "Unsupported light type for shadow" );
						continue;
	
					}
	
					scene.add( light.shadowCamera );
	
					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
				}
	
				if ( light.shadowCameraVisible && ! light.cameraHelper ) {
	
					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					light.shadowCamera.add( light.cameraHelper );
	
				}
	
				if ( light.isVirtual && virtualLight.originalCamera == camera ) {
	
					updateShadowCamera( camera, light );
	
				}
	
				shadowMap = light.shadowMap;
				shadowMatrix = light.shadowMatrix;
				shadowCamera = light.shadowCamera;
	
				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();
	
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();
	
				// compute shadow matrix
	
				shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
								  0.0, 0.5, 0.0, 0.5,
								  0.0, 0.0, 0.5, 0.5,
								  0.0, 0.0, 0.0, 1.0 );
	
				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
				// update camera matrices and frustum
	
				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				// render shadow map
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// set object matrices & frustum culling
	
				renderList = scene.__webglObjects;
	
				for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
					webglObject = renderList[ j ];
					object = webglObject.object;
	
					webglObject.render = false;
	
					if ( object.visible && object.castShadow ) {
	
						if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {
	
							object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
							webglObject.render = true;
	
						}
	
					}
	
				}
	
				// render regular objects
	
				var objectMaterial, useMorphing, useSkinning;
	
				for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
					webglObject = renderList[ j ];
	
					if ( webglObject.render ) {
	
						object = webglObject.object;
						buffer = webglObject.buffer;
	
						// culling is overriden globally for all objects
						// while rendering depth map
	
						// need to deal with MeshFaceMaterial somehow
						// in that case just use the first of material.materials for now
						// (proper solution would require to break objects by materials
						//  similarly to regular rendering and then set corresponding
						//  depth materials per each chunk instead of just once per object)
	
						objectMaterial = getObjectMaterial( object );
	
						useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
						useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
	
						if ( object.customDepthMaterial ) {
	
							material = object.customDepthMaterial;
	
						} else if ( useSkinning ) {
	
							material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
	
						} else if ( useMorphing ) {
	
							material = _depthMaterialMorph;
	
						} else {
	
							material = _depthMaterial;
	
						}
	
						if ( buffer instanceof THREE.BufferGeometry ) {
	
							_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );
	
						} else {
	
							_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );
	
						}
	
					}
	
				}
	
				// set matrices and render immediate objects
	
				renderList = scene.__webglObjectsImmediate;
	
				for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
					webglObject = renderList[ j ];
					object = webglObject.object;
	
					if ( object.visible && object.castShadow ) {
	
						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
						_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );
	
					}
	
				}
	
			}
	
			// restore GL state
	
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
	
			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );
	
			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
		};
	
		function createVirtualLight( light, cascade ) {
	
			var virtualLight = new THREE.DirectionalLight();
	
			virtualLight.isVirtual = true;
	
			virtualLight.onlyShadow = true;
			virtualLight.castShadow = true;
	
			virtualLight.shadowCameraNear = light.shadowCameraNear;
			virtualLight.shadowCameraFar = light.shadowCameraFar;
	
			virtualLight.shadowCameraLeft = light.shadowCameraLeft;
			virtualLight.shadowCameraRight = light.shadowCameraRight;
			virtualLight.shadowCameraBottom = light.shadowCameraBottom;
			virtualLight.shadowCameraTop = light.shadowCameraTop;
	
			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
	
			virtualLight.shadowDarkness = light.shadowDarkness;
	
			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
			virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
			virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];
	
			virtualLight.pointsWorld = [];
			virtualLight.pointsFrustum = [];
	
			var pointsWorld = virtualLight.pointsWorld,
				pointsFrustum = virtualLight.pointsFrustum;
	
			for ( var i = 0; i < 8; i ++ ) {
	
				pointsWorld[ i ] = new THREE.Vector3();
				pointsFrustum[ i ] = new THREE.Vector3();
	
			}
	
			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];
	
			pointsFrustum[ 0 ].set( -1, -1, nearZ );
			pointsFrustum[ 1 ].set(  1, -1, nearZ );
			pointsFrustum[ 2 ].set( -1,  1, nearZ );
			pointsFrustum[ 3 ].set(  1,  1, nearZ );
	
			pointsFrustum[ 4 ].set( -1, -1, farZ );
			pointsFrustum[ 5 ].set(  1, -1, farZ );
			pointsFrustum[ 6 ].set( -1,  1, farZ );
			pointsFrustum[ 7 ].set(  1,  1, farZ );
	
			return virtualLight;
	
		}
	
		// Synchronize virtual light with the original light
	
		function updateVirtualLight( light, cascade ) {
	
			var virtualLight = light.shadowCascadeArray[ cascade ];
	
			virtualLight.position.copy( light.position );
			virtualLight.target.position.copy( light.target.position );
			virtualLight.lookAt( virtualLight.target );
	
			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
			virtualLight.shadowDarkness = light.shadowDarkness;
	
			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
	
			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];
	
			var pointsFrustum = virtualLight.pointsFrustum;
	
			pointsFrustum[ 0 ].z = nearZ;
			pointsFrustum[ 1 ].z = nearZ;
			pointsFrustum[ 2 ].z = nearZ;
			pointsFrustum[ 3 ].z = nearZ;
	
			pointsFrustum[ 4 ].z = farZ;
			pointsFrustum[ 5 ].z = farZ;
			pointsFrustum[ 6 ].z = farZ;
			pointsFrustum[ 7 ].z = farZ;
	
		}
	
		// Fit shadow camera's ortho frustum to camera frustum
	
		function updateShadowCamera( camera, light ) {
	
			var shadowCamera = light.shadowCamera,
				pointsFrustum = light.pointsFrustum,
				pointsWorld = light.pointsWorld;
	
			_min.set( Infinity, Infinity, Infinity );
			_max.set( -Infinity, -Infinity, -Infinity );
	
			for ( var i = 0; i < 8; i ++ ) {
	
				var p = pointsWorld[ i ];
	
				p.copy( pointsFrustum[ i ] );
				THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );
	
				p.applyMatrix4( shadowCamera.matrixWorldInverse );
	
				if ( p.x < _min.x ) _min.x = p.x;
				if ( p.x > _max.x ) _max.x = p.x;
	
				if ( p.y < _min.y ) _min.y = p.y;
				if ( p.y > _max.y ) _max.y = p.y;
	
				if ( p.z < _min.z ) _min.z = p.z;
				if ( p.z > _max.z ) _max.z = p.z;
	
			}
	
			shadowCamera.left = _min.x;
			shadowCamera.right = _max.x;
			shadowCamera.top = _max.y;
			shadowCamera.bottom = _min.y;
	
			// can't really fit near/far
			//shadowCamera.near = _min.z;
			//shadowCamera.far = _max.z;
	
			shadowCamera.updateProjectionMatrix();
	
		}
	
		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use for shadow maps
	
		function getObjectMaterial( object ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;
	
		};
	
	};
	
	THREE.ShadowMapPlugin.__projector = new THREE.Projector();
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function () {
	
		var _gl, _renderer, _texture;
	
		var vertices, faces, vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			vertices = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 
				  0.5, - 0.5, 1, 0,
				  0.5,   0.5, 1, 1,
				- 0.5,   0.5, 0, 1
			] );
	
			faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			vertexBuffer  = _gl.createBuffer();
			elementBuffer = _gl.createBuffer();
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );
	
			program = createProgram();
	
			attributes = {
				position:			_gl.getAttribLocation ( program, 'position' ),
				uv:					_gl.getAttribLocation ( program, 'uv' )
			};
	
			uniforms = {
				uvOffset:			_gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			_gl.getUniformLocation( program, 'uvScale' ),
	
				rotation:			_gl.getUniformLocation( program, 'rotation' ),
				scale:				_gl.getUniformLocation( program, 'scale' ),
	
				color:				_gl.getUniformLocation( program, 'color' ),
				map:				_gl.getUniformLocation( program, 'map' ),
				opacity:			_gl.getUniformLocation( program, 'opacity' ),
	
				modelViewMatrix: 	_gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	_gl.getUniformLocation( program, 'projectionMatrix' ),
	
				fogType:			_gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			_gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			_gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				_gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			_gl.getUniformLocation( program, 'fogColor' ),
	
				alphaTest:			_gl.getUniformLocation( program, 'alphaTest' )
			};
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;
	
			var context = canvas.getContext( '2d' );
			context.fillStyle = '#ffffff';
			context.fillRect( 0, 0, canvas.width, canvas.height );
	
			_texture = new THREE.Texture( canvas );
			_texture.needsUpdate = true;
	
		};
	
		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {
	
			var sprites = scene.__webglSprites,
				nSprites = sprites.length;
	
			if ( ! nSprites ) return;
	
			// setup gl
	
			_gl.useProgram( program );
	
			_gl.enableVertexAttribArray( attributes.position );
			_gl.enableVertexAttribArray( attributes.uv );
	
			_gl.disable( _gl.CULL_FACE );
			_gl.enable( _gl.BLEND );
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
			_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			_gl.activeTexture( _gl.TEXTURE0 );
			_gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					_gl.uniform1f( uniforms.fogNear, fog.near );
					_gl.uniform1f( uniforms.fogFar, fog.far );
	
					_gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					_gl.uniform1f( uniforms.fogDensity, fog.density );
	
					_gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				_gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			var i, sprite, material, fogType, scale = [];
	
			for( i = 0; i < nSprites; i ++ ) {
	
				sprite = sprites[ i ];
				material = sprite.material;
	
				if ( sprite.visible === false ) continue;
	
				sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			for( i = 0; i < nSprites; i ++ ) {
	
				sprite = sprites[ i ];
	
				if ( sprite.visible === false ) continue;
	
				material = sprite.material;
	
				_gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );
	
				scale[ 0 ] = sprite.scale.x;
				scale[ 1 ] = sprite.scale.y;
	
				if ( scene.fog && material.fog ) {
	
					fogType = sceneFogType;
	
				} else {
	
					fogType = 0;
	
				}
	
				if ( oldFogType !== fogType ) {
	
					_gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;
	
				}
	
				if ( material.map !== null ) {
	
					_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
				} else {
	
					_gl.uniform2f( uniforms.uvOffset, 0, 0 );
					_gl.uniform2f( uniforms.uvScale, 1, 1 );
	
				}
	
				_gl.uniform1f( uniforms.opacity, material.opacity );
				_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
				_gl.uniform1f( uniforms.rotation, material.rotation );
				_gl.uniform2fv( uniforms.scale, scale );
	
				_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				_renderer.setDepthTest( material.depthTest );
				_renderer.setDepthWrite( material.depthWrite );
	
				if ( material.map && material.map.image && material.map.image.width ) {
	
					_renderer.setTexture( material.map, 0 );
	
				} else {
	
					_renderer.setTexture( _texture, 0 );
	
				}
	
				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
			}
	
			// restore gl
	
			_gl.enable( _gl.CULL_FACE );
	
		};
	
		function createProgram () {
	
			var program = _gl.createProgram();
	
			var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
			var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
	
			_gl.shaderSource( vertexShader, [
	
				'precision ' + _renderer.getPrecision() + ' float;',
	
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',
	
				'attribute vec2 position;',
				'attribute vec2 uv;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vUV = uvOffset + uv * uvScale;',
	
					'vec2 alignedPosition = position * scale;',
	
					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
					'vec4 finalPosition;',
	
					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',
	
					'gl_Position = finalPosition;',
	
				'}'
	
			].join( '\n' ) );
	
			_gl.shaderSource( fragmentShader, [
	
				'precision ' + _renderer.getPrecision() + ' float;',
	
				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',
	
				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vec4 texture = texture2D( map, vUV );',
	
					'if ( texture.a < alphaTest ) discard;',
	
					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
					'if ( fogType > 0 ) {',
	
						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',
	
						'if ( fogType == 1 ) {',
	
							'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
						'} else {',
	
							'const float LOG2 = 1.442695;',
							'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
						'}',
	
						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
					'}',
	
				'}'
	
			].join( '\n' ) );
	
			_gl.compileShader( vertexShader );
			_gl.compileShader( fragmentShader );
	
			_gl.attachShader( program, vertexShader );
			_gl.attachShader( program, fragmentShader );
	
			_gl.linkProgram( program );
	
			return program;
	
		};
	
		function painterSortStable ( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		};
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DepthPassPlugin = function () {
	
		this.enabled = false;
		this.renderTarget = null;
	
		var _gl,
		_renderer,
		_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,
	
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4();
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			var depthShader = THREE.ShaderLib[ "depthRGBA" ];
			var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
			_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
			_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
			_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
			_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );
	
			_depthMaterial._shadowPass = true;
			_depthMaterialMorph._shadowPass = true;
			_depthMaterialSkin._shadowPass = true;
			_depthMaterialMorphSkin._shadowPass = true;
	
		};
	
		this.render = function ( scene, camera ) {
	
			if ( ! this.enabled ) return;
	
			this.update( scene, camera );
	
		};
	
		this.update = function ( scene, camera ) {
	
			var i, il, j, jl, n,
	
			program, buffer, material,
			webglObject, object, light,
			renderList,
	
			fog = null;
	
			// set GL state for depth map
	
			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );
	
			_renderer.setDepthTest( true );
	
			// update scene
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			// render depth map
	
			_renderer.setRenderTarget( this.renderTarget );
			_renderer.clear();
	
			// set object matrices & frustum culling
	
			renderList = scene.__webglObjects;
	
			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
				webglObject = renderList[ j ];
				object = webglObject.object;
	
				webglObject.render = false;
	
				if ( object.visible ) {
	
					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {
	
						object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
	
						webglObject.render = true;
	
					}
	
				}
	
			}
	
			// render regular objects
	
			var objectMaterial, useMorphing, useSkinning;
	
			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
				webglObject = renderList[ j ];
	
				if ( webglObject.render ) {
	
					object = webglObject.object;
					buffer = webglObject.buffer;
	
					// todo: create proper depth material for particles
	
					if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;
	
					objectMaterial = getObjectMaterial( object );
	
					if ( objectMaterial ) _renderer.setMaterialFaces( object.material );
	
					useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
	
					if ( object.customDepthMaterial ) {
	
						material = object.customDepthMaterial;
	
					} else if ( useSkinning ) {
	
						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
	
					} else if ( useMorphing ) {
	
						material = _depthMaterialMorph;
	
					} else {
	
						material = _depthMaterial;
	
					}
	
					if ( buffer instanceof THREE.BufferGeometry ) {
	
						_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );
	
					} else {
	
						_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );
	
					}
	
				}
	
			}
	
			// set matrices and render immediate objects
	
			renderList = scene.__webglObjectsImmediate;
	
			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
				webglObject = renderList[ j ];
				object = webglObject.object;
	
				if ( object.visible ) {
	
					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
	
					_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );
	
				}
	
			}
	
			// restore GL state
	
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
	
			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );
	
		};
	
		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use
	
		function getObjectMaterial( object ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;
	
		};
	
	};
	
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.ShaderFlares = {
	
		'lensFlareVertexTexture': {
	
			vertexShader: [
	
				"uniform lowp int renderType;",
	
				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",
	
				"uniform sampler2D occlusionMap;",
	
				"attribute vec2 position;",
				"attribute vec2 uv;",
	
				"varying vec2 vUV;",
				"varying float vVisibility;",
	
				"void main() {",
	
					"vUV = uv;",
	
					"vec2 pos = position;",
	
					"if( renderType == 2 ) {",
	
						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
						"vVisibility =        visibility.r / 9.0;",
						"vVisibility *= 1.0 - visibility.g / 9.0;",
						"vVisibility *=       visibility.b / 9.0;",
						"vVisibility *= 1.0 - visibility.a / 9.0;",
	
						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
					"}",
	
					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform lowp int renderType;",
	
				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",
	
				"varying vec2 vUV;",
				"varying float vVisibility;",
	
				"void main() {",
	
					// pink square
	
					"if( renderType == 0 ) {",
	
						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
					// restore
	
					"} else if( renderType == 1 ) {",
	
						"gl_FragColor = texture2D( map, vUV );",
	
					// flare
	
					"} else {",
	
						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",
	
					"}",
	
				"}"
			].join( "\n" )
	
		},
	
	
		'lensFlare': {
	
			vertexShader: [
	
				"uniform lowp int renderType;",
	
				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",
	
				"attribute vec2 position;",
				"attribute vec2 uv;",
	
				"varying vec2 vUV;",
	
				"void main() {",
	
					"vUV = uv;",
	
					"vec2 pos = position;",
	
					"if( renderType == 2 ) {",
	
						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
					"}",
	
					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"precision mediump float;",
	
				"uniform lowp int renderType;",
	
				"uniform sampler2D map;",
				"uniform sampler2D occlusionMap;",
				"uniform float opacity;",
				"uniform vec3 color;",
	
				"varying vec2 vUV;",
	
				"void main() {",
	
					// pink square
	
					"if( renderType == 0 ) {",
	
						"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
	
					// restore
	
					"} else if( renderType == 1 ) {",
	
						"gl_FragColor = texture2D( map, vUV );",
	
					// flare
	
					"} else {",
	
						"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
						"visibility = ( 1.0 - visibility / 4.0 );",
	
						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * visibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",
	
					"}",
	
				"}"
	
			].join( "\n" )
	
		}
	
	};
	
	
	
	/*** EXPORTS FROM exports-loader ***/
	module.exports = THREE;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var ArbitraryController, DatasetInfoView, Marionette, app, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Marionette = __webpack_require__(49);
	
	app = __webpack_require__(48);
	
	constants = __webpack_require__(61);
	
	ArbitraryController = __webpack_require__(247);
	
	DatasetInfoView = (function(superClass) {
	  extend(DatasetInfoView, superClass);
	
	  function DatasetInfoView() {
	    return DatasetInfoView.__super__.constructor.apply(this, arguments);
	  }
	
	  DatasetInfoView.prototype.className = "col-sm-12 flex-column";
	
	  DatasetInfoView.prototype.id = "dataset";
	
	  DatasetInfoView.prototype.template = _.template("<div class=\"well\">\n  <p><%- annotationType %></p>\n  <p>DataSet: <%- dataSetName %></p>\n  <p>Viewport width: <%- chooseUnit(zoomLevel) %></p>\n  <% if(treeCount != null) { %>\n    <p>Total number of trees: <%- treeCount %></p>\n  <% } %>\n</div>");
	
	  DatasetInfoView.prototype.templateHelpers = {
	    chooseUnit: function() {
	      if (this.zoomLevel < 1000) {
	        return this.zoomLevel.toFixed(0) + " nm";
	      } else if (this.zoomLevel < 1000000) {
	        return (this.zoomLevel / 1000).toFixed(1) + " μm";
	      } else {
	        return (this.zoomLevel / 1000000).toFixed(1) + " mm";
	      }
	    }
	  };
	
	  DatasetInfoView.prototype.initialize = function(options) {
	    this.listenTo(this.model.flycam3d, "changed", this.render);
	    this.listenTo(this.model.flycam, "zoomStepChanged", this.render);
	    if (this.model.skeletonTracing) {
	      this.listenTo(this.model.skeletonTracing, "deleteTree", this.render);
	      this.listenTo(this.model.skeletonTracing, "mergeTree", this.render);
	      return this.listenTo(this.model.skeletonTracing, "newTree", this.render);
	    }
	  };
	
	  DatasetInfoView.prototype.serializeData = function() {
	    var annotationType, ref, task;
	    annotationType = this.model.get("tracingType");
	    task = this.model.get("tracing").task;
	    if (task) {
	      annotationType += " " + task.formattedHash;
	    }
	    return {
	      annotationType: annotationType,
	      zoomLevel: this.calculateZoomLevel(),
	      dataSetName: this.model.get("dataset").get("name"),
	      treeCount: (ref = this.model.skeletonTracing) != null ? ref.trees.length : void 0
	    };
	  };
	
	  DatasetInfoView.prototype.calculateZoomLevel = function() {
	    var ref, ref1, width, zoom;
	    if (ref = this.model.mode, indexOf.call(constants.MODES_PLANE, ref) >= 0) {
	      zoom = this.model.flycam.getPlaneScalingFactor();
	      width = constants.PLANE_WIDTH;
	    }
	    if (ref1 = this.model.mode, indexOf.call(constants.MODES_ARBITRARY, ref1) >= 0) {
	      zoom = this.model.flycam3d.zoomStep;
	      width = ArbitraryController.prototype.WIDTH;
	    }
	    return zoom * width * app.scaleInfo.baseVoxel;
	  };
	
	  DatasetInfoView.prototype.onDestroy = function() {
	    this.model.flycam3d.off("changed");
	    return this.model.flycam.off("zoomStepChanged");
	  };
	
	  return DatasetInfoView;
	
	})(Marionette.ItemView);
	
	module.exports = DatasetInfoView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var $, ArbitraryController, ArbitraryPlane, ArbitraryPlaneInfo, ArbitraryView, Backbone, Crosshair, Input, M4x4, TWEEN, Utils, V3, _, app, constants, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	$ = __webpack_require__(1);
	
	_ = __webpack_require__(2);
	
	TWEEN = __webpack_require__(248);
	
	Input = __webpack_require__(233);
	
	ArbitraryPlane = __webpack_require__(249);
	
	Crosshair = __webpack_require__(253);
	
	ArbitraryView = __webpack_require__(254);
	
	ArbitraryPlaneInfo = __webpack_require__(255);
	
	constants = __webpack_require__(61);
	
	ref = __webpack_require__(189), M4x4 = ref.M4x4, V3 = ref.V3;
	
	Utils = __webpack_require__(188);
	
	ArbitraryController = (function() {
	  ArbitraryController.prototype.WIDTH = 128;
	
	  ArbitraryController.prototype.plane = null;
	
	  ArbitraryController.prototype.crosshair = null;
	
	  ArbitraryController.prototype.cam = null;
	
	  ArbitraryController.prototype.fullscreen = false;
	
	  ArbitraryController.prototype.lastNodeMatrix = null;
	
	  ArbitraryController.prototype.model = null;
	
	  ArbitraryController.prototype.view = null;
	
	  ArbitraryController.prototype.record = false;
	
	  ArbitraryController.prototype.input = {
	    mouse: null,
	    keyboard: null,
	    keyboardNoLoop: null,
	    keyboardOnce: null,
	    unbind: function() {
	      var ref1, ref2, ref3, ref4;
	      if ((ref1 = this.mouse) != null) {
	        ref1.unbind();
	      }
	      if ((ref2 = this.keyboard) != null) {
	        ref2.unbind();
	      }
	      if ((ref3 = this.keyboardNoLoop) != null) {
	        ref3.unbind();
	      }
	      return (ref4 = this.keyboardOnce) != null ? ref4.unbind() : void 0;
	    }
	  };
	
	  function ArbitraryController(model1, view, sceneController, skeletonTracingController) {
	    var canvas;
	    this.model = model1;
	    this.view = view;
	    this.sceneController = sceneController;
	    this.skeletonTracingController = skeletonTracingController;
	    this.setWaypoint = bind(this.setWaypoint, this);
	    this.addNode = bind(this.addNode, this);
	    this.scroll = bind(this.scroll, this);
	    _.extend(this, Backbone.Events);
	    this.isStarted = false;
	    this.canvas = canvas = $("#render-canvas");
	    this.cam = this.model.flycam3d;
	    this.arbitraryView = new ArbitraryView(canvas, this.cam, this.view, this.WIDTH);
	    this.plane = new ArbitraryPlane(this.cam, this.model, this.WIDTH);
	    this.arbitraryView.addGeometry(this.plane);
	    this.infoPlane = new ArbitraryPlaneInfo();
	    this.infoPlane.render();
	    $("#render").append(this.infoPlane.el);
	    this.input = _.extend({}, this.input);
	    this.crosshair = new Crosshair(this.cam, this.model.user.get("crosshairSize"));
	    this.arbitraryView.addGeometry(this.crosshair);
	    this.listenTo(this.model.user, "change:displayCrosshair", function(model, value) {
	      return this.crosshair.setVisibility(value);
	    });
	    this.bindToEvents();
	    this.arbitraryView.draw();
	    this.stop();
	    this.crosshair.setVisibility(this.model.user.get("displayCrosshair"));
	    this.setRecord(true);
	    $('#trace-mode-trace').on("click", (function(_this) {
	      return function() {
	        _this.setRecord(true);
	        return $(":focus").blur();
	      };
	    })(this));
	    $('#trace-mode-watch').on("click", (function(_this) {
	      return function() {
	        _this.setRecord(false);
	        return $(":focus").blur();
	      };
	    })(this));
	  }
	
	  ArbitraryController.prototype.render = function(forceUpdate, event) {
	    var binary, j, len, matrix, ref1, results;
	    matrix = this.cam.getMatrix();
	    ref1 = this.model.getColorBinaries();
	    results = [];
	    for (j = 0, len = ref1.length; j < len; j++) {
	      binary = ref1[j];
	      results.push(binary.arbitraryPing(matrix));
	    }
	    return results;
	  };
	
	  ArbitraryController.prototype.initMouse = function() {
	    return this.input.mouse = new Input.Mouse(this.canvas, {
	      leftDownMove: (function(_this) {
	        return function(delta) {
	          var f;
	          if (_this.mode === constants.MODE_ARBITRARY) {
	            _this.cam.yaw(-delta.x * _this.model.user.getMouseInversionX() * _this.model.user.get("mouseRotateValue"), true);
	            return _this.cam.pitch(delta.y * _this.model.user.getMouseInversionY() * _this.model.user.get("mouseRotateValue"), true);
	          } else if (_this.mode === constants.MODE_ARBITRARY_PLANE) {
	            f = _this.cam.getZoomStep() / (_this.arbitraryView.width / _this.WIDTH);
	            return _this.cam.move([delta.x * f, delta.y * f, 0]);
	          }
	        };
	      })(this),
	      scroll: this.scroll
	    });
	  };
	
	  ArbitraryController.prototype.initKeyboard = function() {
	    var getVoxelOffset;
	    getVoxelOffset = (function(_this) {
	      return function(timeFactor) {
	        return _this.model.user.get("moveValue3d") * timeFactor / app.scaleInfo.baseVoxel / constants.FPS;
	      };
	    })(this);
	    this.input.keyboard = new Input.Keyboard({
	      "l": (function(_this) {
	        return function(timeFactor) {
	          return _this.arbitraryView.applyScale(-_this.model.user.get("scaleValue"));
	        };
	      })(this),
	      "k": (function(_this) {
	        return function(timeFactor) {
	          return _this.arbitraryView.applyScale(_this.model.user.get("scaleValue"));
	        };
	      })(this),
	      "w": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.move([0, getVoxelOffset(timeFactor), 0]);
	        };
	      })(this),
	      "s": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.move([0, -getVoxelOffset(timeFactor), 0]);
	        };
	      })(this),
	      "a": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.move([getVoxelOffset(timeFactor), 0, 0]);
	        };
	      })(this),
	      "d": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.move([-getVoxelOffset(timeFactor), 0, 0]);
	        };
	      })(this),
	      "space": (function(_this) {
	        return function(timeFactor) {
	          _this.cam.move([0, 0, getVoxelOffset(timeFactor)]);
	          return _this.moved();
	        };
	      })(this),
	      "ctrl + space": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.move([0, 0, -getVoxelOffset(timeFactor)]);
	        };
	      })(this),
	      "shift + left": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.yaw(_this.model.user.get("rotateValue") * timeFactor);
	        };
	      })(this),
	      "shift + right": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.yaw(-_this.model.user.get("rotateValue") * timeFactor);
	        };
	      })(this),
	      "shift + up": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.pitch(_this.model.user.get("rotateValue") * timeFactor);
	        };
	      })(this),
	      "shift + down": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.pitch(-_this.model.user.get("rotateValue") * timeFactor);
	        };
	      })(this),
	      "left": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.yaw(_this.model.user.get("rotateValue") * timeFactor, _this.mode === constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "right": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.yaw(-_this.model.user.get("rotateValue") * timeFactor, _this.mode === constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "up": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.pitch(-_this.model.user.get("rotateValue") * timeFactor, _this.mode === constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "down": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.pitch(_this.model.user.get("rotateValue") * timeFactor, _this.mode === constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "i": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.zoomIn();
	        };
	      })(this),
	      "o": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.zoomOut();
	        };
	      })(this),
	      "h": (function(_this) {
	        return function(timeFactor) {
	          return _this.changeMoveValue(25);
	        };
	      })(this),
	      "g": (function(_this) {
	        return function(timeFactor) {
	          return _this.changeMoveValue(-25);
	        };
	      })(this)
	    });
	    this.input.keyboardNoLoop = new Input.KeyboardNoLoop({
	      "1": (function(_this) {
	        return function() {
	          return _this.skeletonTracingController.toggleSkeletonVisibility();
	        };
	      })(this),
	      "2": (function(_this) {
	        return function() {
	          return _this.sceneController.skeleton.toggleInactiveTreeVisibility();
	        };
	      })(this),
	      "delete": (function(_this) {
	        return function() {
	          return _this.model.skeletonTracing.deleteActiveNode();
	        };
	      })(this),
	      "c": (function(_this) {
	        return function() {
	          return _this.model.skeletonTracing.createNewTree();
	        };
	      })(this),
	      "b": (function(_this) {
	        return function() {
	          return _this.pushBranch();
	        };
	      })(this),
	      "j": (function(_this) {
	        return function() {
	          return _this.popBranch();
	        };
	      })(this),
	      "r": (function(_this) {
	        return function() {
	          return _this.cam.setRotation([0, 0, 0]);
	        };
	      })(this),
	      "y": (function(_this) {
	        return function() {
	          return _this.centerActiveNode();
	        };
	      })(this),
	      "z": (function(_this) {
	        return function() {
	          return _this.setRecord(true);
	        };
	      })(this),
	      "u": (function(_this) {
	        return function() {
	          return _this.setRecord(false);
	        };
	      })(this),
	      "n": (function(_this) {
	        return function() {
	          return _this.setActiveNode(_this.model.skeletonTracing.nextCommentNodeID(false), true);
	        };
	      })(this),
	      "p": (function(_this) {
	        return function() {
	          return _this.setActiveNode(_this.model.skeletonTracing.nextCommentNodeID(true), true);
	        };
	      })(this)
	    });
	    return this.input.keyboardOnce = new Input.Keyboard({
	      "shift + space": (function(_this) {
	        return function() {
	          _this.model.skeletonTracing.deleteActiveNode();
	          return _this.centerActiveNode();
	        };
	      })(this)
	    }, -1);
	  };
	
	  ArbitraryController.prototype.setRecord = function(record) {
	    this.record = record;
	    $('#trace-mode button').removeClass("btn-primary");
	    if (this.record) {
	      $('#trace-mode-trace').addClass("btn-primary");
	    } else {
	      $('#trace-mode-watch').addClass("btn-primary");
	    }
	    this.infoPlane.updateInfo(this.record);
	    if (this.record) {
	      return this.setWaypoint();
	    }
	  };
	
	  ArbitraryController.prototype.init = function() {
	    this.setClippingDistance(this.model.user.get("clippingDistanceArbitrary"));
	    return this.arbitraryView.applyScale(0);
	  };
	
	  ArbitraryController.prototype.bindToEvents = function() {
	    var binary, name, ref1;
	    this.listenTo(this.arbitraryView, "render", this.render);
	    ref1 = this.model.binary;
	    for (name in ref1) {
	      binary = ref1[name];
	      this.listenTo(binary.cube, "bucketLoaded", this.arbitraryView.draw);
	    }
	    this.listenTo(this.model.user, "change:crosshairSize", function(model, value) {
	      return this.crosshair.setScale(value);
	    });
	    this.listenTo(this.model.user, {
	      "change:sphericalCapRadius": function(model, value) {
	        this.model.flycam3d.distance = value;
	        return this.plane.setMode(this.mode);
	      }
	    });
	    return this.listenTo(this.model.user, "change:clippingDistanceArbitrary", function(model, value) {
	      return this.setClippingDistance(value);
	    });
	  };
	
	  ArbitraryController.prototype.start = function(mode) {
	    this.mode = mode;
	    this.stop();
	    this.plane.setMode(this.mode);
	    this.initKeyboard();
	    this.initMouse();
	    this.arbitraryView.start();
	    this.init();
	    this.arbitraryView.draw();
	    return this.isStarted = true;
	  };
	
	  ArbitraryController.prototype.stop = function() {
	    if (this.isStarted) {
	      this.input.unbind();
	    }
	    this.arbitraryView.stop();
	    return this.isStarted = false;
	  };
	
	  ArbitraryController.prototype.scroll = function(delta, type) {
	    switch (type) {
	      case "shift":
	        return this.setParticleSize(Utils.clamp(-1, delta, 1));
	    }
	  };
	
	  ArbitraryController.prototype.addNode = function(position, rotation) {
	    var datasetConfig, fourBit, interpolation;
	    datasetConfig = this.model.get("datasetConfiguration");
	    fourBit = datasetConfig.get("fourBit") ? 4 : 8;
	    interpolation = datasetConfig.get("interpolation");
	    return this.model.skeletonTracing.addNode(position, rotation, constants.TYPE_USUAL, constants.ARBITRARY_VIEW, 0, fourBit, interpolation);
	  };
	
	  ArbitraryController.prototype.setWaypoint = function() {
	    var position, rotation;
	    if (!this.record) {
	      return;
	    }
	    position = this.cam.getPosition();
	    rotation = this.cam.getRotation();
	    return this.addNode(position, rotation);
	  };
	
	  ArbitraryController.prototype.changeMoveValue = function(delta) {
	    var moveValue;
	    moveValue = this.model.user.get("moveValue3d") + delta;
	    moveValue = Math.min(constants.MAX_MOVE_VALUE, moveValue);
	    moveValue = Math.max(constants.MIN_MOVE_VALUE, moveValue);
	    return this.model.user.set("moveValue3d", Number(moveValue));
	  };
	
	  ArbitraryController.prototype.setParticleSize = function(delta) {
	    var particleSize;
	    particleSize = this.model.user.get("particleSize") + delta;
	    particleSize = Math.min(constants.MAX_PARTICLE_SIZE, particleSize);
	    particleSize = Math.max(constants.MIN_PARTICLE_SIZE, particleSize);
	    return this.model.user.set("particleSize", Number(particleSize));
	  };
	
	  ArbitraryController.prototype.setClippingDistance = function(value) {
	    return this.arbitraryView.setClippingDistance(value);
	  };
	
	  ArbitraryController.prototype.pushBranch = function() {
	    return this.model.skeletonTracing.pushBranch();
	  };
	
	  ArbitraryController.prototype.popBranch = function() {
	    return _.defer((function(_this) {
	      return function() {
	        return _this.model.skeletonTracing.popBranch().then(function(id) {
	          return _this.setActiveNode(id, true);
	        });
	      };
	    })(this));
	  };
	
	  ArbitraryController.prototype.centerActiveNode = function() {
	    var activeNode, curPos, curRotation, newPos, newRotation, waypointAnimation;
	    activeNode = this.model.skeletonTracing.getActiveNode();
	    if (activeNode) {
	      curPos = this.cam.getPosition();
	      newPos = this.model.skeletonTracing.getActiveNodePos();
	      curRotation = this.cam.getRotation();
	      newRotation = this.model.skeletonTracing.getActiveNodeRotation();
	      newRotation = this.getShortestRotation(curRotation, newRotation);
	      waypointAnimation = new TWEEN.Tween({
	        x: curPos[0],
	        y: curPos[1],
	        z: curPos[2],
	        rx: curRotation[0],
	        ry: curRotation[1],
	        rz: curRotation[2],
	        cam: this.cam
	      });
	      waypointAnimation.to({
	        x: newPos[0],
	        y: newPos[1],
	        z: newPos[2],
	        rx: newRotation[0],
	        ry: newRotation[1],
	        rz: newRotation[2]
	      }, 200);
	      waypointAnimation.onUpdate(function() {
	        this.cam.setPosition([this.x, this.y, this.z]);
	        return this.cam.setRotation([this.rx, this.ry, this.rz]);
	      });
	      waypointAnimation.start();
	      return this.cam.update();
	    }
	  };
	
	  ArbitraryController.prototype.setActiveNode = function(nodeId, centered, mergeTree) {
	    this.model.skeletonTracing.setActiveNode(nodeId, mergeTree);
	    this.cam.setPosition(this.model.skeletonTracing.getActiveNodePos());
	    return this.cam.setRotation(this.model.skeletonTracing.getActiveNodeRotation());
	  };
	
	  ArbitraryController.prototype.getShortestRotation = function(curRotation, newRotation) {
	    var i, j;
	    for (i = j = 0; j <= 2; i = ++j) {
	      if (newRotation[i] - curRotation[i] > 180) {
	        newRotation[i] -= 360;
	      } else if (newRotation[i] - curRotation[i] < -180) {
	        newRotation[i] += 360;
	      }
	    }
	    return newRotation;
	  };
	
	  ArbitraryController.prototype.moved = function() {
	    var lastNodeMatrix, matrix, vector, vectorLength;
	    matrix = this.cam.getMatrix();
	    if (this.lastNodeMatrix == null) {
	      this.lastNodeMatrix = matrix;
	    }
	    lastNodeMatrix = this.lastNodeMatrix;
	    vector = [lastNodeMatrix[12] - matrix[12], lastNodeMatrix[13] - matrix[13], lastNodeMatrix[14] - matrix[14]];
	    vectorLength = V3.length(vector);
	    if (vectorLength > 10) {
	      this.setWaypoint();
	      return this.lastNodeMatrix = matrix;
	    }
	  };
	
	  return ArbitraryController;
	
	})();
	
	module.exports = ArbitraryController;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */
	
	// Include a performance.now polyfill
	(function () {
	
		if ('performance' in window === false) {
			window.performance = {};
		}
	
		// IE 8
		Date.now = (Date.now || function () {
			return new Date().getTime();
		});
	
		if ('now' in window.performance === false) {
			var offset = window.performance.timing && window.performance.timing.navigationStart ? window.performance.timing.navigationStart
			                                                                                    : Date.now();
	
			window.performance.now = function () {
				return Date.now() - offset;
			};
		}
	
	})();
	
	var TWEEN = TWEEN || (function () {
	
		var _tweens = [];
	
		return {
	
			getAll: function () {
	
				return _tweens;
	
			},
	
			removeAll: function () {
	
				_tweens = [];
	
			},
	
			add: function (tween) {
	
				_tweens.push(tween);
	
			},
	
			remove: function (tween) {
	
				var i = _tweens.indexOf(tween);
	
				if (i !== -1) {
					_tweens.splice(i, 1);
				}
	
			},
	
			update: function (time) {
	
				if (_tweens.length === 0) {
					return false;
				}
	
				var i = 0;
	
				time = time !== undefined ? time : window.performance.now();
	
				while (i < _tweens.length) {
	
					if (_tweens[i].update(time)) {
						i++;
					} else {
						_tweens.splice(i, 1);
					}
	
				}
	
				return true;
	
			}
		};
	
	})();
	
	TWEEN.Tween = function (object) {
	
		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _yoyo = false;
		var _isPlaying = false;
		var _reversed = false;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;
		var _onStopCallback = null;
	
		// Set all starting values present on the target object
		for (var field in object) {
			_valuesStart[field] = parseFloat(object[field], 10);
		}
	
		this.to = function (properties, duration) {
	
			if (duration !== undefined) {
				_duration = duration;
			}
	
			_valuesEnd = properties;
	
			return this;
	
		};
	
		this.start = function (time) {
	
			TWEEN.add(this);
	
			_isPlaying = true;
	
			_onStartCallbackFired = false;
	
			_startTime = time !== undefined ? time : window.performance.now();
			_startTime += _delayTime;
	
			for (var property in _valuesEnd) {
	
				// Check if an Array was provided as property value
				if (_valuesEnd[property] instanceof Array) {
	
					if (_valuesEnd[property].length === 0) {
						continue;
					}
	
					// Create a local copy of the Array with the start value at the front
					_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
	
				}
	
				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (_valuesStart[property] === undefined) {
					continue;
				}
	
				_valuesStart[property] = _object[property];
	
				if ((_valuesStart[property] instanceof Array) === false) {
					_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}
	
				_valuesStartRepeat[property] = _valuesStart[property] || 0;
	
			}
	
			return this;
	
		};
	
		this.stop = function () {
	
			if (!_isPlaying) {
				return this;
			}
	
			TWEEN.remove(this);
			_isPlaying = false;
	
			if (_onStopCallback !== null) {
				_onStopCallback.call(_object);
			}
	
			this.stopChainedTweens();
			return this;
	
		};
	
		this.stopChainedTweens = function () {
	
			for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
				_chainedTweens[i].stop();
			}
	
		};
	
		this.delay = function (amount) {
	
			_delayTime = amount;
			return this;
	
		};
	
		this.repeat = function (times) {
	
			_repeat = times;
			return this;
	
		};
	
		this.yoyo = function (yoyo) {
	
			_yoyo = yoyo;
			return this;
	
		};
	
	
		this.easing = function (easing) {
	
			_easingFunction = easing;
			return this;
	
		};
	
		this.interpolation = function (interpolation) {
	
			_interpolationFunction = interpolation;
			return this;
	
		};
	
		this.chain = function () {
	
			_chainedTweens = arguments;
			return this;
	
		};
	
		this.onStart = function (callback) {
	
			_onStartCallback = callback;
			return this;
	
		};
	
		this.onUpdate = function (callback) {
	
			_onUpdateCallback = callback;
			return this;
	
		};
	
		this.onComplete = function (callback) {
	
			_onCompleteCallback = callback;
			return this;
	
		};
	
		this.onStop = function (callback) {
	
			_onStopCallback = callback;
			return this;
	
		};
	
		this.update = function (time) {
	
			var property;
			var elapsed;
			var value;
	
			if (time < _startTime) {
				return true;
			}
	
			if (_onStartCallbackFired === false) {
	
				if (_onStartCallback !== null) {
					_onStartCallback.call(_object);
				}
	
				_onStartCallbackFired = true;
	
			}
	
			elapsed = (time - _startTime) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;
	
			value = _easingFunction(elapsed);
	
			for (property in _valuesEnd) {
	
				// Don't update properties that do not exist in the source object
				if (_valuesStart[property] === undefined) {
					continue;
				}
	
				var start = _valuesStart[property] || 0;
				var end = _valuesEnd[property];
	
				if (end instanceof Array) {
	
					_object[property] = _interpolationFunction(end, value);
	
				} else {
	
					// Parses relative end values with start as base (e.g.: +10, -3)
					if (typeof (end) === 'string') {
	
						if (end.startsWith('+') || end.startsWith('-')) {
							end = start + parseFloat(end, 10);
						} else {
							end = parseFloat(end, 10);
						}
					}
	
					// Protect against non numeric properties.
					if (typeof (end) === 'number') {
						_object[property] = start + (end - start) * value;
					}
	
				}
	
			}
	
			if (_onUpdateCallback !== null) {
				_onUpdateCallback.call(_object, value);
			}
	
			if (elapsed === 1) {
	
				if (_repeat > 0) {
	
					if (isFinite(_repeat)) {
						_repeat--;
					}
	
					// Reassign starting values, restart by making startTime = now
					for (property in _valuesStartRepeat) {
	
						if (typeof (_valuesEnd[property]) === 'string') {
							_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);
						}
	
						if (_yoyo) {
							var tmp = _valuesStartRepeat[property];
	
							_valuesStartRepeat[property] = _valuesEnd[property];
							_valuesEnd[property] = tmp;
						}
	
						_valuesStart[property] = _valuesStartRepeat[property];
	
					}
	
					if (_yoyo) {
						_reversed = !_reversed;
					}
	
					_startTime = time + _delayTime;
	
					return true;
	
				} else {
	
					if (_onCompleteCallback !== null) {
						_onCompleteCallback.call(_object);
					}
	
					for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						_chainedTweens[i].start(_startTime + _duration);
					}
	
					return false;
	
				}
	
			}
	
			return true;
	
		};
	
	};
	
	
	TWEEN.Easing = {
	
		Linear: {
	
			None: function (k) {
	
				return k;
	
			}
	
		},
	
		Quadratic: {
	
			In: function (k) {
	
				return k * k;
	
			},
	
			Out: function (k) {
	
				return k * (2 - k);
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}
	
				return - 0.5 * (--k * (k - 2) - 1);
	
			}
	
		},
	
		Cubic: {
	
			In: function (k) {
	
				return k * k * k;
	
			},
	
			Out: function (k) {
	
				return --k * k * k + 1;
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}
	
				return 0.5 * ((k -= 2) * k * k + 2);
	
			}
	
		},
	
		Quartic: {
	
			In: function (k) {
	
				return k * k * k * k;
	
			},
	
			Out: function (k) {
	
				return 1 - (--k * k * k * k);
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}
	
				return - 0.5 * ((k -= 2) * k * k * k - 2);
	
			}
	
		},
	
		Quintic: {
	
			In: function (k) {
	
				return k * k * k * k * k;
	
			},
	
			Out: function (k) {
	
				return --k * k * k * k * k + 1;
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}
	
				return 0.5 * ((k -= 2) * k * k * k * k + 2);
	
			}
	
		},
	
		Sinusoidal: {
	
			In: function (k) {
	
				return 1 - Math.cos(k * Math.PI / 2);
	
			},
	
			Out: function (k) {
	
				return Math.sin(k * Math.PI / 2);
	
			},
	
			InOut: function (k) {
	
				return 0.5 * (1 - Math.cos(Math.PI * k));
	
			}
	
		},
	
		Exponential: {
	
			In: function (k) {
	
				return k === 0 ? 0 : Math.pow(1024, k - 1);
	
			},
	
			Out: function (k) {
	
				return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);
	
			},
	
			InOut: function (k) {
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}
	
				return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);
	
			}
	
		},
	
		Circular: {
	
			In: function (k) {
	
				return 1 - Math.sqrt(1 - k * k);
	
			},
	
			Out: function (k) {
	
				return Math.sqrt(1 - (--k * k));
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return - 0.5 * (Math.sqrt(1 - k * k) - 1);
				}
	
				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	
			}
	
		},
	
		Elastic: {
	
			In: function (k) {
	
				var s;
				var a = 0.1;
				var p = 0.4;
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}
	
				return - (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	
			},
	
			Out: function (k) {
	
				var s;
				var a = 0.1;
				var p = 0.4;
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}
	
				return (a * Math.pow(2, - 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	
			},
	
			InOut: function (k) {
	
				var s;
				var a = 0.1;
				var p = 0.4;
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}
	
				if ((k *= 2) < 1) {
					return - 0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
				}
	
				return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
			}
	
		},
	
		Back: {
	
			In: function (k) {
	
				var s = 1.70158;
	
				return k * k * ((s + 1) * k - s);
	
			},
	
			Out: function (k) {
	
				var s = 1.70158;
	
				return --k * k * ((s + 1) * k + s) + 1;
	
			},
	
			InOut: function (k) {
	
				var s = 1.70158 * 1.525;
	
				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}
	
				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	
			}
	
		},
	
		Bounce: {
	
			In: function (k) {
	
				return 1 - TWEEN.Easing.Bounce.Out(1 - k);
	
			},
	
			Out: function (k) {
	
				if (k < (1 / 2.75)) {
					return 7.5625 * k * k;
				} else if (k < (2 / 2.75)) {
					return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
				} else if (k < (2.5 / 2.75)) {
					return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
				} else {
					return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
				}
	
			},
	
			InOut: function (k) {
	
				if (k < 0.5) {
					return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				}
	
				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
	
			}
	
		}
	
	};
	
	TWEEN.Interpolation = {
	
		Linear: function (v, k) {
	
			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.Linear;
	
			if (k < 0) {
				return fn(v[0], v[1], f);
			}
	
			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}
	
			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
	
		},
	
		Bezier: function (v, k) {
	
			var b = 0;
			var n = v.length - 1;
			var pw = Math.pow;
			var bn = TWEEN.Interpolation.Utils.Bernstein;
	
			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}
	
			return b;
	
		},
	
		CatmullRom: function (v, k) {
	
			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.CatmullRom;
	
			if (v[0] === v[m]) {
	
				if (k < 0) {
					i = Math.floor(f = m * (1 + k));
				}
	
				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
	
			} else {
	
				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
				}
	
				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
				}
	
				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
	
			}
	
		},
	
		Utils: {
	
			Linear: function (p0, p1, t) {
	
				return (p1 - p0) * t + p0;
	
			},
	
			Bernstein: function (n, i) {
	
				var fc = TWEEN.Interpolation.Utils.Factorial;
	
				return fc(n) / fc(i) / fc(n - i);
	
			},
	
			Factorial: (function () {
	
				var a = [1];
	
				return function (n) {
	
					var s = 1;
	
					if (a[n]) {
						return a[n];
					}
	
					for (var i = n; i > 1; i--) {
						s *= i;
					}
	
					a[n] = s;
					return s;
	
				};
	
			})(),
	
			CatmullRom: function (p0, p1, p2, p3, t) {
	
				var v0 = (p2 - p0) * 0.5;
				var v1 = (p3 - p1) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;
	
				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	
			}
	
		}
	
	};
	
	// UMD (Universal Module Definition)
	(function (root) {
	
		if (true) {
	
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return TWEEN;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
		} else if (typeof module !== 'undefined' && typeof exports === 'object') {
	
			// Node.js
			module.exports = TWEEN;
	
		} else if (root !== undefined) {
	
			// Global variable
			root.TWEEN = TWEEN;
	
		}
	
	})(this);


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var ArbitraryPlane, ArbitraryPlaneMaterialFactory, M4x4, THREE, V3, _, backbone, constants, ref;
	
	_ = __webpack_require__(2);
	
	backbone = __webpack_require__(3);
	
	THREE = __webpack_require__(245);
	
	ref = __webpack_require__(189), M4x4 = ref.M4x4, V3 = ref.V3;
	
	constants = __webpack_require__(61);
	
	ArbitraryPlaneMaterialFactory = __webpack_require__(250);
	
	ArbitraryPlane = (function() {
	  ArbitraryPlane.prototype.cam = null;
	
	  ArbitraryPlane.prototype.model = null;
	
	  ArbitraryPlane.prototype.mesh = null;
	
	  ArbitraryPlane.prototype.isDirty = true;
	
	  ArbitraryPlane.prototype.queryVertices = null;
	
	  ArbitraryPlane.prototype.width = 0;
	
	  ArbitraryPlane.prototype.height = 0;
	
	  ArbitraryPlane.prototype.x = 0;
	
	  function ArbitraryPlane(cam1, model, width) {
	    var binary, name, ref1;
	    this.cam = cam1;
	    this.model = model;
	    this.width = width != null ? width : 128;
	    _.extend(this, Backbone.Events);
	    this.mesh = this.createMesh();
	    this.listenTo(this.cam, "changed", function() {
	      return this.isDirty = true;
	    });
	    this.listenTo(this.model.flycam, "positionChanged", function() {
	      return this.isDirty = true;
	    });
	    ref1 = this.model.binary;
	    for (name in ref1) {
	      binary = ref1[name];
	      binary.cube.on("bucketLoaded", (function(_this) {
	        return function() {
	          return _this.isDirty = true;
	        };
	      })(this));
	    }
	    if (Math.log(this.width) / Math.LN2 % 1 === 1) {
	      throw "width needs to be a power of 2";
	    }
	  }
	
	  ArbitraryPlane.prototype.setMode = function(mode, radius) {
	    this.queryVertices = (function() {
	      switch (mode) {
	        case constants.MODE_ARBITRARY:
	          return this.calculateSphereVertices();
	        case constants.MODE_ARBITRARY_PLANE:
	          return this.calculatePlaneVertices();
	      }
	    }).call(this);
	    return this.isDirty = true;
	  };
	
	  ArbitraryPlane.prototype.attachScene = function(scene) {
	    return scene.add(this.mesh);
	  };
	
	  ArbitraryPlane.prototype.update = function() {
	    var cam, m, matrix, mesh, newColors, newVertices;
	    if (this.isDirty) {
	      mesh = this.mesh, cam = this.cam;
	      matrix = cam.getZoomedMatrix();
	      newVertices = M4x4.transformPointsAffine(matrix, this.queryVertices);
	      newColors = this.model.getColorBinaries()[0].getByVerticesSync(newVertices);
	      this.textureMaterial.setData("color", newColors);
	      m = cam.getZoomedMatrix();
	      mesh.matrix.set(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
	      mesh.matrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI));
	      mesh.matrixWorldNeedsUpdate = true;
	      return this.isDirty = false;
	    }
	  };
	
	  ArbitraryPlane.prototype.calculateSphereVertices = function(sphericalCapRadius) {
	    var centerVertex, currentIndex, i, j, length, queryVertices, ref1, ref2, vector, vertex, x, y;
	    if (sphericalCapRadius == null) {
	      sphericalCapRadius = this.cam.distance;
	    }
	    queryVertices = new Float32Array(this.width * this.width * 3);
	    currentIndex = 0;
	    vertex = [0, 0, 0];
	    vector = [0, 0, 0];
	    centerVertex = [0, 0, -sphericalCapRadius];
	    for (y = i = 0, ref1 = this.width; i < ref1; y = i += 1) {
	      for (x = j = 0, ref2 = this.width; j < ref2; x = j += 1) {
	        vertex[0] = x - (Math.floor(this.width / 2));
	        vertex[1] = y - (Math.floor(this.width / 2));
	        vertex[2] = 0;
	        vector = V3.sub(vertex, centerVertex, vector);
	        length = V3.length(vector);
	        vector = V3.scale(vector, sphericalCapRadius / length, vector);
	        queryVertices[currentIndex++] = centerVertex[0] + vector[0];
	        queryVertices[currentIndex++] = centerVertex[1] + vector[1];
	        queryVertices[currentIndex++] = centerVertex[2] + vector[2];
	      }
	    }
	    return queryVertices;
	  };
	
	  ArbitraryPlane.prototype.calculatePlaneVertices = function() {
	    var currentIndex, i, j, queryVertices, ref1, ref2, x, y;
	    queryVertices = new Float32Array(this.width * this.width * 3);
	    currentIndex = 0;
	    for (y = i = 0, ref1 = this.width; i < ref1; y = i += 1) {
	      for (x = j = 0, ref2 = this.width; j < ref2; x = j += 1) {
	        queryVertices[currentIndex++] = x - (Math.floor(this.width / 2));
	        queryVertices[currentIndex++] = y - (Math.floor(this.width / 2));
	        queryVertices[currentIndex++] = 0;
	      }
	    }
	    return queryVertices;
	  };
	
	  ArbitraryPlane.prototype.applyScale = function(delta) {
	    this.x = Number(this.mesh.scale.x) + Number(delta);
	    if (this.x > .5 && this.x < 10) {
	      this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = this.x;
	      return this.cam.update();
	    }
	  };
	
	  ArbitraryPlane.prototype.createMesh = function() {
	    var plane;
	    this.textureMaterial = new ArbitraryPlaneMaterialFactory(this.model, this.width).getMaterial();
	    plane = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.width, 1, 1), this.textureMaterial);
	    plane.rotation.x = Math.PI;
	    this.x = 1;
	    plane.matrixAutoUpdate = false;
	    plane.doubleSided = true;
	    return plane;
	  };
	
	  return ArbitraryPlane;
	
	})();
	
	module.exports = ArbitraryPlane;


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var AbstractPlaneMaterialFactory, ArbitraryPlaneMaterialFactory, THREE,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(245);
	
	AbstractPlaneMaterialFactory = __webpack_require__(251);
	
	ArbitraryPlaneMaterialFactory = (function(superClass) {
	  extend(ArbitraryPlaneMaterialFactory, superClass);
	
	  function ArbitraryPlaneMaterialFactory() {
	    return ArbitraryPlaneMaterialFactory.__super__.constructor.apply(this, arguments);
	  }
	
	  ArbitraryPlaneMaterialFactory.prototype.createTextures = function() {
	    this.colorName = this.sanitizeName(this.model.getColorBinaries()[0].name);
	    this.textures = {};
	    this.textures[this.colorName] = this.createDataTexture(this.tWidth, 1);
	    return this.uniforms[this.colorName + "_texture"] = {
	      type: "t",
	      value: this.textures[this.colorName]
	    };
	  };
	
	  ArbitraryPlaneMaterialFactory.prototype.createDataTexture = function(width, bytes) {
	    this.minFilter = THREE.LinearFilter;
	    return ArbitraryPlaneMaterialFactory.__super__.createDataTexture.call(this, width, bytes);
	  };
	
	  ArbitraryPlaneMaterialFactory.prototype.getFragmentShader = function() {
	    return _.template("uniform sampler2D <%= colorName %>_texture;\nuniform float <%= colorName %>_brightness, <%= colorName %>_contrast;\nvarying vec2 vUv;\n\nvoid main()\n{\n  float color_value = 0.0;\n\n  /* Get grayscale value */\n  color_value = texture2D( <%= colorName %>_texture, vUv).r;\n\n  /* Brightness / Contrast Transformation */\n  color_value = (color_value + <%= colorName %>_brightness - 0.5) * <%= colorName %>_contrast + 0.5;\n\n  /* Set frag color */\n  gl_FragColor = vec4(color_value, color_value, color_value, 1.0);\n}")({
	      colorName: this.colorName
	    });
	  };
	
	  return ArbitraryPlaneMaterialFactory;
	
	})(AbstractPlaneMaterialFactory);
	
	module.exports = ArbitraryPlaneMaterialFactory;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var AbstractMaterialFactory, AbstractPlaneMaterialFactory, THREE, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	app = __webpack_require__(48);
	
	THREE = __webpack_require__(245);
	
	AbstractMaterialFactory = __webpack_require__(252);
	
	AbstractPlaneMaterialFactory = (function(superClass) {
	  extend(AbstractPlaneMaterialFactory, superClass);
	
	  function AbstractPlaneMaterialFactory(model1, tWidth) {
	    this.model = model1;
	    this.tWidth = tWidth;
	    _.extend(this, Backbone.Events);
	    this.minFilter = THREE.NearestFilter;
	    this.maxFilter = THREE.NearestFilter;
	    AbstractPlaneMaterialFactory.__super__.constructor.call(this, this.model);
	  }
	
	  AbstractPlaneMaterialFactory.prototype.setupAttributesAndUniforms = function() {
	    var binary, i, len, name, ref;
	    AbstractPlaneMaterialFactory.__super__.setupAttributesAndUniforms.call(this);
	    ref = this.model.getColorBinaries();
	    for (i = 0, len = ref.length; i < len; i++) {
	      binary = ref[i];
	      name = this.sanitizeName(binary.name);
	      this.uniforms[name + "_brightness"] = {
	        type: "f",
	        value: this.model.datasetConfiguration.get("layers." + binary.name + ".brightness") / 255
	      };
	      this.uniforms[name + "_contrast"] = {
	        type: "f",
	        value: this.model.datasetConfiguration.get("layers." + binary.name + ".contrast")
	      };
	    }
	    return this.createTextures();
	  };
	
	  AbstractPlaneMaterialFactory.prototype.makeMaterial = function(options) {
	    AbstractPlaneMaterialFactory.__super__.makeMaterial.call(this, options);
	    return this.material.setData = (function(_this) {
	      return function(name, data) {
	        var ref, ref1, textureName;
	        textureName = _this.sanitizeName(name);
	        if ((ref = _this.textures[textureName]) != null) {
	          ref.image.data.set(data);
	        }
	        return (ref1 = _this.textures[textureName]) != null ? ref1.needsUpdate = true : void 0;
	      };
	    })(this);
	  };
	
	  AbstractPlaneMaterialFactory.prototype.setupChangeListeners = function() {
	    return this.listenTo(this.model.datasetConfiguration, "change", function(model) {
	      var binaryName, changes, name, ref;
	      ref = model.changed.layers || {};
	      for (binaryName in ref) {
	        changes = ref[binaryName];
	        name = this.sanitizeName(binaryName);
	        if (changes.brightness != null) {
	          this.uniforms[name + "_brightness"].value = changes.brightness / 255;
	        }
	        if (changes.contrast != null) {
	          this.uniforms[name + "_contrast"].value = changes.contrast;
	        }
	      }
	      return app.vent.trigger("rerender");
	    });
	  };
	
	  AbstractPlaneMaterialFactory.prototype.createTextures = function() {
	    throw new Error("Subclass responsibility");
	  };
	
	  AbstractPlaneMaterialFactory.prototype.sanitizeName = function(name) {
	    if (name == null) {
	      return;
	    }
	    return "binary_" + name.replace(/-/g, "_");
	  };
	
	  AbstractPlaneMaterialFactory.prototype.createDataTexture = function(width, bytes) {
	    var format;
	    format = bytes === 1 ? THREE.LuminanceFormat : THREE.RGBFormat;
	    return new THREE.DataTexture(new Uint8Array(bytes * width * width), width, width, format, THREE.UnsignedByteType, new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, this.minFilter, this.maxFilter);
	  };
	
	  AbstractPlaneMaterialFactory.prototype.getVertexShader = function() {
	    return "varying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position =   projectionMatrix *\n                  modelViewMatrix *\n                  vec4(position,1.0); }";
	  };
	
	  return AbstractPlaneMaterialFactory;
	
	})(AbstractMaterialFactory);
	
	module.exports = AbstractPlaneMaterialFactory;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var AbstractMaterialFactory, Backbone, THREE;
	
	Backbone = __webpack_require__(3);
	
	THREE = __webpack_require__(245);
	
	AbstractMaterialFactory = (function() {
	  function AbstractMaterialFactory(model) {
	    this.model = model;
	    _.extend(this, Backbone.Events);
	    this.setupAttributesAndUniforms();
	    this.makeMaterial();
	    this.setupChangeListeners();
	  }
	
	  AbstractMaterialFactory.prototype.setupAttributesAndUniforms = function() {
	    this.uniforms = {};
	    return this.attributes = {};
	  };
	
	  AbstractMaterialFactory.prototype.makeMaterial = function(options) {
	    if (options == null) {
	      options = {};
	    }
	    options = _.extend(options, {
	      uniforms: this.uniforms,
	      attributes: this.attributes,
	      vertexShader: this.getVertexShader(),
	      fragmentShader: this.getFragmentShader()
	    });
	    return this.material = new THREE.ShaderMaterial(options);
	  };
	
	  AbstractMaterialFactory.prototype.setupChangeListeners = function() {};
	
	  AbstractMaterialFactory.prototype.getMaterial = function() {
	    return this.material;
	  };
	
	  AbstractMaterialFactory.prototype.getVertexShader = function() {};
	
	  AbstractMaterialFactory.prototype.getFragmentShader = function() {};
	
	  return AbstractMaterialFactory;
	
	})();
	
	module.exports = AbstractMaterialFactory;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var Crosshair, THREE;
	
	THREE = __webpack_require__(245);
	
	Crosshair = (function() {
	  Crosshair.prototype.WIDTH = 200;
	
	  Crosshair.prototype.COLOR = "#2895FF";
	
	  Crosshair.prototype.SCALE_MIN = 0.01;
	
	  Crosshair.prototype.SCALE_MAX = 1;
	
	  Crosshair.prototype.context = null;
	
	  Crosshair.prototype.mesh = null;
	
	  Crosshair.prototype.scale = 0;
	
	  Crosshair.prototype.isDirty = true;
	
	  function Crosshair(cam1, scale) {
	    var WIDTH, canvas;
	    this.cam = cam1;
	    WIDTH = this.WIDTH;
	    canvas = document.createElement('canvas');
	    canvas.width = canvas.height = WIDTH;
	    this.context = canvas.getContext("2d");
	    this.mesh = this.createMesh(canvas);
	    this.mesh.setVisibility = function(v) {
	      this.arbitraryVisible = v;
	      return this.updateVisibility();
	    };
	    this.mesh.setVisibilityEnabled = function(v) {
	      this.visibilityEnabled = v;
	      return this.updateVisibility();
	    };
	    this.mesh.updateVisibility = function() {
	      return this.visible = this.arbitraryVisible && this.visibilityEnabled;
	    };
	    this.setScale(scale);
	  }
	
	  Crosshair.prototype.setVisibility = function(v) {
	    return this.mesh.setVisibilityEnabled(v);
	  };
	
	  Crosshair.prototype.update = function() {
	    var COLOR, WIDTH, cam, context, isDirty, m, mesh, texture;
	    isDirty = this.isDirty, context = this.context, WIDTH = this.WIDTH, COLOR = this.COLOR, texture = this.texture, mesh = this.mesh, cam = this.cam;
	    if (this.isDirty) {
	      context.clearRect(0, 0, WIDTH, WIDTH);
	      context.fillStyle = COLOR;
	      context.strokeStyle = COLOR;
	      context.lineWidth = 3;
	      context.moveTo(WIDTH / 2, 3);
	      context.beginPath();
	      context.arc(WIDTH / 2, WIDTH / 2, WIDTH / 2 - 3, 0, 2 * Math.PI);
	      context.stroke();
	      context.beginPath();
	      context.moveTo(WIDTH / 2, WIDTH / 2 - 1);
	      context.arc(WIDTH / 2, WIDTH / 2, 4, 0, 2 * Math.PI, true);
	      context.fill();
	      mesh.material.map.needsUpdate = true;
	    }
	    m = this.cam.getZoomedMatrix();
	    mesh.matrix.set(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
	    mesh.matrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI));
	    mesh.matrix.multiply(new THREE.Matrix4().makeTranslation(0, 0, 0.5));
	    mesh.matrix.scale(new THREE.Vector3(this.scale, this.scale, this.scale));
	    mesh.matrixWorldNeedsUpdate = true;
	    return this.isDirty = false;
	  };
	
	  Crosshair.prototype.setScale = function(value) {
	    var SCALE_MAX, SCALE_MIN, mesh;
	    SCALE_MIN = this.SCALE_MIN, SCALE_MAX = this.SCALE_MAX, mesh = this.mesh;
	    if (value > SCALE_MIN && value < SCALE_MAX) {
	      this.scale = value;
	    }
	    return this.isDirty = true;
	  };
	
	  Crosshair.prototype.attachScene = function(scene) {
	    return scene.add(this.mesh);
	  };
	
	  Crosshair.prototype.createMesh = function(canvas) {
	    var WIDTH, material, mesh, texture;
	    WIDTH = this.WIDTH;
	    texture = new THREE.Texture(canvas);
	    material = new THREE.MeshBasicMaterial({
	      map: texture
	    });
	    material.transparent = true;
	    mesh = new THREE.Mesh(new THREE.PlaneGeometry(WIDTH, WIDTH), material);
	    mesh.rotation.x = Math.PI;
	    mesh.matrixAutoUpdate = false;
	    mesh.doubleSided = true;
	    return mesh;
	  };
	
	  return Crosshair;
	
	})();
	
	module.exports = Crosshair;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var $, ArbitraryView, Backbone, Constants, THREE, TWEEN, _, app,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	$ = __webpack_require__(1);
	
	_ = __webpack_require__(2);
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	THREE = __webpack_require__(245);
	
	TWEEN = __webpack_require__(248);
	
	Constants = __webpack_require__(61);
	
	ArbitraryView = (function() {
	  ArbitraryView.prototype.DEFAULT_SCALE = 2;
	
	  ArbitraryView.prototype.MAX_SCALE = 3;
	
	  ArbitraryView.prototype.MIN_SCALE = 1;
	
	  ArbitraryView.prototype.forceUpdate = false;
	
	  ArbitraryView.prototype.geometries = [];
	
	  ArbitraryView.prototype.additionalInfo = "";
	
	  ArbitraryView.prototype.isRunning = true;
	
	  ArbitraryView.prototype.animationRequestId = void 0;
	
	  ArbitraryView.prototype.scene = null;
	
	  ArbitraryView.prototype.camera = null;
	
	  ArbitraryView.prototype.cameraPosition = null;
	
	  function ArbitraryView(canvas, dataCam, view, width) {
	    var camera, ref;
	    this.dataCam = dataCam;
	    this.view = view;
	    this.setClippingDistance = bind(this.setClippingDistance, this);
	    this.applyScale = bind(this.applyScale, this);
	    this.resize = bind(this.resize, this);
	    this.animate = bind(this.animate, this);
	    _.extend(this, Backbone.Events);
	    this.CAM_DISTANCE = width / 2 / Math.tan(Math.PI / 180 * 45 / 2);
	    this.container = $(canvas);
	    this.width = this.container.width();
	    this.height = this.container.height();
	    this.deviceScaleFactor = window.devicePixelRatio || 1;
	    ref = this.view, this.renderer = ref.renderer, this.scene = ref.scene;
	    this.camera = camera = new THREE.PerspectiveCamera(45, this.width / this.height, 50, 1000);
	    camera.matrixAutoUpdate = false;
	    camera.aspect = this.width / this.height;
	    this.cameraPosition = [0, 0, this.CAM_DISTANCE];
	    this.group = new THREE.Object3D;
	    this.group.scale = (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Vector3, app.scaleInfo.nmPerVoxel, function(){});
	    this.scene.add(this.group);
	    this.group.add(camera);
	  }
	
	  ArbitraryView.prototype.start = function() {
	    var element, i, len, ref;
	    if (!this.isRunning) {
	      this.isRunning = true;
	      ref = this.group.children;
	      for (i = 0, len = ref.length; i < len; i++) {
	        element = ref[i];
	        element.setVisibility = element.setVisibility || function(v) {
	          return this.visible = v;
	        };
	        element.setVisibility(true);
	      }
	      $('.skeleton-arbitrary-controls').show();
	      $("#arbitrary-info-canvas").show();
	      this.resize();
	      this.animationRequestId = window.requestAnimationFrame(this.animate);
	      return $(window).on("resize", this.resize);
	    }
	  };
	
	  ArbitraryView.prototype.stop = function() {
	    var element, i, len, ref;
	    if (this.isRunning) {
	      this.isRunning = false;
	      if (this.animationRequestId != null) {
	        window.cancelAnimationFrame(this.animationRequestId);
	        this.animationRequestId = void 0;
	      }
	      ref = this.group.children;
	      for (i = 0, len = ref.length; i < len; i++) {
	        element = ref[i];
	        element.setVisibility = element.setVisibility || function(v) {
	          return this.visible = v;
	        };
	        element.setVisibility(false);
	      }
	      $(window).off("resize", this.resize);
	      $('.skeleton-arbitrary-controls').hide();
	      return $("#arbitrary-info-canvas").hide();
	    }
	  };
	
	  ArbitraryView.prototype.animate = function() {
	    var camera, forceUpdate, geometries, geometry, i, len, m, ref, renderer, scene;
	    this.animationRequestId = void 0;
	    if (!this.isRunning) {
	      return;
	    }
	    TWEEN.update();
	    if (this.trigger("render", this.forceUpdate) || this.forceUpdate) {
	      camera = this.camera, geometries = this.geometries, renderer = this.renderer, scene = this.scene;
	      for (i = 0, len = geometries.length; i < len; i++) {
	        geometry = geometries[i];
	        if (geometry.update != null) {
	          geometry.update();
	        }
	      }
	      m = this.dataCam.getZoomedMatrix();
	      camera.matrix.set(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
	      camera.matrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI));
	      camera.matrix.multiply((ref = new THREE.Matrix4()).makeTranslation.apply(ref, this.cameraPosition));
	      camera.matrixWorldNeedsUpdate = true;
	      renderer.setViewport(0, 0, this.width * this.deviceScaleFactor, this.height * this.deviceScaleFactor);
	      renderer.setScissor(0, 0, this.width * this.deviceScaleFactor, this.height * this.deviceScaleFactor);
	      renderer.enableScissorTest(true);
	      renderer.setClearColor(0xFFFFFF, 1);
	      renderer.render(scene, camera);
	      forceUpdate = false;
	      this.trigger("render");
	    }
	    return this.animationRequestId = window.requestAnimationFrame(this.animate);
	  };
	
	  ArbitraryView.prototype.draw = function() {
	    return this.forceUpdate = true;
	  };
	
	  ArbitraryView.prototype.addGeometry = function(geometry) {
	    this.geometries.push(geometry);
	    geometry.attachScene(this.group);
	  };
	
	  ArbitraryView.prototype.resizeThrottled = function() {
	    this.resizeThrottled = _.throttle((function(_this) {
	      return function() {
	        return _this.resize();
	      };
	    })(this), Constants.RESIZE_THROTTLE_TIME);
	    return this.resizeThrottled();
	  };
	
	  ArbitraryView.prototype.resize = function() {
	    this.width = this.container.width();
	    this.height = this.container.height();
	    this.renderer.setSize(this.width, this.height);
	    this.camera.aspect = this.width / this.height;
	    this.camera.updateProjectionMatrix();
	    return this.draw();
	  };
	
	  ArbitraryView.prototype.applyScale = function(delta) {
	    if (!this.scaleFactor) {
	      this.scaleFactor = this.DEFAULT_SCALE;
	    }
	    if ((this.scaleFactor + delta > this.MIN_SCALE) && (this.scaleFactor + delta < this.MAX_SCALE)) {
	      this.scaleFactor += Number(delta);
	      this.width = this.height = this.scaleFactor * Constants.VIEWPORT_WIDTH;
	      this.container.width(this.width);
	      this.container.height(this.height);
	      return this.resizeThrottled();
	    }
	  };
	
	  ArbitraryView.prototype.setClippingDistance = function(value) {
	    this.camera.near = this.CAM_DISTANCE - value;
	    return this.camera.updateProjectionMatrix();
	  };
	
	  ArbitraryView.prototype.setAdditionalInfo = function(info) {
	    return this.additionalInfo = info;
	  };
	
	  return ArbitraryView;
	
	})();
	
	module.exports = ArbitraryView;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var ArbitraryPlaneInfo, marionette,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	marionette = __webpack_require__(49);
	
	ArbitraryPlaneInfo = (function(superClass) {
	  extend(ArbitraryPlaneInfo, superClass);
	
	  ArbitraryPlaneInfo.prototype.NOT_RECORDING_CLASS = "not-recording";
	
	  ArbitraryPlaneInfo.prototype.NOT_RECORDING = "Watching";
	
	  ArbitraryPlaneInfo.prototype.RECORDING_CLASS = "recording";
	
	  ArbitraryPlaneInfo.prototype.RECORDING = "RECORDING";
	
	  ArbitraryPlaneInfo.prototype.tagName = "div";
	
	  ArbitraryPlaneInfo.prototype.id = "arbitrary-info-canvas";
	
	  ArbitraryPlaneInfo.prototype.className = function() {
	    if (this.model.get("isRecording")) {
	      return this.RECORDING_CLASS;
	    } else {
	      return this.NOT_RECORDING_CLASS;
	    }
	  };
	
	  ArbitraryPlaneInfo.prototype.template = _.template("<span class=\"recording-text\">\n  <%= recordingText %>\n</span>");
	
	  function ArbitraryPlaneInfo() {
	    this.model = new Backbone.Model({
	      isRecording: false,
	      recordingText: this.NOT_RECORDING
	    });
	    ArbitraryPlaneInfo.__super__.constructor.call(this);
	  }
	
	  ArbitraryPlaneInfo.prototype.initialize = function() {
	    return this.listenTo(this.model, "change", this.render);
	  };
	
	  ArbitraryPlaneInfo.prototype.updateInfo = function(isRecording) {
	    this.model.set({
	      isRecording: isRecording,
	      recordingText: isRecording ? this.RECORDING : this.NOT_RECORDING
	    });
	    return this.$el.removeClass(this.NOT_RECORDING_CLASS).removeClass(this.RECORDING_CLASS).addClass(this.className());
	  };
	
	  return ArbitraryPlaneInfo;
	
	})(Backbone.Marionette.ItemView);
	
	module.exports = ArbitraryPlaneInfo;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, DatasetInfoView, MappingInfoView, VolumeTracingRightMenuView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	MappingInfoView = __webpack_require__(257);
	
	DatasetInfoView = __webpack_require__(246);
	
	VolumeTracingRightMenuView = (function(superClass) {
	  extend(VolumeTracingRightMenuView, superClass);
	
	  function VolumeTracingRightMenuView() {
	    return VolumeTracingRightMenuView.__super__.constructor.apply(this, arguments);
	  }
	
	  VolumeTracingRightMenuView.prototype.getTabs = function() {
	    return [
	      {
	        id: "tab-info",
	        name: "Info",
	        viewClass: DatasetInfoView
	      }, {
	        id: "volume-mapping-info",
	        name: "Mapping Info",
	        viewClass: MappingInfoView
	      }
	    ];
	  };
	
	  return VolumeTracingRightMenuView;
	
	})(AbstractTabView);
	
	module.exports = VolumeTracingRightMenuView;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var CheckboxSettingView, MappingInfoView, Marionette, _, backbone, subviews,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	backbone = __webpack_require__(3);
	
	Marionette = __webpack_require__(49);
	
	subviews = __webpack_require__(198);
	
	_ = __webpack_require__(2);
	
	CheckboxSettingView = __webpack_require__(202);
	
	MappingInfoView = (function(superClass) {
	  extend(MappingInfoView, superClass);
	
	  function MappingInfoView() {
	    return MappingInfoView.__super__.constructor.apply(this, arguments);
	  }
	
	  MappingInfoView.prototype.RENDER_DEBOUNCE_TIME = 200;
	
	  MappingInfoView.prototype.id = "volume-mapping-info";
	
	  MappingInfoView.prototype.template = _.template("<div class=\"well\">\n  <% if (hasMapping) { %>\n    <p>ID without mapping: <%- idWithoutMapping %></p>\n    <p>ID with mapping: <%- idWithMapping %></p>\n  <% } else { %>\n    <p>ID at current position: <%- idWithoutMapping %></p>\n  <% } %>\n</div>\n<% if (hasMapping) { %>\n  <div data-subview=\"enableMapping\"></div>\n<% } %>");
	
	  MappingInfoView.prototype.subviewCreators = {
	    "enableMapping": function() {
	      return new CheckboxSettingView({
	        model: this.model,
	        options: {
	          name: "enableMapping",
	          displayName: "Enable Mapping"
	        }
	      });
	    }
	  };
	
	  MappingInfoView.prototype.initialize = function(arg) {
	    var oxalisModel;
	    oxalisModel = arg.model;
	    Backbone.Subviews.add(this);
	    this.model = new Backbone.Model();
	    this.model.set("enableMapping", true);
	    this.binary = oxalisModel.getSegmentationBinary();
	    this.cube = this.binary.cube;
	    this.flycam = oxalisModel.flycam;
	    this.renderDebounced = _.debounce(this.render, this.RENDER_DEBOUNCE_TIME);
	    this.listenTo(this.cube, "bucketLoaded", this.renderDebounced);
	    this.listenTo(this.cube, "volumeLabeled", this.renderDebounced);
	    this.listenTo(this.cube, "newMapping", this.render);
	    this.listenTo(this.flycam, "positionChanged", this.renderDebounced);
	    return this.listenTo(this.model, "change:enableMapping", function() {
	      return this.cube.setMappingEnabled(this.model.get("enableMapping"));
	    });
	  };
	
	  MappingInfoView.prototype.serializeData = function() {
	    var pos;
	    pos = this.flycam.getPosition();
	    return {
	      hasMapping: this.cube.hasMapping(),
	      idWithMapping: this.cube.getDataValue(pos, this.cube.mapping),
	      idWithoutMapping: this.cube.getDataValue(pos, this.cube.EMPTY_MAPPING)
	    };
	  };
	
	  return MappingInfoView;
	
	})(Marionette.CompositeView);
	
	module.exports = MappingInfoView;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractTabView, DatasetInfoView, ViewmodeRightMenuView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractTabView = __webpack_require__(195);
	
	DatasetInfoView = __webpack_require__(246);
	
	ViewmodeRightMenuView = (function(superClass) {
	  extend(ViewmodeRightMenuView, superClass);
	
	  function ViewmodeRightMenuView() {
	    return ViewmodeRightMenuView.__super__.constructor.apply(this, arguments);
	  }
	
	  ViewmodeRightMenuView.prototype.getTabs = function() {
	    return [
	      {
	        id: "tab-info",
	        name: "Info",
	        viewClass: DatasetInfoView
	      }
	    ];
	  };
	
	  return ViewmodeRightMenuView;
	
	})(AbstractTabView);
	
	module.exports = ViewmodeRightMenuView;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var Marionette, UserScriptsModalView, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Marionette = __webpack_require__(49);
	
	UserScriptsModalView = (function(superClass) {
	  extend(UserScriptsModalView, superClass);
	
	  function UserScriptsModalView() {
	    return UserScriptsModalView.__super__.constructor.apply(this, arguments);
	  }
	
	  UserScriptsModalView.prototype.className = "modal fade";
	
	  UserScriptsModalView.prototype.template = _.template("<div class=\"modal-dialog modal-lg\">\n  <div class=\"modal-content\">\n    <div class=\"modal-header\">\n      <button type=\"button\" class=\"close\" data-dismiss=\"modal\">&times;</button>\n      <h3>Add user script</h3>\n    </div>\n    <div class=\"modal-body\">\n      <textarea id=\"add-script-input\" rows=\"10\"></textarea>\n    </div>\n    <div class=\"modal-footer\">\n      <a href=\"#\" id=\"add-script-button\" class=\"btn btn-default\">Add</a>\n      <a href=\"#\" class=\"btn btn-default\" data-dismiss=\"modal\">Close</a>\n    </div>\n  </div>\n</div>");
	
	  UserScriptsModalView.prototype.ui = {
	    "inputBox": "#add-script-input"
	  };
	
	  UserScriptsModalView.prototype.events = {
	    "click #add-script-button": "handleAddClick"
	  };
	
	  UserScriptsModalView.prototype.show = function() {
	    return this.$el.modal("show");
	  };
	
	  UserScriptsModalView.prototype.handleAddClick = function() {
	    return eval(this.ui.inputBox.val());
	  };
	
	  return UserScriptsModalView;
	
	})(Marionette.ItemView);
	
	module.exports = UserScriptsModalView;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Constants, Marionette, TracingView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Marionette = __webpack_require__(49);
	
	Constants = __webpack_require__(61);
	
	TracingView = (function(superClass) {
	  extend(TracingView, superClass);
	
	  function TracingView() {
	    return TracingView.__super__.constructor.apply(this, arguments);
	  }
	
	  TracingView.prototype.id = "render";
	
	  TracingView.prototype.template = _.template("<div id=\"modal\" class=\"modal fade\"></div>\n<div id=\"inputcatchers\">\n  <div id=\"planexy\" class=\"inputcatcher\"></div>\n  <div id=\"planeyz\" class=\"inputcatcher\"></div>\n  <div id=\"planexz\" class=\"inputcatcher\"></div>\n  <div id=\"TDView\" class=\"inputcatcher\">\n    <div id=\"TDViewControls\" class=\"btn-group\">\n      <button type=\"button\" class=\"btn btn-default btn-sm\">3D</button>\n      <button type=\"button\" class=\"btn btn-default btn-sm\">\n        <span></span>XY\n      </button>\n      <button type=\"button\" class=\"btn btn-default btn-sm\">\n        <span></span>YZ\n      </button>\n      <button type=\"button\" class=\"btn btn-default btn-sm\">\n        <span></span>XZ\n      </button>\n    </div>\n  </div>\n</div>");
	
	  TracingView.prototype.events = {
	    "contextmenu": "disableContextMenu"
	  };
	
	  TracingView.prototype.ui = {
	    "inputcatchers": ".inputcatcher"
	  };
	
	  TracingView.prototype.initialize = function() {
	    return this.listenTo(this.model.flycam, "zoomStepChanged", function() {
	      return this.$el.toggleClass("zoomstep-warning", (this.model.volumeTracing != null) && !this.model.canDisplaySegmentationData());
	    });
	  };
	
	  TracingView.prototype.disableContextMenu = function(event) {
	    event.preventDefault();
	  };
	
	  TracingView.prototype.onRender = function() {
	    var ref;
	    if (ref = this.model.get("mode"), indexOf.call(Constants.MODES_ARBITRARY, ref) >= 0) {
	      return this.ui.inputcatchers.hide();
	    }
	  };
	
	  return TracingView;
	
	})(Marionette.LayoutView);
	
	module.exports = TracingView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, Controller, Input, MinimalArbitraryController, Model, PlaneController, SceneController, SkeletonTracingArbitraryController, SkeletonTracingController, SkeletonTracingPlaneController, SkeletonTracingView, Stats, Toast, UrlManager, View, VolumeTracingController, VolumeTracingPlaneController, VolumeTracingView, _, app, constants,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	$ = __webpack_require__(1);
	
	_ = __webpack_require__(2);
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	Stats = __webpack_require__(262);
	
	PlaneController = __webpack_require__(263);
	
	SkeletonTracingController = __webpack_require__(309);
	
	VolumeTracingController = __webpack_require__(310);
	
	SkeletonTracingArbitraryController = __webpack_require__(311);
	
	SkeletonTracingPlaneController = __webpack_require__(312);
	
	VolumeTracingPlaneController = __webpack_require__(313);
	
	MinimalArbitraryController = __webpack_require__(314);
	
	SceneController = __webpack_require__(315);
	
	UrlManager = __webpack_require__(327);
	
	Model = __webpack_require__(266);
	
	View = __webpack_require__(306);
	
	SkeletonTracingView = __webpack_require__(328);
	
	VolumeTracingView = __webpack_require__(329);
	
	constants = __webpack_require__(61);
	
	Input = __webpack_require__(233);
	
	Toast = __webpack_require__(18);
	
	Controller = (function() {
	  function Controller(options) {
	    this.model = options.model;
	    _.extend(this, {
	      view: null,
	      planeController: null,
	      arbitraryController: null
	    });
	    _.extend(this, Backbone.Events);
	    this.fullScreen = false;
	    this.urlManager = new UrlManager(this.model);
	    this.model.set("state", this.urlManager.initialState);
	    this.model.fetch().then((function(_this) {
	      return function(error) {
	        return _this.modelFetchDone(error);
	      };
	    })(this));
	  }
	
	  Controller.prototype.modelFetchDone = function(error) {
	    var ArbitraryController, binaryName, stats;
	    if (error) {
	      return;
	    }
	    if (!this.model.tracing.restrictions.allowAccess) {
	      Toast.Error("You are not allowed to access this tracing");
	      return;
	    }
	    this.urlManager.startUrlUpdater();
	    this.sceneController = new SceneController(this.model.upperBoundary, this.model.flycam, this.model);
	    if (this.model.skeletonTracing != null) {
	      this.view = new SkeletonTracingView(this.model);
	      this.annotationController = new SkeletonTracingController(this.model, this.view, this.sceneController);
	      this.planeController = new SkeletonTracingPlaneController(this.model, this.view, this.sceneController, this.annotationController);
	      ArbitraryController = this.model.tracing.content.settings.advancedOptionsAllowed ? SkeletonTracingArbitraryController : MinimalArbitraryController;
	      this.arbitraryController = new ArbitraryController(this.model, this.view, this.sceneController, this.annotationController);
	    } else if (this.model.volumeTracing != null) {
	      this.view = new VolumeTracingView(this.model);
	      this.annotationController = new VolumeTracingController(this.model, this.view, this.sceneController);
	      this.planeController = new VolumeTracingPlaneController(this.model, this.view, this.sceneController, this.annotationController);
	    } else {
	      this.view = new View(this.model);
	      this.planeController = new PlaneController(this.model, this.view, this.sceneController);
	    }
	    stats = new Stats();
	    $("body").append(stats.domElement);
	    if (this.arbitraryController) {
	      this.listenTo(this.arbitraryController.arbitraryView, "render", function() {
	        return stats.update();
	      });
	    }
	    this.listenTo(this.planeController.planeView, "render", function() {
	      return stats.update();
	    });
	    this.initKeyboard();
	    this.initTimeLimit();
	    for (binaryName in this.model.binary) {
	      this.listenTo(this.model.binary[binaryName].cube, "bucketLoaded", function() {
	        return app.vent.trigger("rerender");
	      });
	    }
	    this.listenTo(this.model, "change:mode", this.loadMode);
	    this.loadMode(this.model.get("mode"));
	    this.zoomStepWarningToast = null;
	    return this.model.flycam.on({
	      zoomStepChanged: (function(_this) {
	        return function() {
	          var shouldWarn, toastType;
	          shouldWarn = !_this.model.canDisplaySegmentationData();
	          if (shouldWarn && (_this.zoomStepWarningToast == null)) {
	            toastType = _this.model.volumeTracing != null ? "danger" : "info";
	            return _this.zoomStepWarningToast = Toast.message(toastType, "Segmentation data is only fully supported at a smaller zoom level.", true);
	          } else if (!shouldWarn && (_this.zoomStepWarningToast != null)) {
	            _this.zoomStepWarningToast.remove();
	            return _this.zoomStepWarningToast = null;
	          }
	        };
	      })(this)
	    });
	  };
	
	  Controller.prototype.initKeyboard = function() {
	    var keyboardControls;
	    $(document).keydown(function(event) {
	      var ref;
	      if ((event.which === 32 || event.which === 18 || (37 <= (ref = event.which) && ref <= 40)) && !$(":focus").length) {
	        event.preventDefault();
	      }
	    });
	    keyboardControls = {};
	    if (this.model.get("controlMode") === constants.CONTROL_MODE_TRACE) {
	      _.extend(keyboardControls, {
	        "shift + 1": (function(_this) {
	          return function() {
	            return _this.model.setMode(constants.MODE_PLANE_TRACING);
	          };
	        })(this),
	        "shift + 2": (function(_this) {
	          return function() {
	            return _this.model.setMode(constants.MODE_ARBITRARY);
	          };
	        })(this),
	        "shift + 3": (function(_this) {
	          return function() {
	            return _this.model.setMode(constants.MODE_ARBITRARY_PLANE);
	          };
	        })(this),
	        "t": (function(_this) {
	          return function() {
	            return _this.view.toggleTheme();
	          };
	        })(this),
	        "m": (function(_this) {
	          return function() {
	            var index;
	            index = (_this.model.allowedModes.indexOf(_this.model.get("mode")) + 1) % _this.model.allowedModes.length;
	            return _this.model.setMode(_this.model.allowedModes[index]);
	          };
	        })(this),
	        "super + s": (function(_this) {
	          return function(event) {
	            event.preventDefault();
	            event.stopPropagation();
	            return _this.model.save();
	          };
	        })(this),
	        "ctrl + s": (function(_this) {
	          return function(event) {
	            event.preventDefault();
	            event.stopPropagation();
	            return _this.model.save();
	          };
	        })(this)
	      });
	    }
	    return new Input.KeyboardNoLoop(keyboardControls);
	  };
	
	  Controller.prototype.loadMode = function(newMode, force) {
	    var ref, ref1;
	    if (force == null) {
	      force = false;
	    }
	    if ((newMode === constants.MODE_ARBITRARY || newMode === constants.MODE_ARBITRARY_PLANE) && (indexOf.call(this.model.allowedModes, newMode) >= 0 || force)) {
	      if ((ref = this.planeController) != null) {
	        ref.stop();
	      }
	      return this.arbitraryController.start(newMode);
	    } else if ((newMode === constants.MODE_PLANE_TRACING || newMode === constants.MODE_VOLUME) && (indexOf.call(this.model.allowedModes, newMode) >= 0 || force)) {
	      if ((ref1 = this.arbitraryController) != null) {
	        ref1.stop();
	      }
	      return this.planeController.start(newMode);
	    } else {
	
	    }
	  };
	
	  Controller.prototype.initTimeLimit = function() {
	    var expectedTime, finishTracing, hardLimitRe, timeLimit;
	    if (!(this.model.tracing.task && this.model.tracing.user === "Anonymous User")) {
	      return;
	    }
	    finishTracing = (function(_this) {
	      return function() {
	        var model, tracingType;
	        model = _this.model;
	        tracingType = model.skeletonTracing || model.volumeTracing;
	        return tracingType.stateLogger.pushNow().done(function() {
	          var url;
	          url = "/annotations/" + model.tracingType + "/" + model.tracingId + "/finishAndRedirect";
	          return app.router.loadURL(url);
	        });
	      };
	    })(this);
	    hardLimitRe = /Limit: ([0-9]+)/;
	    expectedTime = this.model.tracing.task.type.expectedTime;
	    timeLimit = parseInt(expectedTime.match(hardLimitRe)[1]) * 60 * 1000 || 0;
	    if (timeLimit >= Math.pow(2, 32) / 2) {
	      Toast.error("Time limit was reduced as it cannot be bigger than 35791 minutes.");
	      timeLimit = Math.pow(2, 32) / 2 - 1;
	    }
	    console.log("TimeLimit is " + (timeLimit / 60 / 1000) + " min");
	    if (timeLimit) {
	      return setTimeout(function() {
	        window.alert("Time limit is reached, thanks for tracing!");
	        return finishTracing();
	      }, timeLimit);
	    }
	  };
	
	  return Controller;
	
	})();
	
	module.exports = Controller;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var Stats = function () {
	
		var startTime = Date.now(), prevTime = startTime;
		var ms = 0, msMin = Infinity, msMax = 0;
		var fps = 0, fpsMin = Infinity, fpsMax = 0;
		var frames = 0, mode = 0;
	
		var container = document.createElement( 'div' );
		container.id = 'stats';
		container.addEventListener( 'mousedown', function ( event ) { event.preventDefault(); setMode( ++ mode % 2 ) }, false );
		container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
	
		var fpsDiv = document.createElement( 'div' );
		fpsDiv.id = 'fps';
		fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
		container.appendChild( fpsDiv );
	
		var fpsText = document.createElement( 'div' );
		fpsText.id = 'fpsText';
		fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
		fpsText.innerHTML = 'FPS';
		fpsDiv.appendChild( fpsText );
	
		var fpsGraph = document.createElement( 'div' );
		fpsGraph.id = 'fpsGraph';
		fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
		fpsDiv.appendChild( fpsGraph );
	
		while ( fpsGraph.children.length < 74 ) {
	
			var bar = document.createElement( 'span' );
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
			fpsGraph.appendChild( bar );
	
		}
	
		var msDiv = document.createElement( 'div' );
		msDiv.id = 'ms';
		msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
		container.appendChild( msDiv );
	
		var msText = document.createElement( 'div' );
		msText.id = 'msText';
		msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
		msText.innerHTML = 'MS';
		msDiv.appendChild( msText );
	
		var msGraph = document.createElement( 'div' );
		msGraph.id = 'msGraph';
		msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
		msDiv.appendChild( msGraph );
	
		while ( msGraph.children.length < 74 ) {
	
			var bar = document.createElement( 'span' );
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
			msGraph.appendChild( bar );
	
		}
	
		var setMode = function ( value ) {
	
			mode = value;
	
			switch ( mode ) {
	
				case 0:
					fpsDiv.style.display = 'block';
					msDiv.style.display = 'none';
					break;
				case 1:
					fpsDiv.style.display = 'none';
					msDiv.style.display = 'block';
					break;
			}
	
		};
	
		var updateGraph = function ( dom, value ) {
	
			var child = dom.appendChild( dom.firstChild );
			child.style.height = value + 'px';
	
		};
	
		return {
	
			REVISION: 12,
	
			domElement: container,
	
			setMode: setMode,
	
			begin: function () {
	
				startTime = Date.now();
	
			},
	
			end: function () {
	
				var time = Date.now();
	
				ms = time - startTime;
				msMin = Math.min( msMin, ms );
				msMax = Math.max( msMax, ms );
	
				msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
				updateGraph( msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );
	
				frames ++;
	
				if ( time > prevTime + 1000 ) {
	
					fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
					fpsMin = Math.min( fpsMin, fps );
					fpsMax = Math.max( fpsMax, fps );
	
					fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
					updateGraph( fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );
	
					prevTime = time;
					frames = 0;
	
				}
	
				return time;
	
			},
	
			update: function () {
	
				startTime = this.end();
	
			}
	
		}
	
	};
	
	if ( true ) {
	
		module.exports = Stats;
	
	}

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, CameraController, Dimensions, Input, PlaneController, PlaneView, SkeletonTracingController, THREE, Trackball, Utils, VolumeTracingController, _, app, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	$ = __webpack_require__(1);
	
	_ = __webpack_require__(2);
	
	Utils = __webpack_require__(188);
	
	Input = __webpack_require__(233);
	
	Trackball = __webpack_require__(264);
	
	CameraController = __webpack_require__(265);
	
	Dimensions = __webpack_require__(277);
	
	PlaneView = __webpack_require__(308);
	
	constants = __webpack_require__(61);
	
	SkeletonTracingController = __webpack_require__(309);
	
	VolumeTracingController = __webpack_require__(310);
	
	THREE = __webpack_require__(245);
	
	PlaneController = (function() {
	  PlaneController.prototype.bindings = [];
	
	  PlaneController.prototype.model = null;
	
	  PlaneController.prototype.view = null;
	
	  PlaneController.prototype.input = {
	    mouseControllers: [],
	    keyboard: null,
	    keyboardNoLoop: null,
	    keyboardLoopDelayed: null,
	    unbind: function() {
	      var j, len, mouse, ref, ref1, ref2, ref3;
	      ref = this.mouseControllers;
	      for (j = 0, len = ref.length; j < len; j++) {
	        mouse = ref[j];
	        mouse.unbind();
	      }
	      this.mouseControllers = [];
	      if ((ref1 = this.keyboard) != null) {
	        ref1.unbind();
	      }
	      if ((ref2 = this.keyboardNoLoop) != null) {
	        ref2.unbind();
	      }
	      return (ref3 = this.keyboardLoopDelayed) != null ? ref3.unbind() : void 0;
	    }
	  };
	
	  function PlaneController(model1, view1, sceneController) {
	    var callbacks, j, len, mesh, meshes;
	    this.model = model1;
	    this.view = view1;
	    this.sceneController = sceneController;
	    this.calculateGlobalPos = bind(this.calculateGlobalPos, this);
	    this.scrollPlanes = bind(this.scrollPlanes, this);
	    this.finishZoom = bind(this.finishZoom, this);
	    this.moveZ = bind(this.moveZ, this);
	    this.moveY = bind(this.moveY, this);
	    this.moveX = bind(this.moveX, this);
	    this.move = bind(this.move, this);
	    _.extend(this, Backbone.Events);
	    this.isStarted = false;
	    this.flycam = this.model.flycam;
	    this.oldNmPos = app.scaleInfo.voxelToNm(this.flycam.getPosition());
	    this.planeView = new PlaneView(this.model, this.view);
	    this.activeViewport = constants.PLANE_XY;
	    this.cameraController = new CameraController(this.planeView.getCameras(), this.flycam, this.model);
	    this.canvasesAndNav = $("#main")[0];
	    this.TDViewControls = $('#TDViewControls');
	    this.TDViewControls.addClass("btn-group");
	    callbacks = [this.cameraController.changeTDViewDiagonal, this.cameraController.changeTDViewXY, this.cameraController.changeTDViewYZ, this.cameraController.changeTDViewXZ];
	    $("#TDViewControls button").each((function(_this) {
	      return function(i, element) {
	        return $(element).on("click", callbacks[i]);
	      };
	    })(this));
	    meshes = this.sceneController.getMeshes();
	    for (j = 0, len = meshes.length; j < len; j++) {
	      mesh = meshes[j];
	      this.planeView.addGeometry(mesh);
	    }
	    this.model.user.triggerAll();
	    this.model.datasetConfiguration.triggerAll();
	    this.initTrackballControls();
	    this.bindToEvents();
	    this.stop();
	  }
	
	  PlaneController.prototype.initMouse = function() {
	    var fn, j, planeId;
	    fn = (function(_this) {
	      return function(planeId) {
	        var inputcatcher;
	        inputcatcher = $("#plane" + constants.PLANE_NAMES[planeId]);
	        return _this.input.mouseControllers.push(new Input.Mouse(inputcatcher, _this.getPlaneMouseControls(planeId), planeId));
	      };
	    })(this);
	    for (planeId = j = 0; j <= 2; planeId = ++j) {
	      fn(planeId);
	    }
	    return this.input.mouseControllers.push(new Input.Mouse($("#TDView"), this.getTDViewMouseControls(), constants.TDView));
	  };
	
	  PlaneController.prototype.getTDViewMouseControls = function() {
	    return {
	      leftDownMove: (function(_this) {
	        return function(delta) {
	          return _this.moveTDView(delta);
	        };
	      })(this),
	      scroll: (function(_this) {
	        return function(value) {
	          return _this.zoomTDView(Utils.clamp(-1, value, 1), true);
	        };
	      })(this),
	      over: (function(_this) {
	        return function() {
	          return _this.planeView.setActiveViewport(_this.activeViewport = constants.TDView);
	        };
	      })(this)
	    };
	  };
	
	  PlaneController.prototype.getPlaneMouseControls = function(planeId) {
	    return {
	      leftDownMove: (function(_this) {
	        return function(delta, pos) {
	          return _this.move([delta.x * _this.model.user.getMouseInversionX() / _this.planeView.scaleFactor, delta.y * _this.model.user.getMouseInversionY() / _this.planeView.scaleFactor, 0]);
	        };
	      })(this),
	      over: (function(_this) {
	        return function() {
	          $(':focus').blur();
	          return _this.planeView.setActiveViewport(_this.activeViewport = planeId);
	        };
	      })(this),
	      scroll: this.scrollPlanes
	    };
	  };
	
	  PlaneController.prototype.initTrackballControls = function() {
	    var pos, ref, view;
	    view = $("#TDView")[0];
	    pos = app.scaleInfo.voxelToNm(this.flycam.getPosition());
	    this.controls = new THREE.TrackballControls(this.planeView.getCameras()[constants.TDView], view, (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Vector3, pos, function(){}), function() {
	      return app.vent.trigger("rerender");
	    });
	    this.controls.noZoom = true;
	    this.controls.noPan = true;
	    this.controls.staticMoving = true;
	    (ref = this.controls.target).set.apply(ref, app.scaleInfo.voxelToNm(this.flycam.getPosition()));
	    this.listenTo(this.flycam, "positionChanged", function(position) {
	      var i, invertedDiff, j, nmPosition, ref1;
	      nmPosition = app.scaleInfo.voxelToNm(position);
	      (ref1 = this.controls.target).set.apply(ref1, nmPosition);
	      this.controls.update();
	      invertedDiff = [];
	      for (i = j = 0; j <= 2; i = ++j) {
	        invertedDiff.push(this.oldNmPos[i] - nmPosition[i]);
	      }
	      this.oldNmPos = nmPosition;
	      return this.cameraController.moveTDView((function(func, args, ctor) {
	        ctor.prototype = func.prototype;
	        var child = new ctor, result = func.apply(child, args);
	        return Object(result) === result ? result : child;
	      })(THREE.Vector3, invertedDiff, function(){}));
	    });
	    return this.listenTo(this.cameraController, "cameraPositionChanged", this.controls.update);
	  };
	
	  PlaneController.prototype.initKeyboard = function() {
	    var getMoveValue;
	    $(document).keydown(function(event) {
	      var ref;
	      if ((event.which === 32 || event.which === 18 || (37 <= (ref = event.which) && ref <= 40)) && !$(":focus").length) {
	        event.preventDefault();
	      }
	    });
	    getMoveValue = (function(_this) {
	      return function(timeFactor) {
	        var ref;
	        if (ref = _this.activeViewport, indexOf.call([0, 1, 2], ref) >= 0) {
	          return _this.model.user.get("moveValue") * timeFactor / app.scaleInfo.baseVoxel / constants.FPS;
	        } else {
	          return constants.TDView_MOVE_SPEED * timeFactor / constants.FPS;
	        }
	      };
	    })(this);
	    this.input.keyboard = new Input.Keyboard({
	      "l": (function(_this) {
	        return function(timeFactor) {
	          return _this.scaleTrianglesPlane(-_this.model.user.get("scaleValue") * timeFactor);
	        };
	      })(this),
	      "k": (function(_this) {
	        return function(timeFactor) {
	          return _this.scaleTrianglesPlane(_this.model.user.get("scaleValue") * timeFactor);
	        };
	      })(this),
	      "left": (function(_this) {
	        return function(timeFactor) {
	          return _this.moveX(-getMoveValue(timeFactor));
	        };
	      })(this),
	      "right": (function(_this) {
	        return function(timeFactor) {
	          return _this.moveX(getMoveValue(timeFactor));
	        };
	      })(this),
	      "up": (function(_this) {
	        return function(timeFactor) {
	          return _this.moveY(-getMoveValue(timeFactor));
	        };
	      })(this),
	      "down": (function(_this) {
	        return function(timeFactor) {
	          return _this.moveY(getMoveValue(timeFactor));
	        };
	      })(this)
	    });
	    this.input.keyboardLoopDelayed = new Input.Keyboard({
	      "shift + f": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(getMoveValue(timeFactor) * 5, first);
	        };
	      })(this),
	      "shift + d": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(-getMoveValue(timeFactor) * 5, first);
	        };
	      })(this),
	      "shift + space": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(-getMoveValue(timeFactor), first);
	        };
	      })(this),
	      "ctrl + space": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(-getMoveValue(timeFactor), first);
	        };
	      })(this),
	      "space": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(getMoveValue(timeFactor), first);
	        };
	      })(this),
	      "f": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(getMoveValue(timeFactor), first);
	        };
	      })(this),
	      "d": (function(_this) {
	        return function(timeFactor, first) {
	          return _this.moveZ(-getMoveValue(timeFactor), first);
	        };
	      })(this)
	    }, this.model.user.get("keyboardDelay"));
	    this.listenTo(this.model.user, "change:keyboardDelay", function(model, value) {
	      return this.input.keyboardLoopDelayed.delay = value;
	    });
	    return this.input.keyboardNoLoop = new Input.KeyboardNoLoop(this.getKeyboardControls());
	  };
	
	  PlaneController.prototype.getKeyboardControls = function() {
	    return {
	      "i": (function(_this) {
	        return function() {
	          return _this.zoom(1, false);
	        };
	      })(this),
	      "o": (function(_this) {
	        return function() {
	          return _this.zoom(-1, false);
	        };
	      })(this),
	      "h": (function(_this) {
	        return function() {
	          return _this.changeMoveValue(25);
	        };
	      })(this),
	      "g": (function(_this) {
	        return function() {
	          return _this.changeMoveValue(-25);
	        };
	      })(this)
	    };
	  };
	
	  PlaneController.prototype.init = function() {
	    this.cameraController.setClippingDistance(this.model.user.get("clippingDistance"));
	    return this.sceneController.setClippingDistance(this.model.user.get("clippingDistance"));
	  };
	
	  PlaneController.prototype.start = function(newMode) {
	    this.stop();
	    this.sceneController.start();
	    this.planeView.start();
	    this.initKeyboard();
	    this.init();
	    this.initMouse();
	    return this.isStarted = true;
	  };
	
	  PlaneController.prototype.stop = function() {
	    if (this.isStarted) {
	      this.input.unbind();
	    }
	    this.sceneController.stop();
	    this.planeView.stop();
	    return this.isStarted = false;
	  };
	
	  PlaneController.prototype.bindToEvents = function() {
	    this.planeView.bindToEvents();
	    this.listenTo(this.planeView, "render", this.render);
	    this.listenTo(this.planeView, "renderCam", this.sceneController.updateSceneForCam);
	    this.listenTo(this.sceneController, "newGeometries", function(list) {
	      var geometry, j, len, results;
	      results = [];
	      for (j = 0, len = list.length; j < len; j++) {
	        geometry = list[j];
	        results.push(this.planeView.addGeometry(geometry));
	      }
	      return results;
	    });
	    this.listenTo(this.sceneController, "removeGeometries", function(list) {
	      var geometry, j, len, results;
	      results = [];
	      for (j = 0, len = list.length; j < len; j++) {
	        geometry = list[j];
	        results.push(this.planeView.removeGeometry(geometry));
	      }
	      return results;
	    });
	    if (this.sceneController.skeleton) {
	      this.listenTo(this.sceneController.skeleton, "newGeometries", function(list) {
	        var geometry, j, len, results;
	        results = [];
	        for (j = 0, len = list.length; j < len; j++) {
	          geometry = list[j];
	          results.push(this.planeView.addGeometry(geometry));
	        }
	        return results;
	      });
	      return this.listenTo(this.sceneController.skeleton, "removeGeometries", function(list) {
	        var geometry, j, len, results;
	        results = [];
	        for (j = 0, len = list.length; j < len; j++) {
	          geometry = list[j];
	          results.push(this.planeView.removeGeometry(geometry));
	        }
	        return results;
	      });
	    }
	  };
	
	  PlaneController.prototype.render = function() {
	    var dataLayerName;
	    for (dataLayerName in this.model.binary) {
	      if (this.sceneController.pingDataLayer(dataLayerName)) {
	        this.model.binary[dataLayerName].ping(this.flycam.getPosition(), {
	          zoomStep: this.flycam.getIntegerZoomStep(),
	          area: this.flycam.getAreas(),
	          activePlane: this.activeViewport
	        });
	      }
	    }
	    this.cameraController.update();
	    return this.sceneController.update();
	  };
	
	  PlaneController.prototype.move = function(v, increaseSpeedWithZoom) {
	    var ref;
	    if (increaseSpeedWithZoom == null) {
	      increaseSpeedWithZoom = true;
	    }
	    if (ref = this.activeViewport, indexOf.call([0, 1, 2], ref) >= 0) {
	      return this.flycam.movePlane(v, this.activeViewport, increaseSpeedWithZoom);
	    } else {
	      return this.moveTDView({
	        x: -v[0],
	        y: -v[1]
	      });
	    }
	  };
	
	  PlaneController.prototype.moveX = function(x) {
	    return this.move([x, 0, 0]);
	  };
	
	  PlaneController.prototype.moveY = function(y) {
	    return this.move([0, y, 0]);
	  };
	
	  PlaneController.prototype.moveZ = function(z, oneSlide) {
	    if (this.activeViewport === constants.TDView) {
	      return;
	    }
	    if (oneSlide) {
	      return this.flycam.move(Dimensions.transDim([0, 0, (z < 0 ? -1 : 1) << this.flycam.getIntegerZoomStep()], this.activeViewport), this.activeViewport);
	    } else {
	      return this.move([0, 0, z], false);
	    }
	  };
	
	  PlaneController.prototype.zoom = function(value, zoomToMouse) {
	    var ref;
	    if (ref = this.activeViewport, indexOf.call([0, 1, 2], ref) >= 0) {
	      return this.zoomPlanes(value, zoomToMouse);
	    } else {
	      return this.zoomTDView(value, zoomToMouse);
	    }
	  };
	
	  PlaneController.prototype.zoomPlanes = function(value, zoomToMouse) {
	    if (zoomToMouse) {
	      this.zoomPos = this.getMousePosition();
	    }
	    this.flycam.zoomByDelta(value);
	    this.model.user.set("zoom", this.flycam.getPlaneScalingFactor());
	    if (zoomToMouse) {
	      return this.finishZoom();
	    }
	  };
	
	  PlaneController.prototype.zoomTDView = function(value, zoomToMouse) {
	    var zoomToPosition;
	    if (zoomToMouse) {
	      zoomToPosition = this.input.mouseControllers[constants.TDView].position;
	    }
	    return this.cameraController.zoomTDView(value, zoomToPosition, this.planeView.curWidth);
	  };
	
	  PlaneController.prototype.moveTDView = function(delta) {
	    this.cameraController.moveTDViewX(delta.x * this.model.user.getMouseInversionX());
	    return this.cameraController.moveTDViewY(delta.y * this.model.user.getMouseInversionY());
	  };
	
	  PlaneController.prototype.finishZoom = function() {
	    var mousePos, moveVector;
	    if (this.isMouseOver()) {
	      mousePos = this.getMousePosition();
	      moveVector = [this.zoomPos[0] - mousePos[0], this.zoomPos[1] - mousePos[1], this.zoomPos[2] - mousePos[2]];
	      return this.flycam.move(moveVector, this.activeViewport);
	    }
	  };
	
	  PlaneController.prototype.getMousePosition = function() {
	    var pos;
	    pos = this.input.mouseControllers[this.activeViewport].position;
	    return this.calculateGlobalPos(pos);
	  };
	
	  PlaneController.prototype.isMouseOver = function() {
	    return this.input.mouseControllers[this.activeViewport].isMouseOver;
	  };
	
	  PlaneController.prototype.changeMoveValue = function(delta) {
	    var moveValue;
	    moveValue = this.model.user.get("moveValue") + delta;
	    moveValue = Math.min(constants.MAX_MOVE_VALUE, moveValue);
	    moveValue = Math.max(constants.MIN_MOVE_VALUE, moveValue);
	    return this.model.user.set("moveValue", Number(moveValue));
	  };
	
	  PlaneController.prototype.scaleTrianglesPlane = function(delta) {
	    var scale;
	    scale = this.model.user.get("scale") + delta;
	    scale = Math.min(constants.MAX_SCALE, scale);
	    scale = Math.max(constants.MIN_SCALE, scale);
	    return this.model.user.set("scale", scale);
	  };
	
	  PlaneController.prototype.scrollPlanes = function(delta, type) {
	    switch (type) {
	      case null:
	        return this.moveZ(delta, true);
	      case "alt":
	        return this.zoomPlanes(Utils.clamp(-1, delta, 1), true);
	    }
	  };
	
	  PlaneController.prototype.calculateGlobalPos = function(clickPos) {
	    var curGlobalPos, planeRatio, position, scaleFactor, zoomFactor;
	    curGlobalPos = this.flycam.getPosition();
	    zoomFactor = this.flycam.getPlaneScalingFactor();
	    scaleFactor = this.planeView.scaleFactor;
	    planeRatio = app.scaleInfo.baseVoxelFactors;
	    return position = (function() {
	      switch (this.activeViewport) {
	        case constants.PLANE_XY:
	          return [curGlobalPos[0] - (constants.VIEWPORT_WIDTH * scaleFactor / 2 - clickPos.x) / scaleFactor * planeRatio[0] * zoomFactor, curGlobalPos[1] - (constants.VIEWPORT_WIDTH * scaleFactor / 2 - clickPos.y) / scaleFactor * planeRatio[1] * zoomFactor, curGlobalPos[2]];
	        case constants.PLANE_YZ:
	          return [curGlobalPos[0], curGlobalPos[1] - (constants.VIEWPORT_WIDTH * scaleFactor / 2 - clickPos.y) / scaleFactor * planeRatio[1] * zoomFactor, curGlobalPos[2] - (constants.VIEWPORT_WIDTH * scaleFactor / 2 - clickPos.x) / scaleFactor * planeRatio[2] * zoomFactor];
	        case constants.PLANE_XZ:
	          return [curGlobalPos[0] - (constants.VIEWPORT_WIDTH * scaleFactor / 2 - clickPos.x) / scaleFactor * planeRatio[0] * zoomFactor, curGlobalPos[1], curGlobalPos[2] - (constants.VIEWPORT_WIDTH * scaleFactor / 2 - clickPos.y) / scaleFactor * planeRatio[2] * zoomFactor];
	      }
	    }).call(this);
	  };
	
	  return PlaneController;
	
	})();
	
	module.exports = PlaneController;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var THREE = __webpack_require__(245);
	
	/**
	 * @author Eberhard Graether / http://egraether.com/
	 * @author Mark Lundin 	/ http://mark-lundin.com
	 */
	
	THREE.TrackballControls = function ( object, domElement, target, updateCallback ) {
	
		var _this = this;
		var STATE = { NONE: -1, PAN: 0, ZOOM: 1, ROTATE: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5 };
	
		this.object = object;
		this.domElement = ( domElement !== undefined ) ? domElement : document;
		this.updateCallback = updateCallback;
	
		// API
	
		this.enabled = true;
		this.keyboardEnabled = false;
	
		this.rotateSpeed = 1.0;
		this.zoomSpeed = 1.2;
		this.panSpeed = 0.3;
	
		this.noRotate = false;
		this.noZoom = false;
		this.noPan = false;
		this.noRoll = false;
	
		this.staticMoving = false;
		this.dynamicDampingFactor = 0.2;
	
		this.minDistance = 0;
		this.maxDistance = Infinity;
	
		this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];
	
		// internals
	
		this.target = target || new THREE.Vector3();
		this.lastTarget = this.target.clone();
	
		var lastPosition = new THREE.Vector3();
	
		var _state = STATE.NONE,
		_prevState = STATE.NONE,
	
		_eye = new THREE.Vector3(),
	
		_rotateStart = new THREE.Vector3(),
		_rotateEnd = new THREE.Vector3(),
	
		_zoomStart = new THREE.Vector2(),
		_zoomEnd = new THREE.Vector2(),
	
		_touchZoomDistanceStart = 0,
		_touchZoomDistanceEnd = 0,
	
		_panStart = new THREE.Vector2(),
		_panEnd = new THREE.Vector2();
	
		// for reset
	
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.up0 = this.object.up.clone();
	
		// events
	
		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start'};
		var endEvent = { type: 'end'};
	
	
		// methods
	
		this.getScreenBounds = function() {
			var clientRect = this.domElement.getBoundingClientRect();
			var d = this.domElement.ownerDocument.documentElement;
			return {
				top : clientRect.top + window.pageYOffset - d.clientTop,
				left : clientRect.left + window.pageXOffset - d.clientLeft,
				width : clientRect.width,
				height : clientRect.height
			};
		};
	
		this.handleEvent = function ( event ) {
	
			if ( typeof this[ event.type ] == 'function' ) {
	
				this[ event.type ]( event );
	
			}
	
		};
	
		this.getMouseOnScreen = function ( pageX, pageY, vector ) {
	
			var screenBounds = _this.getScreenBounds()
	
			return vector.set(
				( pageX - screenBounds.left ) / screenBounds.width,
				( pageY - screenBounds.top ) / screenBounds.height
			);
	
		};
	
		this.getMouseProjectionOnBall = (function(){
	
			var objectUp = new THREE.Vector3(),
			    mouseOnBall = new THREE.Vector3();
	
	
			return function ( pageX, pageY, projection ) {
	
				var screenBounds = _this.getScreenBounds()
	
				mouseOnBall.set(
					( pageX - screenBounds.width * 0.5 - screenBounds.left ) / (screenBounds.width*.5),
					( screenBounds.height * 0.5 + screenBounds.top - pageY ) / (screenBounds.height*.5),
					0.0
				);
	
				var length = mouseOnBall.length();
	
				if ( _this.noRoll ) {
	
					if ( length < Math.SQRT1_2 ) {
	
						mouseOnBall.z = Math.sqrt( 1.0 - length*length );
	
					} else {
	
						mouseOnBall.z = .5 / length;
	
					}
	
				} else if ( length > 1.0 ) {
	
					mouseOnBall.normalize();
	
				} else {
	
					mouseOnBall.z = Math.sqrt( 1.0 - length * length );
	
				}
	
				_eye.copy( _this.object.position ).sub( _this.target );
	
				projection.copy( _this.object.up ).setLength( mouseOnBall.y )
				projection.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
				projection.add( _eye.setLength( mouseOnBall.z ) );
	
				return projection;
			}
	
		}());
	
		this.rotateCamera = (function(){
	
			var axis = new THREE.Vector3(),
				quaternion = new THREE.Quaternion();
	
	
			return function () {
	
				var angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );
	
				if ( angle ) {
	
					axis.crossVectors( _rotateStart, _rotateEnd ).normalize();
	
					angle *= _this.rotateSpeed;
	
					quaternion.setFromAxisAngle( axis, -angle );
	
					_eye.applyQuaternion( quaternion );
					_this.object.up.applyQuaternion( quaternion );
	
					_rotateEnd.applyQuaternion( quaternion );
	
					if ( _this.staticMoving ) {
	
						_rotateStart.copy( _rotateEnd );
	
					} else {
	
						quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
						_rotateStart.applyQuaternion( quaternion );
	
					}
	
				}
			}
	
		}());
	
		this.zoomCamera = function () {
	
			if ( _state === STATE.TOUCH_ZOOM ) {
	
				var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
				_touchZoomDistanceStart = _touchZoomDistanceEnd;
				_eye.multiplyScalar( factor );
	
			} else {
	
				var factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;
	
				if ( factor !== 1.0 && factor > 0.0 ) {
	
					_eye.multiplyScalar( factor );
	
					if ( _this.staticMoving ) {
	
						_zoomStart.copy( _zoomEnd );
	
					} else {
	
						_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;
	
					}
	
				}
	
			}
	
		};
	
		this.panCamera = (function(){
	
			var mouseChange = new THREE.Vector2(),
				objectUp = new THREE.Vector3(),
				pan = new THREE.Vector3();
	
			return function () {
	
				mouseChange.copy( _panEnd ).sub( _panStart );
	
				if ( mouseChange.lengthSq() ) {
	
					mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );
	
					pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
					pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );
	
					_this.object.position.add( pan );
					_this.target.add( pan );
	
					if ( _this.staticMoving ) {
	
						_panStart.copy( _panEnd );
	
					} else {
	
						_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );
	
					}
	
				}
			}
	
		}());
	
		this.checkDistances = function () {
	
			if ( !_this.noZoom || !_this.noPan ) {
	
				if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {
	
					_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );
	
				}
	
				if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {
	
					_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );
	
				}
	
			}
	
		};
	
		this.update = function () {
	
			_eye.subVectors( _this.object.position, _this.lastTarget );
	
			if ( !_this.noRotate ) {
	
				_this.rotateCamera();
	
			}
	
			if ( !_this.noZoom ) {
	
				_this.zoomCamera();
	
			}
	
			if ( !_this.noPan ) {
	
				_this.panCamera();
	
			}
	
			_this.object.position.addVectors( _this.target, _eye );
	
			_this.checkDistances();
	
			_this.object.lookAt( _this.target );
	
			if ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {
	
				_this.dispatchEvent( changeEvent );
	
				lastPosition.copy( _this.object.position );
	
			}
	
			_this.lastTarget = _this.target.clone();
			_this.updateCallback();
	
		};
	
		this.reset = function () {
	
			_state = STATE.NONE;
			_prevState = STATE.NONE;
	
			_this.target.copy( _this.target0 );
			_this.object.position.copy( _this.position0 );
			_this.object.up.copy( _this.up0 );
	
			_eye.subVectors( _this.object.position, _this.target );
	
			_this.object.lookAt( _this.target );
	
			_this.dispatchEvent( changeEvent );
	
			lastPosition.copy( _this.object.position );
	
		};
	
		// listeners
	
		function keydown( event ) {
	
			if ( _this.enabled === false || _this.keyboardEnabled === false ) return;
	
			window.removeEventListener( 'keydown', keydown );
	
			_prevState = _state;
	
			if ( _state !== STATE.NONE ) {
	
				return;
	
			} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {
	
				_state = STATE.ROTATE;
	
			} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {
	
				_state = STATE.ZOOM;
	
			} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {
	
				_state = STATE.PAN;
	
			}
	
		}
	
		function keyup( event ) {
	
			if ( _this.enabled === false || _this.keyboardEnabled === false ) return;
	
			_state = _prevState;
	
			window.addEventListener( 'keydown', keydown, false );
	
		}
	
		function mousedown( event ) {
	
			if ( _this.enabled === false ) return;
	
			event.preventDefault();
			event.stopPropagation();
	
			if ( _state === STATE.NONE ) {
	
				_state = event.button;
	
			}
	
			if ( _state === STATE.ROTATE && !_this.noRotate ) {
	
				_this.getMouseProjectionOnBall( event.pageX, event.pageY, _rotateStart );
				_rotateEnd.copy(_rotateStart)
	
			} else if ( _state === STATE.ZOOM && !_this.noZoom ) {
	
				_this.getMouseOnScreen( event.pageX, event.pageY, _zoomStart );
				_zoomEnd.copy(_zoomStart);
	
			} else if ( _state === STATE.PAN && !_this.noPan ) {
	
				_this.getMouseOnScreen( event.pageX, event.pageY, _panStart );
				_panEnd.copy(_panStart)
	
			}
	
			document.addEventListener( 'mousemove', mousemove, false );
			document.addEventListener( 'mouseup', mouseup, false );
			_this.dispatchEvent( startEvent );
	
	
		}
	
		function mousemove( event ) {
	
			if ( _this.enabled === false ) return;
	
			event.preventDefault();
			event.stopPropagation();
	
			if ( _state === STATE.ROTATE && !_this.noRotate ) {
	
				_this.getMouseProjectionOnBall( event.pageX, event.pageY, _rotateEnd );
				_this.update();
	
			} else if ( _state === STATE.ZOOM && !_this.noZoom ) {
	
				_this.getMouseOnScreen( event.pageX, event.pageY, _zoomEnd );
				_this.update();
	
			} else if ( _state === STATE.PAN && !_this.noPan ) {
	
				_this.getMouseOnScreen( event.pageX, event.pageY, _panEnd );
				_this.update();
	
			}
	
		}
	
		function mouseup( event ) {
	
			if ( _this.enabled === false ) return;
	
			event.preventDefault();
			event.stopPropagation();
	
			_state = STATE.NONE;
	
			document.removeEventListener( 'mousemove', mousemove );
			document.removeEventListener( 'mouseup', mouseup );
			_this.dispatchEvent( endEvent );
	
		}
	
		function mousewheel( event ) {
	
			if ( _this.enabled === false ) return;
	
			event.preventDefault();
			event.stopPropagation();
	
			var delta = 0;
	
			if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9
	
				delta = event.wheelDelta / 40;
	
			} else if ( event.detail ) { // Firefox
	
				delta = - event.detail / 3;
	
			}
	
			_zoomStart.y += delta * 0.01;
			_this.dispatchEvent( startEvent );
			_this.dispatchEvent( endEvent );
	
		}
	
		function touchstart( event ) {
	
			if ( _this.enabled === false ) return;
	
			switch ( event.touches.length ) {
	
				case 1:
					_state = STATE.TOUCH_ROTATE;
					_rotateEnd.copy( _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateStart ));
					break;
	
				case 2:
					_state = STATE.TOUCH_ZOOM;
					var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
					var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
					_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );
					break;
	
				case 3:
					_state = STATE.TOUCH_PAN;
					_panEnd.copy( _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panStart ));
					break;
	
				default:
					_state = STATE.NONE;
	
			}
			_this.dispatchEvent( startEvent );
	
	
		}
	
		function touchmove( event ) {
	
			if ( _this.enabled === false ) return;
	
			event.preventDefault();
			event.stopPropagation();
	
			switch ( event.touches.length ) {
	
				case 1:
					_this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateEnd );
					break;
	
				case 2:
					var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
					var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
					_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy )
					break;
	
				case 3:
					_this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panEnd );
					break;
	
				default:
					_state = STATE.NONE;
	
			}
	
		}
	
		function touchend( event ) {
	
			if ( _this.enabled === false ) return;
	
			switch ( event.touches.length ) {
	
				case 1:
					_rotateStart.copy( _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateEnd ));
					break;
	
				case 2:
					_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
					break;
	
				case 3:
					_panStart.copy( _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panEnd ));
					break;
	
			}
	
			_state = STATE.NONE;
			_this.dispatchEvent( endEvent );
	
		}
	
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
	
		this.domElement.addEventListener( 'mousedown', mousedown, false );
	
		this.domElement.addEventListener( 'mousewheel', mousewheel, false );
		this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox
	
		this.domElement.addEventListener( 'touchstart', touchstart, false );
		this.domElement.addEventListener( 'touchend', touchend, false );
		this.domElement.addEventListener( 'touchmove', touchmove, false );
	
		window.addEventListener( 'keydown', keydown, false );
		window.addEventListener( 'keyup', keyup, false );
		this.update();
	
	};
	
	THREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
	


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, CameraController, Dimensions, Model, THREE, TWEEN, View, app, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	Model = __webpack_require__(266);
	
	View = __webpack_require__(306);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	THREE = __webpack_require__(245);
	
	TWEEN = __webpack_require__(248);
	
	CameraController = (function() {
	  CameraController.prototype.cameras = null;
	
	  CameraController.prototype.flycam = null;
	
	  CameraController.prototype.model = null;
	
	  function CameraController(cameras, flycam, model1) {
	    var cam, j, len, ref;
	    this.cameras = cameras;
	    this.flycam = flycam;
	    this.model = model1;
	    this.moveTDViewY = bind(this.moveTDViewY, this);
	    this.moveTDViewX = bind(this.moveTDViewX, this);
	    this.zoomTDView = bind(this.zoomTDView, this);
	    this.changeTDViewDiagonal = bind(this.changeTDViewDiagonal, this);
	    this.changeTDViewXZ = bind(this.changeTDViewXZ, this);
	    this.changeTDViewYZ = bind(this.changeTDViewYZ, this);
	    this.changeTDViewXY = bind(this.changeTDViewXY, this);
	    this.update = bind(this.update, this);
	    _.extend(this, Backbone.Events);
	    app.vent.on({
	      centerTDView: (function(_this) {
	        return function() {
	          return _this.centerTDView();
	        };
	      })(this)
	    });
	    this.updateCamViewport();
	    ref = this.cameras;
	    for (j = 0, len = ref.length; j < len; j++) {
	      cam = ref[j];
	      cam.near = -1000000;
	      cam.far = 1000000;
	    }
	    this.changeTDViewDiagonal(false);
	    this.bindToEvents();
	  }
	
	  CameraController.prototype.update = function() {
	    var cPos, gPos;
	    gPos = this.flycam.getPosition();
	    cPos = app.scaleInfo.voxelToNm(gPos);
	    this.cameras[constants.PLANE_XY].position = new THREE.Vector3(cPos[0], cPos[1], cPos[2]);
	    this.cameras[constants.PLANE_YZ].position = new THREE.Vector3(cPos[0], cPos[1], cPos[2]);
	    return this.cameras[constants.PLANE_XZ].position = new THREE.Vector3(cPos[0], cPos[1], cPos[2]);
	  };
	
	  CameraController.prototype.changeTDView = function(id, animate) {
	    var a1, a2, b, b1, b2, camera, d2, diagonal, distance, from, getConvertedPosition, ind, intersect, notify, offsetX, offsetY, padding, paddingTop, pos, positionOffset, prop, time, to, upVector, width, x1, x2, y1, y2, yOffset;
	    if (animate == null) {
	      animate = true;
	    }
	    camera = this.cameras[constants.TDView];
	    b = app.scaleInfo.voxelToNm(this.model.upperBoundary);
	    pos = app.scaleInfo.voxelToNm(this.model.flycam.getPosition());
	    time = 800;
	    to = {};
	    notify = (function(_this) {
	      return function() {
	        return _this.trigger("cameraPositionChanged");
	      };
	    })(this);
	    getConvertedPosition = (function(_this) {
	      return function() {
	        return app.scaleInfo.voxelToNm(_this.model.flycam.getPosition());
	      };
	    })(this);
	    from = {
	      notify: notify,
	      getConvertedPosition: getConvertedPosition,
	      upX: camera.up.x,
	      upY: camera.up.y,
	      upZ: camera.up.z,
	      camera: camera,
	      flycam: this.flycam,
	      dx: camera.position.x - pos[0],
	      dy: camera.position.y - pos[1],
	      dz: camera.position.z - pos[2],
	      l: camera.left,
	      r: camera.right,
	      t: camera.top,
	      b: camera.bottom
	    };
	    this.tween = new TWEEN.Tween(from);
	    if (id === constants.TDView) {
	      diagonal = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
	      padding = 0.05 * diagonal;
	      a1 = b[0];
	      b1 = -b[1];
	      x1 = 0;
	      y1 = b[1];
	      x2 = pos[0];
	      y2 = pos[1];
	      b2 = 1 / Math.sqrt(b1 * b1 / a1 / a1 + 1);
	      a2 = -b2 * b1 / a1;
	      d2 = (a1 / b1 * (y1 - y2) - x1 + x2) / (-a2 + a1 * b2 / b1);
	      intersect = [x2 + d2 * a2, y2 + d2 * b2];
	      distance = Dimensions.distance([x1, y1], intersect);
	      yOffset = pos[2] - b[2] / 2;
	      to = {
	        dx: b[1] / diagonal,
	        dy: b[0] / diagonal,
	        dz: -1 / 2,
	        upX: 0,
	        upY: 0,
	        upZ: -1,
	        l: -distance - padding,
	        r: diagonal - distance + padding,
	        t: diagonal / 2 + padding + yOffset,
	        b: -diagonal / 2 - padding + yOffset
	      };
	    } else {
	      ind = Dimensions.getIndices(id);
	      width = Math.max(b[ind[0]], b[ind[1]] * 1.12) * 1.1;
	      paddingTop = width * 0.12;
	      padding = width / 1.1 * 0.1 / 2;
	      offsetX = pos[ind[0]] + padding + (width - b[ind[0]]) / 2;
	      offsetY = pos[ind[1]] + paddingTop + padding;
	      positionOffset = [[0, 0, -1], [1, 0, 0], [0, 1, 0]];
	      upVector = [[0, -1, 0], [0, -1, 0], [0, 0, -1]];
	      to.dx = positionOffset[id][0];
	      to.dy = positionOffset[id][1];
	      to.dz = positionOffset[id][2];
	      to.upX = upVector[id][0];
	      to.upY = upVector[id][1];
	      to.upZ = upVector[id][2];
	      to.l = -offsetX;
	      to.t = offsetY;
	      to.r = to.l + width;
	      to.b = to.t - width;
	    }
	    if (animate) {
	      return this.tween.to(to, time).onUpdate(this.updateCameraTDView).start();
	    } else {
	      for (prop in from) {
	        if (to[prop] == null) {
	          to[prop] = from[prop];
	        }
	      }
	      return this.updateCameraTDView.call(to);
	    }
	  };
	
	  CameraController.prototype.degToRad = function(deg) {
	    return deg / 180 * Math.PI;
	  };
	
	  CameraController.prototype.changeTDViewXY = function() {
	    return this.changeTDView(constants.PLANE_XY);
	  };
	
	  CameraController.prototype.changeTDViewYZ = function() {
	    return this.changeTDView(constants.PLANE_YZ);
	  };
	
	  CameraController.prototype.changeTDViewXZ = function() {
	    return this.changeTDView(constants.PLANE_XZ);
	  };
	
	  CameraController.prototype.changeTDViewDiagonal = function(animate) {
	    if (animate == null) {
	      animate = true;
	    }
	    return this.changeTDView(constants.TDView, animate);
	  };
	
	  CameraController.prototype.updateCameraTDView = function() {
	    var p;
	    p = this.getConvertedPosition();
	    this.camera.position.set(this.dx + p[0], this.dy + p[1], this.dz + p[2]);
	    this.camera.left = this.l;
	    this.camera.right = this.r;
	    this.camera.top = this.t;
	    this.camera.bottom = this.b;
	    this.camera.up = new THREE.Vector3(this.upX, this.upY, this.upZ);
	    this.flycam.setRayThreshold(this.camera.right, this.camera.left);
	    this.camera.updateProjectionMatrix();
	    this.notify();
	    return app.vent.trigger("rerender");
	  };
	
	  CameraController.prototype.TDViewportSize = function() {
	    return this.cameras[constants.TDView].right - this.cameras[constants.TDView].left;
	  };
	
	  CameraController.prototype.zoomTDView = function(value, position, curWidth) {
	    var baseDiff, baseOffset, camera, factor, middleX, middleY, offsetX, offsetY, size;
	    camera = this.cameras[constants.TDView];
	    factor = Math.pow(0.9, value);
	    middleX = (camera.left + camera.right) / 2;
	    middleY = (camera.bottom + camera.top) / 2;
	    size = this.TDViewportSize();
	    baseOffset = factor * size / 2;
	    baseDiff = baseOffset - size / 2;
	    if (position != null) {
	      offsetX = (position.x / curWidth * 2 - 1) * (-baseDiff);
	      offsetY = (position.y / curWidth * 2 - 1) * (+baseDiff);
	    } else {
	      offsetX = offsetY = 0;
	    }
	    camera.left = middleX - baseOffset + offsetX;
	    camera.right = middleX + baseOffset + offsetX;
	    camera.top = middleY + baseOffset + offsetY;
	    camera.bottom = middleY - baseOffset + offsetY;
	    camera.updateProjectionMatrix();
	    this.flycam.setRayThreshold(camera.right, camera.left);
	    return app.vent.trigger("rerender");
	  };
	
	  CameraController.prototype.moveTDViewX = function(x) {
	    return this.moveTDViewRaw(new THREE.Vector2(x * this.TDViewportSize() / constants.VIEWPORT_WIDTH, 0));
	  };
	
	  CameraController.prototype.moveTDViewY = function(y) {
	    return this.moveTDViewRaw(new THREE.Vector2(0, -y * this.TDViewportSize() / constants.VIEWPORT_WIDTH));
	  };
	
	  CameraController.prototype.moveTDView = function(nmVector) {
	    var camera, rotation;
	    camera = this.cameras[constants.TDView];
	    rotation = THREE.Vector3.prototype.multiplyScalar.call(camera.rotation.clone(), -1);
	    rotation.order = rotation.order.split("").reverse().join("");
	    nmVector.applyEuler(rotation);
	    return this.moveTDViewRaw(nmVector);
	  };
	
	  CameraController.prototype.moveTDViewRaw = function(moveVector) {
	    var camera;
	    camera = this.cameras[constants.TDView];
	    camera.left += moveVector.x;
	    camera.right += moveVector.x;
	    camera.top += moveVector.y;
	    camera.bottom += moveVector.y;
	    camera.updateProjectionMatrix();
	    return app.vent.trigger("rerender");
	  };
	
	  CameraController.prototype.centerTDView = function() {
	    var camera;
	    camera = this.cameras[constants.TDView];
	    return this.moveTDViewRaw(new THREE.Vector2(-(camera.left + camera.right) / 2, -(camera.top + camera.bottom) / 2));
	  };
	
	  CameraController.prototype.setClippingDistance = function(value) {
	    this.camDistance = value;
	    return this.updateCamViewport();
	  };
	
	  CameraController.prototype.getClippingDistance = function(planeID) {
	    return this.camDistance * app.scaleInfo.voxelPerNM[planeID];
	  };
	
	  CameraController.prototype.updateCamViewport = function() {
	    var boundary, i, j, len, ref, scaleFactor;
	    scaleFactor = app.scaleInfo.baseVoxel;
	    boundary = constants.VIEWPORT_WIDTH / 2 * this.model.user.get("zoom");
	    ref = [constants.PLANE_XY, constants.PLANE_YZ, constants.PLANE_XZ];
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      this.cameras[i].near = -this.camDistance;
	      this.cameras[i].left = this.cameras[i].bottom = -boundary * scaleFactor;
	      this.cameras[i].right = this.cameras[i].top = boundary * scaleFactor;
	      this.cameras[i].updateProjectionMatrix();
	    }
	    return app.vent.trigger("rerender");
	  };
	
	  CameraController.prototype.bindToEvents = function() {
	    this.listenTo(this.model.user, "change:clippingDistance", function(model, value) {
	      return this.setClippingDistance(value);
	    });
	    return this.listenTo(this.model.user, "change:zoom", function(model, value) {
	      return this.updateCamViewport();
	    });
	  };
	
	  return CameraController;
	
	})();
	
	module.exports = CameraController;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Binary, ConnectionInfo, DatasetConfiguration, ErrorHandling, Flycam2d, Flycam3d, Model, Request, ScaleInfo, SkeletonTracing, Toast, User, VolumeTracing, _, app, constants,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Backbone = __webpack_require__(3);
	
	_ = __webpack_require__(2);
	
	app = __webpack_require__(48);
	
	Binary = __webpack_require__(267);
	
	SkeletonTracing = __webpack_require__(285);
	
	User = __webpack_require__(294);
	
	DatasetConfiguration = __webpack_require__(295);
	
	VolumeTracing = __webpack_require__(297);
	
	ConnectionInfo = __webpack_require__(302);
	
	ScaleInfo = __webpack_require__(303);
	
	Flycam2d = __webpack_require__(304);
	
	Flycam3d = __webpack_require__(305);
	
	constants = __webpack_require__(61);
	
	Request = __webpack_require__(17);
	
	Toast = __webpack_require__(18);
	
	ErrorHandling = __webpack_require__(5);
	
	Model = (function(superClass) {
	  extend(Model, superClass);
	
	  function Model() {
	    this.initialized = false;
	    Model.__super__.constructor.apply(this, arguments);
	  }
	
	  Model.prototype.fetch = function(options) {
	    var infoUrl;
	    if (this.get("controlMode") === constants.CONTROL_MODE_TRACE) {
	      infoUrl = location.pathname + "/info";
	    } else {
	      infoUrl = "/annotations/" + (this.get('tracingType')) + "/" + (this.get('tracingId')) + "/info";
	    }
	    return Request.receiveJSON(infoUrl).then((function(_this) {
	      return function(tracing) {
	        _this.set("datasetName", tracing.content.dataSet.name);
	        if (tracing.error) {
	          Toast.error(tracing.error);
	          return {
	            "error": true
	          };
	        } else if (!tracing.content.dataSet) {
	          Toast.error("Selected dataset doesn't exist");
	          return {
	            "error": true
	          };
	        } else if (!tracing.content.dataSet.dataLayers) {
	          if (_this.get("datasetName")) {
	            Toast.error("Please, double check if you have the dataset '" + (_this.get("datasetName")) + "' imported.");
	          } else {
	            Toast.error("Please, make sure you have a dataset imported.");
	          }
	          return {
	            "error": true
	          };
	        } else {
	          _this.user = new User();
	          _this.set("user", _this.user);
	          return _this.user.fetch().then(function() {
	            var colorLayers;
	            _this.set("dataset", new Backbone.Model(tracing.content.dataSet));
	            colorLayers = _.filter(_this.get("dataset").get("dataLayers"), function(layer) {
	              return layer.category === "color";
	            });
	            _this.set("datasetConfiguration", new DatasetConfiguration({
	              datasetName: _this.get("datasetName"),
	              dataLayerNames: _.pluck(colorLayers, "name")
	            }));
	            return _this.get("datasetConfiguration").fetch().then(function() {
	              var layers;
	              layers = _this.getLayers(tracing.content.contentData.customLayers);
	              return Promise.all(_this.getDataTokens(layers)).then(function() {
	                var error;
	                error = _this.initializeWithData(tracing, layers);
	                if (error) {
	                  return error;
	                }
	              });
	            }, function() {
	              return Toast.error("Ooops. We couldn't communicate with our mother ship. Please try to reload this page.");
	            });
	          });
	        }
	      };
	    })(this));
	  };
	
	  Model.prototype.determineAllowedModes = function() {
	    var allowedMode, allowedModes, j, len, modeId, ref, settings;
	    allowedModes = [];
	    settings = this.get("settings");
	    ref = settings.allowedModes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      allowedMode = ref[j];
	      if (this.getColorBinaries()[0].cube.BIT_DEPTH === 8) {
	        switch (allowedMode) {
	          case "flight":
	            allowedModes.push(constants.MODE_ARBITRARY);
	            break;
	          case "oblique":
	            allowedModes.push(constants.MODE_ARBITRARY_PLANE);
	        }
	      }
	      if (allowedMode === "orthogonal" || allowedMode === "volume") {
	        allowedModes.push(constants.MODE_NAME_TO_ID[allowedMode]);
	      }
	    }
	    if (settings.preferredMode) {
	      modeId = constants.MODE_NAME_TO_ID[settings.preferredMode];
	      if (indexOf.call(allowedModes, modeId) >= 0) {
	        this.set("preferredMode", modeId);
	      }
	    }
	    allowedModes.sort();
	    return allowedModes;
	  };
	
	  Model.prototype.initializeWithData = function(tracing, layers) {
	    var bb, dataset, flycam, flycam3d, isVolumeTracing, j, layer, len, maxLayerZoomStep, maxZoomStep, mode;
	    dataset = this.get("dataset");
	    ErrorHandling.assertExtendContext({
	      task: this.get("tracingId"),
	      dataSet: dataset.get("name")
	    });
	    console.log("tracing", tracing);
	    console.log("user", this.user);
	    isVolumeTracing = indexOf.call(tracing.content.settings.allowedModes, "volume") >= 0;
	    app.scaleInfo = new ScaleInfo(dataset.get("scale"));
	    if ((bb = tracing.content.boundingBox) != null) {
	      this.boundingBox = {
	        min: bb.topLeft,
	        max: [bb.topLeft[0] + bb.width, bb.topLeft[1] + bb.height, bb.topLeft[2] + bb.depth]
	      };
	    }
	    this.connectionInfo = new ConnectionInfo();
	    this.binary = {};
	    maxZoomStep = -Infinity;
	    for (j = 0, len = layers.length; j < len; j++) {
	      layer = layers[j];
	      layer.bitDepth = parseInt(layer.elementClass.substring(4));
	      maxLayerZoomStep = Math.log(Math.max.apply(Math, layer.resolutions)) / Math.LN2;
	      this.binary[layer.name] = new Binary(this, tracing, layer, maxLayerZoomStep, this.connectionInfo);
	      maxZoomStep = Math.max(maxZoomStep, maxLayerZoomStep);
	    }
	    this.buildMappingsObject(layers);
	    if (this.getColorBinaries().length === 0) {
	      Toast.error("No data available! Something seems to be wrong with the dataset.");
	      return {
	        "error": true
	      };
	    }
	    flycam = new Flycam2d(constants.PLANE_WIDTH, maxZoomStep + 1, this);
	    flycam3d = new Flycam3d(constants.DISTANCE_3D, dataset.get("scale"));
	    this.set("flycam", flycam);
	    this.set("flycam3d", flycam3d);
	    this.listenTo(flycam3d, "changed", (function(_this) {
	      return function(matrix, zoomStep) {
	        return flycam.setPosition(matrix.slice(12, 15));
	      };
	    })(this));
	    this.listenTo(flycam, {
	      "positionChanged": (function(_this) {
	        return function(position) {
	          return flycam3d.setPositionSilent(position);
	        };
	      })(this)
	    });
	    if (this.get("controlMode") === constants.CONTROL_MODE_TRACE) {
	      if (isVolumeTracing) {
	        ErrorHandling.assert(this.getSegmentationBinary() != null, "Volume is allowed, but segmentation does not exist");
	        this.set("volumeTracing", new VolumeTracing(tracing, flycam, flycam3d, this.getSegmentationBinary()));
	      } else {
	        this.set("skeletonTracing", new SkeletonTracing(tracing, flycam, flycam3d, this.user));
	      }
	    }
	    this.applyState(this.get("state"), tracing);
	    this.computeBoundaries();
	    this.set("tracing", tracing);
	    this.set("settings", tracing.content.settings);
	    this.set("allowedModes", this.determineAllowedModes());
	    if (this.get("allowedModes").length === 0) {
	      Toast.error("There was no valid allowed tracing mode specified.");
	    } else {
	      mode = this.get("preferredMode") || this.get("state").mode || this.get("allowedModes")[0];
	      this.setMode(mode);
	    }
	    this.initSettersGetter();
	    this.initialized = true;
	    this.trigger("sync");
	  };
	
	  Model.prototype.setMode = function(mode) {
	    this.set("mode", mode);
	    return this.trigger("change:mode", mode);
	  };
	
	  Model.prototype.buildMappingsObject = function(layers) {
	    var segmentationBinary;
	    segmentationBinary = this.getSegmentationBinary();
	    if (segmentationBinary != null) {
	      return window.mappings = {
	        getAll: (function(_this) {
	          return function() {
	            return segmentationBinary.mappings.getMappingNames();
	          };
	        })(this),
	        getActive: (function(_this) {
	          return function() {
	            return segmentationBinary.activeMapping;
	          };
	        })(this),
	        activate: (function(_this) {
	          return function(mapping) {
	            return segmentationBinary.setActiveMapping(mapping);
	          };
	        })(this)
	      };
	    }
	  };
	
	  Model.prototype.getDataTokens = function(layers) {
	    var dataStoreUrl, j, layer, len, results;
	    dataStoreUrl = this.get("dataset").get("dataStore").url;
	    results = [];
	    for (j = 0, len = layers.length; j < len; j++) {
	      layer = layers[j];
	      results.push((function(_this) {
	        return function(layer) {
	          return Request.receiveJSON("/dataToken/generate?dataSetName=" + (_this.get("datasetName")) + "&dataLayerName=" + layer.name).then(function(dataStore) {
	            layer.token = dataStore.token;
	            return layer.url = dataStoreUrl;
	          });
	        };
	      })(this)(layer));
	    }
	    return results;
	  };
	
	  Model.prototype.getColorBinaries = function() {
	    return _.filter(this.binary, function(binary) {
	      return binary.category === "color";
	    });
	  };
	
	  Model.prototype.getSegmentationBinary = function() {
	    return _.find(this.binary, function(binary) {
	      return binary.category === "segmentation";
	    });
	  };
	
	  Model.prototype.getLayers = function(userLayers) {
	    var j, layer, layers, len, userLayer;
	    layers = this.get("dataset").get("dataLayers");
	    if (userLayers == null) {
	      return layers;
	    }
	    for (j = 0, len = userLayers.length; j < len; j++) {
	      userLayer = userLayers[j];
	      layer = _.find(layers, function(layer) {
	        var ref;
	        return layer.name === ((ref = userLayer.fallback) != null ? ref.layerName : void 0);
	      });
	      if (layer != null) {
	        _.extend(layer, userLayer);
	      } else {
	        layers.push(userLayer);
	      }
	    }
	    return layers;
	  };
	
	  Model.prototype.canDisplaySegmentationData = function() {
	    return !this.flycam.getIntegerZoomStep() > 0 || !this.getSegmentationBinary();
	  };
	
	  Model.prototype.computeBoundaries = function() {
	    var binary, i, key, ref, results;
	    this.lowerBoundary = [Infinity, Infinity, Infinity];
	    this.upperBoundary = [-Infinity, -Infinity, -Infinity];
	    ref = this.binary;
	    results = [];
	    for (key in ref) {
	      binary = ref[key];
	      results.push((function() {
	        var j, results1;
	        results1 = [];
	        for (i = j = 0; j <= 2; i = ++j) {
	          this.lowerBoundary[i] = Math.min(this.lowerBoundary[i], binary.lowerBoundary[i]);
	          results1.push(this.upperBoundary[i] = Math.max(this.upperBoundary[i], binary.upperBoundary[i]));
	        }
	        return results1;
	      }).call(this));
	    }
	    return results;
	  };
	
	  Model.prototype.save = function() {
	    var promises, submodels;
	    submodels = [];
	    promises = [];
	    if (this.user != null) {
	      submodels.push[this.user];
	    }
	    if (this.get("dataset") != null) {
	      submodels.push[this.get("dataset")];
	    }
	    if (this.get("datasetConfiguration") != null) {
	      submodels.push[this.get("datasetConfiguration")];
	    }
	    if (this.get("volumeTracing") != null) {
	      submodels.push(this.get("volumeTracing").stateLogger);
	    }
	    if (this.get("skeletonTracing") != null) {
	      submodels.push(this.get("skeletonTracing").stateLogger);
	    }
	    _.each(submodels, function(model) {
	      return promises.push(model.save());
	    });
	    return Promise.all(promises).then(function() {
	      Toast.success("Saved!");
	      return Promise.resolve(arguments);
	    }, function() {
	      Toast.error("Couldn't save. Please try again.");
	      return Promise.reject(arguments);
	    });
	  };
	
	  Model.prototype.initSettersGetter = function() {
	    return _.forEach(this.attributes, (function(_this) {
	      return function(value, key, attribute) {
	        return Object.defineProperty(_this, key, {
	          set: function(val) {
	            return this.set(key, val);
	          },
	          get: function() {
	            return this.get(key);
	          }
	        });
	      };
	    })(this));
	  };
	
	  Model.prototype.applyState = function(state, tracing) {
	    var ref, rotation;
	    this.get("flycam").setPosition(state.position || tracing.content.editPosition);
	    if (state.zoomStep != null) {
	      this.get("user").set("zoom", Math.exp(Math.LN2 * state.zoomStep));
	      this.get("flycam3d").setZoomStep(state.zoomStep);
	    }
	    rotation = state.rotation || tracing.content.editRotation;
	    if (rotation != null) {
	      this.get("flycam3d").setRotation(rotation);
	    }
	    if (state.activeNode != null) {
	      return (ref = this.get("skeletonTracing")) != null ? ref.setActiveNode(state.activeNode) : void 0;
	    }
	  };
	
	  return Model;
	
	})(Backbone.Model);
	
	module.exports = Model;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, Binary, BoundingBox, Cube, InterpolationCollector, Mappings, PingStrategy, PingStrategy3d, Pipeline, Plane2D, PullQueue, PushQueue, constants;
	
	Backbone = __webpack_require__(3);
	
	InterpolationCollector = __webpack_require__(268);
	
	Cube = __webpack_require__(269);
	
	PullQueue = __webpack_require__(273);
	
	PushQueue = __webpack_require__(275);
	
	Plane2D = __webpack_require__(276);
	
	PingStrategy = __webpack_require__(278);
	
	PingStrategy3d = __webpack_require__(279);
	
	BoundingBox = __webpack_require__(281);
	
	Mappings = __webpack_require__(282);
	
	Pipeline = __webpack_require__(283);
	
	constants = __webpack_require__(61);
	
	Binary = (function() {
	  Binary.prototype.PING_THROTTLE_TIME = 50;
	
	  Binary.prototype.DIRECTION_VECTOR_SMOOTHER = .125;
	
	  Binary.prototype.TEXTURE_SIZE_P = 0;
	
	  Binary.prototype.cube = null;
	
	  Binary.prototype.pullQueue = null;
	
	  Binary.prototype.planes = [];
	
	  Binary.prototype.direction = [0, 0, 0];
	
	  function Binary(model1, tracing, layer, maxZoomStep, connectionInfo) {
	    var datasetName, depth, height, i, len, planeId, ref, ref1, ref2, topLeft, updatePipeline, width;
	    this.model = model1;
	    this.tracing = tracing;
	    this.layer = layer;
	    this.connectionInfo = connectionInfo;
	    _.extend(this, Backbone.Events);
	    this.TEXTURE_SIZE_P = constants.TEXTURE_SIZE_P;
	    ref = this.layer, this.category = ref.category, this.name = ref.name;
	    this.targetBitDepth = this.category === "color" ? this.layer.bitDepth : 8;
	    ref1 = this.layer.maxCoordinates, topLeft = ref1.topLeft, width = ref1.width, height = ref1.height, depth = ref1.depth;
	    this.lowerBoundary = topLeft;
	    this.upperBoundary = [topLeft[0] + width, topLeft[1] + height, topLeft[2] + depth];
	    this.cube = new Cube(this.upperBoundary, maxZoomStep + 1, this.layer.bitDepth);
	    this.boundingBox = new BoundingBox(this.model.boundingBox, this.cube);
	    updatePipeline = new Pipeline([this.tracing.version]);
	    datasetName = this.model.get("dataset").get("name");
	    this.pullQueue = new PullQueue(datasetName, this.cube, this.layer, this.boundingBox, this.connectionInfo);
	    this.pushQueue = new PushQueue(datasetName, this.cube, this.layer, this.tracing.id, updatePipeline);
	    this.cube.initializeWithQueues(this.pullQueue, this.pushQueue);
	    this.mappings = new Mappings(this.model.dataSetName, this.layer);
	    this.activeMapping = null;
	    this.pingStrategies = [new PingStrategy.Skeleton(this.cube, this.TEXTURE_SIZE_P), new PingStrategy.Volume(this.cube, this.TEXTURE_SIZE_P)];
	    this.pingStrategies3d = [new PingStrategy3d.DslSlow()];
	    this.planes = [];
	    ref2 = constants.ALL_PLANES;
	    for (i = 0, len = ref2.length; i < len; i++) {
	      planeId = ref2[i];
	      this.planes.push(new Plane2D(planeId, this.cube, this.pullQueue, this.TEXTURE_SIZE_P, this.layer.bitDepth, this.targetBitDepth, 32));
	    }
	    this.pullQueue.setFourBit(this.model.get("datasetConfiguration").get("fourBit"));
	    this.listenTo(this.model.get("datasetConfiguration"), "change:fourBit", function(model, fourBit) {
	      return this.pullQueue.setFourBit(fourBit);
	    });
	    this.cube.on({
	      newMapping: (function(_this) {
	        return function() {
	          return _this.forcePlaneRedraw();
	        };
	      })(this)
	    });
	    this.ping = _.throttle(this.pingImpl, this.PING_THROTTLE_TIME);
	  }
	
	  Binary.prototype.forcePlaneRedraw = function() {
	    var i, len, plane, ref, results;
	    ref = this.planes;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      plane = ref[i];
	      results.push(plane.forceRedraw());
	    }
	    return results;
	  };
	
	  Binary.prototype.setActiveMapping = function(mappingName) {
	    var setMapping;
	    this.activeMapping = mappingName;
	    setMapping = (function(_this) {
	      return function(mapping) {
	        _this.cube.setMapping(mapping);
	        return _this.model.flycam.update();
	      };
	    })(this);
	    if (mappingName != null) {
	      return this.mappings.getMappingArrayAsync(mappingName).then(setMapping);
	    } else {
	      return setMapping([]);
	    }
	  };
	
	  Binary.prototype.setActiveMapping = function(mappingName) {
	    var setMapping;
	    this.activeMapping = mappingName;
	    setMapping = (function(_this) {
	      return function(mapping) {
	        _this.cube.setMapping(mapping);
	        return _this.model.flycam.update();
	      };
	    })(this);
	    if (mappingName != null) {
	      return this.mappings.getMappingArrayAsync(mappingName).then(setMapping);
	    } else {
	      return setMapping([]);
	    }
	  };
	
	  Binary.prototype.pingStop = function() {
	    return this.pullQueue.clearNormalPriorities();
	  };
	
	  Binary.prototype.pingImpl = function(position, arg) {
	    var activePlane, area, i, len, ref, strategy, zoomStep;
	    zoomStep = arg.zoomStep, area = arg.area, activePlane = arg.activePlane;
	    if (this.lastPosition != null) {
	      this.direction = [(1 - this.DIRECTION_VECTOR_SMOOTHER) * this.direction[0] + this.DIRECTION_VECTOR_SMOOTHER * (position[0] - this.lastPosition[0]), (1 - this.DIRECTION_VECTOR_SMOOTHER) * this.direction[1] + this.DIRECTION_VECTOR_SMOOTHER * (position[1] - this.lastPosition[1]), (1 - this.DIRECTION_VECTOR_SMOOTHER) * this.direction[2] + this.DIRECTION_VECTOR_SMOOTHER * (position[2] - this.lastPosition[2])];
	    }
	    if (!(_.isEqual(position, this.lastPosition) && zoomStep === this.lastZoomStep && _.isEqual(area, this.lastArea))) {
	      this.lastPosition = position.slice();
	      this.lastZoomStep = zoomStep;
	      this.lastArea = area.slice();
	      ref = this.pingStrategies;
	      for (i = 0, len = ref.length; i < len; i++) {
	        strategy = ref[i];
	        if (strategy.forContentType(this.tracing.contentType) && strategy.inVelocityRange(this.connectionInfo.bandwidth) && strategy.inRoundTripTimeRange(this.connectionInfo.roundTripTime)) {
	          if ((zoomStep != null) && (area != null) && (activePlane != null)) {
	            this.pullQueue.clearNormalPriorities();
	            this.pullQueue.addAll(strategy.ping(position, this.direction, zoomStep, area, activePlane));
	          }
	          break;
	        }
	      }
	      return this.pullQueue.pull();
	    }
	  };
	
	  Binary.prototype.arbitraryPing = _.once(function(matrix) {
	    this.arbitraryPing = _.throttle(this.arbitraryPingImpl, this.PING_THROTTLE_TIME);
	    return this.arbitraryPing(matrix);
	  });
	
	  Binary.prototype.arbitraryPingImpl = function(matrix) {
	    var i, len, ref, strategy;
	    ref = this.pingStrategies3d;
	    for (i = 0, len = ref.length; i < len; i++) {
	      strategy = ref[i];
	      if (strategy.forContentType(this.tracing.contentType) && strategy.inVelocityRange(1) && strategy.inRoundTripTimeRange(this.pullQueue.roundTripTime)) {
	        this.pullQueue.clearNormalPriorities();
	        this.pullQueue.addAll(strategy.ping(matrix));
	        break;
	      }
	    }
	    return this.pullQueue.pull();
	  };
	
	  Binary.prototype.getByVerticesSync = function(vertices) {
	    var buffer, missingBuckets, ref;
	    ref = InterpolationCollector.bulkCollect(vertices, this.cube.getArbitraryCube()), buffer = ref.buffer, missingBuckets = ref.missingBuckets;
	    this.pullQueue.addAll(missingBuckets.map(function(bucket) {
	      return {
	        bucket: bucket,
	        priority: PullQueue.prototype.PRIORITY_HIGHEST
	      };
	    }));
	    this.pullQueue.pull();
	    return buffer;
	  };
	
	  return Binary;
	
	})();
	
	module.exports = Binary;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var InterpolationCollector, _, collectLoopMacro, pointIndexMacro, subPointMacro, templateFill, trilinearMacro;
	
	_ = __webpack_require__(2);
	
	templateFill = function(str, params) {
	  params.forEach(function(param) {
	    return str = str.replace(new RegExp("([^a-zA-Z0-9_])" + param + "([^a-zA-Z0-9_])", "gm"), function(match, pre, post) {
	      return pre + "<%= " + param + " %>" + post;
	    });
	  });
	  return str;
	};
	
	pointIndexMacro = _.template(templateFill("//-- pointIndexMacro(pointIndex, x, y, z, zoomStep)\ncoordMask = 31 << zoomStep;\n\npointIndex =\n  (\n    ((z & coordMask) << (10 - zoomStep)) +\n    ((y & coordMask) << (5 - zoomStep)) +\n    ((x & coordMask) >> (zoomStep))\n  ) >> 0;", ["pointIndex", "x", "y", "z", "zoomStep"]));
	
	subPointMacro = _.template("//-- subPointMacro(<%= output %>, <%= xd %>, <%= yd %>, <%= zd %>)\nbucketIndex = baseBucketIndex;\n\nsub_x = x0;\nsub_y = y0;\nsub_z = z0;\n\n// We use bitmasks to handle x, y and z coordinates.\n<% if (zd) { %>\n// `31     = 00000 00000 11111`\n  sub_z++;\n  if ((basePointIndex & 31744) == 31744) {\n\n    // The point seems to be at the right border.\n    bucketIndex++;\n\n    // Bound checking.\n    if (bucketIndex % sizeZ == 0)\n      continue;\n  }\n<% } %>\n\n<% if (yd) { %>\n// `992   = 00000 11111 00000`\n  sub_y++;\n  if ((basePointIndex & 992) == 992) {\n\n    // The point is to at the bottom border.\n    bucketIndex += sizeZ;\n\n    // Bound checking.\n    if (bucketIndex % sizeZY == 0)\n      continue;\n  }\n<% } %>\n\n<% if (xd) { %>\n// `31744 = 11111 00000 00000`\n  sub_x++;\n  if ((basePointIndex & 31) == 31) {\n    // The point seems to be at the back border.\n    bucketIndex += sizeZY;\n  }\n<% } %>\n\n\nif (bucketIndex == lastBucketIndex) {\n\n  <%= pointIndexMacro({ pointIndex : \"pointIndex\", x : \"sub_x\", y : \"sub_y\", z : \"sub_z\", zoomStep : \"lastBucketZoomStep\" }) %>\n\n  <%= output %> = lastBucket[pointIndex];\n\n} else if ((bucket = buckets.getBucket(bucketIndex)) != null) {\n\n  bucketZoomStep = bucket.zoomStep || 0;\n\n  <%= pointIndexMacro({ pointIndex : \"pointIndex\", x : \"sub_x\", y : \"sub_y\", z : \"sub_z\", zoomStep : \"bucketZoomStep\" }) %>\n\n  lastBucket = bucket;\n  lastBucketIndex = bucketIndex;\n  lastBucketZoomStep = bucketZoomStep;\n\n  <%= output %> = bucket[pointIndex];\n\n} else {\n  if(buckets.isValidBucket(bucketIndex) && missingBuckets.length < 100) {\n\n    missingBuckets.push([\n      Math.floor(bucketIndex / sizeZY),\n      Math.floor((bucketIndex % sizeZY) / sizeZ),\n      bucketIndex % sizeZ,\n      0\n    ])\n  }\n  continue;\n}", {
	  imports: {
	    pointIndexMacro: pointIndexMacro
	  }
	});
	
	trilinearMacro = _.template(templateFill("//-- trilinearMacro(output, p000, p100, p010, p110, p001, p101, p011, p111, d0, d1, d2)\n\noutput =\n  p000 * (1 - d0) * (1 - d1) * (1 - d2) +\n  p100 * d0 * (1 - d1) * (1 - d2) +\n  p010 * (1 - d0) * d1 * (1 - d2) +\n  p110 * d0 * d1 * (1 - d2) +\n  p001 * (1 - d0) * (1 - d1) * d2 +\n  p101 * d0 * (1 - d1) * d2 +\n  p011 * (1 - d0) * d1 * d2 +\n  p111 * d0 * d1 * d2;\n", ["output", "p000", "p100", "p010", "p110", "p001", "p101", "p011", "p111", "d0", "d1", "d2"]));
	
	collectLoopMacro = _.template(templateFill("//-- collectLoopMacro(x, y, z, buffer, j, buckets, min_x, min_y, min_z, max_x, max_y, max_z, sizeZ, sizeZY)\n\noutput0 = output1 = output2 = output3 = output4 = output5 = output6 = output7 = 0;\n\n// Cube bound checking is necessary.\nif (x < min_x || y < min_y || z < min_z || x > max_x || y > max_y || z > max_z)\n  continue;\n\n// Bitwise operations provide fast rounding of numbers.\nx0 = x >> 0; xd = x - x0;\ny0 = y >> 0; yd = y - y0;\nz0 = z >> 0; zd = z - z0;\n\nbaseBucketIndex =\n  ((x0 - min_x) >> 5) * sizeZY +\n  ((y0 - min_y) >> 5) * sizeZ +\n  ((z0 - min_z) >> 5);\n\nbasePointIndex =\n  ((z0 & 31) << 10) +\n  ((y0 & 31) << 5) +\n  ((x0 & 31));\n\n// trilinear x,y,z\n<%= subPointMacro({ output : \"output0\", xd : 0,  yd : 0,  zd : 0 }) %>\n<%= subPointMacro({ output : \"output1\", xd : 1,  yd : 0,  zd : 0 }) %>\n<%= subPointMacro({ output : \"output2\", xd : 0,  yd : 1,  zd : 0 }) %>\n<%= subPointMacro({ output : \"output3\", xd : 1,  yd : 1,  zd : 0 }) %>\n<%= subPointMacro({ output : \"output4\", xd : 0,  yd : 0,  zd : 1 }) %>\n<%= subPointMacro({ output : \"output5\", xd : 1,  yd : 0,  zd : 1 }) %>\n<%= subPointMacro({ output : \"output6\", xd : 0,  yd : 1,  zd : 1 }) %>\n<%= subPointMacro({ output : \"output7\", xd : 1,  yd : 1,  zd : 1 }) %>\n\n<%= trilinearMacro({\n  output : \"trilinearOutput\",\n  p000 : \"output0\",\n  p100 : \"output1\",\n  p010 : \"output2\",\n  p110 : \"output3\",\n  p001 : \"output4\",\n  p101 : \"output5\",\n  p011 : \"output6\",\n  p111 : \"output7\",\n  d0 : \"xd\",\n  d1 : \"yd\",\n  d2 : \"zd\"\n}) %>\nbuffer[j] = trilinearOutput;", ["x", "y", "z", "buffer", "j", "buckets", "min_x", "min_y", "min_z", "max_x", "max_y", "max_z", "sizeZ", "sizeZY"]), {
	  imports: {
	    trilinearMacro: trilinearMacro,
	    subPointMacro: subPointMacro
	  }
	});
	
	InterpolationCollector = {
	  bulkCollect: new Function("vertices", "buckets", _.template("var buffer = new Uint8Array(vertices.length / 3);\nvar missingBuckets = [];\nvar x, y, z;\nvar sub_x, sub_y, sub_z;\nvar output0, output1, output2, output3, output4, output5, output6, output7, x0, y0, z0, xd, yd, zd, baseBucketIndex, basePointIndex;\nvar coordMask, boundary;\nvar bucketZoomStep, bucket;\nvar sizeZ, sizeZY, lastBucket, lastBucketIndex, lastBucketZoomStep;\nvar bucketIndex, sub_x, sub_y, sub_Z;\nvar min_x, min_y, min_z, max_x, max_y, max_z;\nvar i, j;\n\nbuckets.reset();\n\nif (buckets) {\n\n  boundary = buckets.boundary;\n\n  sizeZ  = boundary[2];\n  sizeZY = boundary[2] * boundary[1];\n\n  min_x = 0; //cubeOffset[0] << 5;\n  min_y = 0; //cubeOffset[1] << 5;\n  min_z = 0; //cubeOffset[2] << 5;\n  max_x = min_x + (boundary[0] << 5) - 1;\n  max_y = min_y + (boundary[1] << 5) - 1;\n  max_z = min_z + (boundary[2] << 5) - 1;\n\n  lastBucket = null;\n  lastBucketIndex = -1;\n  lastBucketZoomStep = 0;\n\n  i = vertices.length;\n\n  j = -1;\n\n  while (i) {\n\n    z = vertices[--i];\n    y = vertices[--i];\n    x = vertices[--i];\n\n    j++;\n\n    <%= collectLoopMacro({\n      x : \"x\", y : \"y\", z : \"z\",\n      buffer : \"buffer\",\n      j : \"j\", buckets : \"buckets\",\n      min_x : \"min_x\", min_y : \"min_y\", min_z : \"min_z\",\n      max_x : \"max_x\", max_y : \"max_y\", max_z : \"max_z\",\n      sizeZ : \"sizeZ\", sizeZY : \"sizeZY\"\n    }) %>\n  }\n}\n\nreturn {\n  buffer : buffer,\n  missingBuckets : missingBuckets\n};\n\n//# sourceURL=/oxalis/model/binary/interpolation_collector/bulkCollect")({
	    collectLoopMacro: collectLoopMacro
	  }))
	};
	
	module.exports = InterpolationCollector;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var ArbitraryCubeAdapter, Backbone, Bucket, Cube, ErrorHandling, NullBucket, TemporalBucketManager, _, ref;
	
	Backbone = __webpack_require__(3);
	
	_ = __webpack_require__(2);
	
	ErrorHandling = __webpack_require__(5);
	
	ref = __webpack_require__(270), Bucket = ref.Bucket, NullBucket = ref.NullBucket;
	
	ArbitraryCubeAdapter = __webpack_require__(271);
	
	TemporalBucketManager = __webpack_require__(272);
	
	Cube = (function() {
	  Cube.prototype.BUCKET_SIZE_P = 5;
	
	  Cube.prototype.CUBE_SIZE_P = 7;
	
	  Cube.prototype.LOCAL_ID_SIZE_P = 16;
	
	  Cube.prototype.BUCKET_LENGTH = 0;
	
	  Cube.prototype.ZOOM_STEP_COUNT = 0;
	
	  Cube.prototype.LOOKUP_DEPTH_UP = 0;
	
	  Cube.prototype.LOOKUP_DEPTH_DOWN = 1;
	
	  Cube.prototype.MAXIMUM_BUCKET_COUNT = 5000;
	
	  Cube.prototype.ARBITRARY_MAX_ZOOMSTEP = 2;
	
	  Cube.prototype.EMPTY_MAPPING = null;
	
	  Cube.prototype.arbitraryCube = null;
	
	  Cube.prototype.dataCubes = null;
	
	  Cube.prototype.upperBoundary = null;
	
	  Cube.prototype.buckets = null;
	
	  Cube.prototype.bucketIterator = 0;
	
	  Cube.prototype.bucketCount = 0;
	
	  function Cube(upperBoundary, ZOOM_STEP_COUNT, BIT_DEPTH) {
	    var cubeBoundary, i, j, ref1;
	    this.upperBoundary = upperBoundary;
	    this.ZOOM_STEP_COUNT = ZOOM_STEP_COUNT;
	    this.BIT_DEPTH = BIT_DEPTH;
	    _.extend(this, Backbone.Events);
	    this.NULL_BUCKET = new NullBucket();
	    this.LOOKUP_DEPTH_UP = this.ZOOM_STEP_COUNT - 1;
	    this.MAX_ZOOM_STEP = this.ZOOM_STEP_COUNT - 1;
	    this.BUCKET_LENGTH = (1 << this.BUCKET_SIZE_P * 3) * (this.BIT_DEPTH >> 3);
	    this.BYTE_OFFSET = this.BIT_DEPTH >> 3;
	    this.cubes = [];
	    this.buckets = new Array(this.MAXIMUM_BUCKET_COUNT);
	    this.mapping = this.EMPTY_MAPPING;
	    this.currentMapping = this.mapping;
	    cubeBoundary = [Math.ceil(this.upperBoundary[0] / (1 << this.BUCKET_SIZE_P)), Math.ceil(this.upperBoundary[1] / (1 << this.BUCKET_SIZE_P)), Math.ceil(this.upperBoundary[2] / (1 << this.BUCKET_SIZE_P))];
	    this.arbitraryCube = new ArbitraryCubeAdapter(this, cubeBoundary.slice());
	    for (i = j = 0, ref1 = this.ZOOM_STEP_COUNT; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
	      this.cubes[i] = {};
	      this.cubes[i].data = new Array(cubeBoundary[0] * cubeBoundary[1] * cubeBoundary[2]);
	      this.cubes[i].boundary = cubeBoundary.slice();
	      cubeBoundary = [(cubeBoundary[0] + 1) >> 1, (cubeBoundary[1] + 1) >> 1, (cubeBoundary[2] + 1) >> 1];
	    }
	  }
	
	  Cube.prototype.initializeWithQueues = function(pullQueue, pushQueue) {
	    this.pullQueue = pullQueue;
	    this.pushQueue = pushQueue;
	    return this.temporalBucketManager = new TemporalBucketManager(this.pullQueue, this.pushQueue);
	  };
	
	  Cube.prototype.setMapping = function(mapping1) {
	    this.mapping = mapping1;
	    return this.trigger("mappingChanged");
	  };
	
	  Cube.prototype.setMappingEnabled = function(isEnabled) {
	    this.currentMapping = isEnabled ? this.mapping : this.EMPTY_MAPPING;
	    return this.trigger("newMapping");
	  };
	
	  Cube.prototype.hasMapping = function() {
	    return this.mapping != null;
	  };
	
	  Cube.prototype.setMapping = function(newMapping) {
	    if (this.currentMapping === this.mapping) {
	      this.currentMapping = newMapping;
	    }
	    this.mapping = newMapping;
	    return this.trigger("newMapping");
	  };
	
	  Cube.prototype.mapId = function(idToMap) {
	    var mappedId;
	    if ((this.currentMapping != null) && ((mappedId = this.currentMapping[idToMap]) != null)) {
	      return mappedId;
	    } else {
	      return idToMap;
	    }
	  };
	
	  Cube.prototype.getArbitraryCube = function() {
	    return this.arbitraryCube;
	  };
	
	  Cube.prototype.getVoxelIndexByVoxelOffset = function(arg) {
	    var x, y, z;
	    x = arg[0], y = arg[1], z = arg[2];
	    return x + y * (1 << this.BUCKET_SIZE_P) + z * (1 << this.BUCKET_SIZE_P * 2);
	  };
	
	  Cube.prototype.getBucketIndexByZoomedAddress = function(arg) {
	    var boundary, x, y, z, zoomStep;
	    x = arg[0], y = arg[1], z = arg[2], zoomStep = arg[3];
	    ErrorHandling.assertExists(this.cubes[zoomStep], "Cube for given zoomStep does not exist", {
	      cubeCount: this.cubes.length,
	      zoomStep: zoomStep,
	      zoomStepCount: this.ZOOM_STEP_COUNT
	    });
	    boundary = this.cubes[zoomStep].boundary;
	    if (x >= 0 && x < boundary[0] && y >= 0 && y < boundary[1] && z >= 0 && z < boundary[2]) {
	      return x * boundary[2] * boundary[1] + y * boundary[2] + z;
	    } else {
	      return void 0;
	    }
	  };
	
	  Cube.prototype.getBucketByZoomedAddress = function(address) {
	    var bucketIndex, cube;
	    if (address[3] >= this.ZOOM_STEP_COUNT) {
	      return this.NULL_BUCKET;
	    }
	    bucketIndex = this.getBucketIndexByZoomedAddress(address);
	    cube = this.cubes[address[3]].data;
	    if (bucketIndex != null) {
	      if (cube[bucketIndex] == null) {
	        cube[bucketIndex] = this.createBucket(address);
	      }
	      return cube[bucketIndex];
	    }
	    return this.NULL_BUCKET;
	  };
	
	  Cube.prototype.createBucket = function(address) {
	    var bucket;
	    bucket = new Bucket(this.BIT_DEPTH, address, this.temporalBucketManager);
	    bucket.on({
	      bucketLoaded: (function(_this) {
	        return function() {
	          return _this.trigger("bucketLoaded", address);
	        };
	      })(this)
	    });
	    this.addBucketToGarbageCollection(bucket);
	    return bucket;
	  };
	
	  Cube.prototype.addBucketToGarbageCollection = function(bucket) {
	    var i, j, ref1;
	    if (this.bucketCount >= this.MAXIMUM_BUCKET_COUNT) {
	      for (i = j = 0, ref1 = 2 * this.bucketCount; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
	        this.bucketIterator = ++this.bucketIterator % this.MAXIMUM_BUCKET_COUNT;
	        if (this.buckets[this.bucketIterator].shouldCollect()) {
	          break;
	        }
	      }
	      if (!this.buckets[this.bucketIterator].shouldCollect()) {
	        throw new Error("All buckets have shouldCollect == false permanently");
	      }
	      this.collectBucket(this.buckets[this.bucketIterator]);
	      this.bucketCount--;
	    }
	    this.bucketCount++;
	    this.buckets[this.bucketIterator] = bucket;
	    return this.bucketIterator = ++this.bucketIterator % this.MAXIMUM_BUCKET_COUNT;
	  };
	
	  Cube.prototype.collectBucket = function(bucket) {
	    var address, bucketIndex, cube;
	    address = bucket.zoomedAddress;
	    bucketIndex = this.getBucketIndexByZoomedAddress(address);
	    cube = this.cubes[address[3]].data;
	    return cube[bucketIndex] = null;
	  };
	
	  Cube.prototype.labelTestShape = function() {
	    var j, k, l, x, y, z;
	    for (x = j = 80; j <= 120; x = ++j) {
	      for (y = k = 80; k <= 120; y = ++k) {
	        for (z = l = 80; l <= 120; z = ++l) {
	          if (Math.sqrt((x - 100) * (x - 100) + (y - 100) * (y - 100) + (z - 100) * (z - 100)) <= 20) {
	            this.labelVoxel([x, y, z], 5);
	          }
	        }
	      }
	    }
	    return this.trigger("volumeLabeled");
	  };
	
	  Cube.prototype.labelVoxels = function(iterator, label) {
	    var voxel;
	    while (iterator.hasNext) {
	      voxel = iterator.getNext();
	      this.labelVoxel(voxel, label);
	    }
	    this.pushQueue.push();
	    return this.trigger("volumeLabeled");
	  };
	
	  Cube.prototype.labelVoxel = function(voxel, label) {
	    var bucket, i, j, labelFunc, ref1, ref2, voxelInCube, voxelIndex;
	    voxelInCube = true;
	    for (i = j = 0; j <= 2; i = ++j) {
	      voxelInCube &= (0 <= (ref1 = voxel[i]) && ref1 < this.upperBoundary[i]);
	    }
	    if (voxelInCube) {
	      ref2 = this.getBucketAndVoxelIndex(voxel, 0, true), bucket = ref2.bucket, voxelIndex = ref2.voxelIndex;
	      labelFunc = (function(_this) {
	        return function(data) {
	          var k, ref3, results;
	          results = [];
	          for (i = k = 0, ref3 = _this.BYTE_OFFSET; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
	            results.push(data[voxelIndex + i] = (label >> (i * 8)) & 0xff);
	          }
	          return results;
	        };
	      })(this);
	      bucket.label(labelFunc);
	      if (bucket.isLoaded()) {
	        return this.pushQueue.insert(this.positionToZoomedAddress(voxel));
	      }
	    }
	  };
	
	  Cube.prototype.getDataValue = function(voxel, mapping) {
	    var bucket, data, i, j, ref1, ref2, result, voxelIndex;
	    if (mapping == null) {
	      mapping = this.EMPTY_MAPPING;
	    }
	    ref1 = this.getBucketAndVoxelIndex(voxel, 0), bucket = ref1.bucket, voxelIndex = ref1.voxelIndex;
	    if (bucket.hasData()) {
	      data = bucket.getData();
	      result = 0;
	      for (i = j = 0, ref2 = this.BYTE_OFFSET; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
	        result += (1 << (8 * i)) * data[voxelIndex + i];
	      }
	      if ((mapping != null ? mapping[result] : void 0) != null) {
	        return mapping[result];
	      }
	      return result;
	    }
	    return 0;
	  };
	
	  Cube.prototype.getMappedDataValue = function(voxel) {
	    return this.getDataValue(voxel, this.currentMapping);
	  };
	
	  Cube.prototype.getBucketAndVoxelIndex = function(voxel, zoomStep, createBucketIfUndefined) {
	    var address, ref1, voxelIndex, x, y, z;
	    if (createBucketIfUndefined == null) {
	      createBucketIfUndefined = false;
	    }
	    address = this.positionToZoomedAddress(voxel, zoomStep);
	    ref1 = voxel.map(function(v) {
	      return v & 0x1f;
	    }), x = ref1[0], y = ref1[1], z = ref1[2];
	    voxelIndex = x + y * (1 << this.BUCKET_SIZE_P) + z * (1 << this.BUCKET_SIZE_P * 2);
	    return {
	      bucket: this.getBucketByZoomedAddress(address, createBucketIfUndefined),
	      voxelIndex: this.BYTE_OFFSET * voxelIndex
	    };
	  };
	
	  Cube.prototype.positionToZoomedAddress = function(arg, zoomStep) {
	    var x, y, z;
	    x = arg[0], y = arg[1], z = arg[2];
	    if (zoomStep == null) {
	      zoomStep = 0;
	    }
	    return [x >> this.BUCKET_SIZE_P + zoomStep, y >> this.BUCKET_SIZE_P + zoomStep, z >> this.BUCKET_SIZE_P + zoomStep, zoomStep];
	  };
	
	  return Cube;
	
	})();
	
	module.exports = Cube;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, Bucket, NullBucket, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Backbone = __webpack_require__(3);
	
	_ = __webpack_require__(2);
	
	Bucket = (function() {
	  Bucket.prototype.STATE_UNREQUESTED = 0;
	
	  Bucket.prototype.STATE_REQUESTED = 1;
	
	  Bucket.prototype.STATE_LOADED = 2;
	
	  Bucket.prototype.BUCKET_SIZE_P = 5;
	
	  function Bucket(BIT_DEPTH, zoomedAddress, temporalBucketManager) {
	    this.BIT_DEPTH = BIT_DEPTH;
	    this.zoomedAddress = zoomedAddress;
	    this.temporalBucketManager = temporalBucketManager;
	    _.extend(this, Backbone.Events);
	    this.BUCKET_LENGTH = (1 << this.BUCKET_SIZE_P * 3) * (this.BIT_DEPTH >> 3);
	    this.BYTE_OFFSET = this.BIT_DEPTH >> 3;
	    this.state = this.STATE_UNREQUESTED;
	    this.dirty = false;
	    this.accessed = true;
	    this.data = null;
	  }
	
	  Bucket.prototype.shouldCollect = function() {
	    var collect;
	    collect = !this.accessed && !this.dirty && this.state !== this.STATE_REQUESTED;
	    this.accessed = false;
	    return collect;
	  };
	
	  Bucket.prototype.needsRequest = function() {
	    return this.state === this.STATE_UNREQUESTED;
	  };
	
	  Bucket.prototype.isLoaded = function() {
	    return this.state === this.STATE_LOADED;
	  };
	
	  Bucket.prototype.label = function(labelFunc) {
	    labelFunc(this.getOrCreateData());
	    return this.dirty = true;
	  };
	
	  Bucket.prototype.hasData = function() {
	    return this.data != null;
	  };
	
	  Bucket.prototype.getData = function() {
	    if (this.data == null) {
	      throw new Error("Bucket.getData() called, but data does not exist.");
	    }
	    this.accessed = true;
	    return this.data;
	  };
	
	  Bucket.prototype.getOrCreateData = function() {
	    if (this.data == null) {
	      this.data = new Uint8Array(this.BUCKET_LENGTH);
	      this.temporalBucketManager.addBucket(this);
	    }
	    return this.getData();
	  };
	
	  Bucket.prototype.pull = function() {
	    return this.state = (function() {
	      switch (this.state) {
	        case this.STATE_UNREQUESTED:
	          return this.STATE_REQUESTED;
	        default:
	          return this.unexpectedState();
	      }
	    }).call(this);
	  };
	
	  Bucket.prototype.pullFailed = function() {
	    return this.state = (function() {
	      switch (this.state) {
	        case this.STATE_REQUESTED:
	          return this.STATE_UNREQUESTED;
	        default:
	          return this.unexpectedState();
	      }
	    }).call(this);
	  };
	
	  Bucket.prototype.receiveData = function(data) {
	    return this.state = (function() {
	      switch (this.state) {
	        case this.STATE_REQUESTED:
	          if (this.dirty) {
	            this.merge(data);
	          } else {
	            this.data = data;
	          }
	          this.trigger("bucketLoaded");
	          return this.STATE_LOADED;
	        default:
	          return this.unexpectedState();
	      }
	    }).call(this);
	  };
	
	  Bucket.prototype.push = function() {
	    switch (this.state) {
	      case this.STATE_LOADED:
	        return this.dirty = false;
	      default:
	        return this.unexpectedState();
	    }
	  };
	
	  Bucket.prototype.unexpectedState = function() {
	    throw new Error("Unexpected state: " + this.state);
	  };
	
	  Bucket.prototype.merge = function(newData) {
	    var i, j, k, oldVoxel, oldVoxelEmpty, ref, results, voxelPerBucket;
	    voxelPerBucket = 1 << this.BUCKET_SIZE_P * 3;
	    results = [];
	    for (i = k = 0, ref = voxelPerBucket; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
	      oldVoxel = (function() {
	        var l, ref1, results1;
	        results1 = [];
	        for (j = l = 0, ref1 = this.BYTE_OFFSET; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
	          results1.push(this.data[i * this.BYTE_OFFSET + j]);
	        }
	        return results1;
	      }).call(this);
	      oldVoxelEmpty = _.reduce(oldVoxel, ((function(_this) {
	        return function(memo, v) {
	          return memo && v === 0;
	        };
	      })(this)), true);
	      if (oldVoxelEmpty) {
	        results.push((function() {
	          var l, ref1, results1;
	          results1 = [];
	          for (j = l = 0, ref1 = this.BYTE_OFFSET; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
	            results1.push(this.data[i * this.BYTE_OFFSET + j] = newData[i * this.BYTE_OFFSET + j]);
	          }
	          return results1;
	        }).call(this));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  return Bucket;
	
	})();
	
	NullBucket = (function(superClass) {
	  extend(NullBucket, superClass);
	
	  function NullBucket() {
	    NullBucket.__super__.constructor.call(this, 0);
	    this.state = this.STATE_LOADED;
	  }
	
	  NullBucket.prototype.label = function(_) {};
	
	  return NullBucket;
	
	})(Bucket);
	
	module.exports = {
	  Bucket: Bucket,
	  NullBucket: NullBucket
	};


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	var ArbitraryCubeAdapter, _;
	
	_ = __webpack_require__(2);
	
	ArbitraryCubeAdapter = (function() {
	  ArbitraryCubeAdapter.prototype.ARBITRARY_MAX_ZOOMSTEP = 2;
	
	  function ArbitraryCubeAdapter(cube, boundary) {
	    this.cube = cube;
	    this.boundary = boundary;
	    this.sizeZYX = this.boundary[0] * this.boundary[1] * this.boundary[2];
	    this.sizeZY = this.boundary[1] * this.boundary[2];
	    this.sizeZ = this.boundary[2];
	  }
	
	  ArbitraryCubeAdapter.prototype.getBucket = _.memoize(function(bucketIndex) {
	    var bucketAddress, bucketData, i, ref, zoomStep;
	    if (!this.isValidBucket(bucketIndex)) {
	      return null;
	    }
	    bucketAddress = [Math.floor(bucketIndex / this.sizeZY), Math.floor((bucketIndex % this.sizeZY) / this.sizeZ), bucketIndex % this.sizeZ, 0];
	    for (zoomStep = i = 0, ref = this.ARBITRARY_MAX_ZOOMSTEP; 0 <= ref ? i <= ref : i >= ref; zoomStep = 0 <= ref ? ++i : --i) {
	      if (this.cube.getBucketByZoomedAddress(bucketAddress).hasData()) {
	        bucketData = this.cube.getBucketByZoomedAddress(bucketAddress).getData();
	        bucketData.zoomStep = zoomStep;
	        return bucketData;
	      }
	      bucketAddress = [bucketAddress[0] >> 1, bucketAddress[1] >> 1, bucketAddress[2] >> 1, bucketAddress[3] + 1];
	    }
	    return null;
	  });
	
	  ArbitraryCubeAdapter.prototype.isValidBucket = function(bucketIndex) {
	    return bucketIndex < this.sizeZYX;
	  };
	
	  ArbitraryCubeAdapter.prototype.reset = function() {
	    return this.getBucket.cache.__data__ = {};
	  };
	
	  return ArbitraryCubeAdapter;
	
	})();
	
	module.exports = ArbitraryCubeAdapter;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	var PullQueue, TemporalBucketManager, _;
	
	PullQueue = __webpack_require__(273);
	
	_ = __webpack_require__(2);
	
	TemporalBucketManager = (function() {
	  function TemporalBucketManager(pullQueue, pushQueue) {
	    this.pullQueue = pullQueue;
	    this.pushQueue = pushQueue;
	    this.loadedPromises = [];
	  }
	
	  TemporalBucketManager.prototype.getCount = function() {
	    return this.loadedPromises.length;
	  };
	
	  TemporalBucketManager.prototype.addBucket = function(bucket) {
	    this.pullBucket(bucket);
	    return this.loadedPromises.push(this.makeLoadedPromise(bucket));
	  };
	
	  TemporalBucketManager.prototype.pullBucket = function(bucket) {
	    this.pullQueue.add({
	      bucket: bucket.zoomedAddress,
	      priority: PullQueue.prototype.PRIORITY_HIGHEST
	    });
	    return this.pullQueue.pull();
	  };
	
	  TemporalBucketManager.prototype.makeLoadedPromise = function(bucket) {
	    var loadedPromise;
	    loadedPromise = new Promise((function(_this) {
	      return function(resolve, reject) {
	        return bucket.on("bucketLoaded", function() {
	          if (bucket.dirty) {
	            _this.pushQueue.insert(bucket.zoomedAddress);
	          }
	          _.removeElement(_this.loadedPromises, loadedPromise);
	          return resolve();
	        });
	      };
	    })(this));
	    return loadedPromise;
	  };
	
	  TemporalBucketManager.prototype.getAllLoadedPromise = function() {
	    return Promise.all(this.loadedPromises);
	  };
	
	  return TemporalBucketManager;
	
	})();
	
	module.exports = TemporalBucketManager;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	var Cube, MultipartData, PullQueue, Request, _;
	
	_ = __webpack_require__(2);
	
	Cube = __webpack_require__(269);
	
	Request = __webpack_require__(17);
	
	MultipartData = __webpack_require__(274);
	
	PullQueue = (function() {
	  PullQueue.prototype.BATCH_LIMIT = 6;
	
	  PullQueue.prototype.BATCH_SIZE = 3;
	
	  PullQueue.prototype.MESSAGE_TIMEOUT = 10000;
	
	  PullQueue.prototype.PRIORITY_HIGHEST = -1;
	
	  PullQueue.prototype.cube = null;
	
	  PullQueue.prototype.queue = null;
	
	  PullQueue.prototype.dataSetName = "";
	
	  PullQueue.prototype.batchCount = 0;
	
	  PullQueue.prototype.roundTripTime = 0;
	
	  function PullQueue(dataSetName, cube, layer, boundingBox, connectionInfo) {
	    this.dataSetName = dataSetName;
	    this.cube = cube;
	    this.layer = layer;
	    this.boundingBox = boundingBox;
	    this.connectionInfo = connectionInfo;
	    this.queue = [];
	    this.url = this.layer.url + "/data/datasets/" + this.dataSetName + "/layers/" + this.layer.name + "/data?cubeSize=" + (1 << this.cube.BUCKET_SIZE_P) + "&token=" + this.layer.token;
	  }
	
	  PullQueue.prototype.pull = function() {
	    var address, batch, bucket, results;
	    this.queue = _.filter(this.queue, (function(_this) {
	      return function(item) {
	        return _this.boundingBox.containsBucket(item.bucket) && _this.cube.getBucketByZoomedAddress(item.bucket).needsRequest();
	      };
	    })(this));
	    this.queue = _.sortBy(this.queue, function(item) {
	      return item.priority;
	    });
	    results = [];
	    while (this.batchCount < this.BATCH_LIMIT && this.queue.length) {
	      batch = [];
	      while (batch.length < this.BATCH_SIZE && this.queue.length) {
	        address = this.queue.shift().bucket;
	        bucket = this.cube.getBucketByZoomedAddress(address);
	        if (!bucket.needsRequest()) {
	          continue;
	        }
	        batch.push(address);
	        bucket.pull();
	      }
	      if (batch.length > 0) {
	        results.push(this.pullBatch(batch));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  PullQueue.prototype.pullBatch = function(batch) {
	    var bucket, j, len, requestData, roundTripBeginTime, zoomStep;
	    this.batchCount++;
	    requestData = new MultipartData();
	    for (j = 0, len = batch.length; j < len; j++) {
	      bucket = batch[j];
	      zoomStep = bucket[3];
	      requestData.addPart({
	        "X-Bucket": JSON.stringify({
	          position: [bucket[0] << (zoomStep + this.cube.BUCKET_SIZE_P), bucket[1] << (zoomStep + this.cube.BUCKET_SIZE_P), bucket[2] << (zoomStep + this.cube.BUCKET_SIZE_P)],
	          zoomStep: zoomStep,
	          cubeSize: 1 << this.cube.BUCKET_SIZE_P,
	          fourBit: this.shouldRequestFourBit()
	        })
	      });
	    }
	    roundTripBeginTime = new Date();
	    return Request.always(requestData.dataPromise().then((function(_this) {
	      return function(data) {
	        return Request.sendArraybufferReceiveArraybuffer(_this.layer.url + "/data/datasets/" + _this.dataSetName + "/layers/" + _this.layer.name + "/data?token=" + _this.layer.token, {
	          data: data,
	          headers: {
	            "Content-Type": "multipart/mixed; boundary=" + requestData.boundary
	          },
	          timeout: _this.MESSAGE_TIMEOUT,
	          compress: true
	        });
	      };
	    })(this)).then((function(_this) {
	      return function(responseBuffer) {
	        var bucketData, i, k, len1, offset, results;
	        responseBuffer = new Uint8Array(responseBuffer);
	        _this.connectionInfo.log(_this.layer.name, roundTripBeginTime, batch.length, responseBuffer.length);
	        offset = 0;
	        results = [];
	        for (i = k = 0, len1 = batch.length; k < len1; i = ++k) {
	          bucket = batch[i];
	          if (bucket.fourBit) {
	            bucketData = _this.decode4bit(responseBuffer.subarray(offset, offset += _this.cube.BUCKET_LENGTH >> 1));
	          } else {
	            bucketData = responseBuffer.subarray(offset, offset += _this.cube.BUCKET_LENGTH);
	          }
	          _this.boundingBox.removeOutsideArea(bucket, bucketData);
	          results.push(_this.cube.getBucketByZoomedAddress(bucket).receiveData(bucketData));
	        }
	        return results;
	      };
	    })(this))["catch"]((function(_this) {
	      return function() {
	        var bucketAddress, k, len1, results;
	        results = [];
	        for (k = 0, len1 = batch.length; k < len1; k++) {
	          bucketAddress = batch[k];
	          bucket = _this.cube.getBucketByZoomedAddress(bucketAddress);
	          bucket.pullFailed();
	          if (bucket.dirty) {
	            results.push(_this.add({
	              bucket: bucketAddress,
	              priority: _this.PRIORITY_HIGHEST
	            }));
	          } else {
	            results.push(void 0);
	          }
	        }
	        return results;
	      };
	    })(this)), (function(_this) {
	      return function() {
	        _this.batchCount--;
	        return _this.pull();
	      };
	    })(this));
	  };
	
	  PullQueue.prototype.clearNormalPriorities = function() {
	    return this.queue = _.filter(this.queue, (function(_this) {
	      return function(e) {
	        return e.priority === _this.PRIORITY_HIGHEST;
	      };
	    })(this));
	  };
	
	  PullQueue.prototype.add = function(item) {
	    return this.queue.push(item);
	  };
	
	  PullQueue.prototype.addAll = function(items) {
	    return this.queue = this.queue.concat(items);
	  };
	
	  PullQueue.prototype.decode4Bit = function(colors) {
	    var index, newColors, value;
	    newColors = new Uint8Array(colors.length << 1);
	    index = 0;
	    while (index < newColors.length) {
	      value = colors[index >> 1];
	      newColors[index] = value & 0xf0;
	      index++;
	      newColors[index] = value << 4;
	      index++;
	    }
	    return newColors;
	  };
	
	  PullQueue.prototype.setFourBit = function(fourBit) {
	    this.fourBit = fourBit;
	  };
	
	  PullQueue.prototype.shouldRequestFourBit = function() {
	    return this.fourBit && this.layer.category === "color";
	  };
	
	  return PullQueue;
	
	})();
	
	module.exports = PullQueue;


/***/ },
/* 274 */
/***/ function(module, exports) {

	var MultipartData;
	
	MultipartData = (function() {
	  MultipartData.prototype.randomBoundary = function() {
	    return '--multipart-boundary--xxxxxxxxxxxxxxxxxxxxxxxx--'.replace(/[x]/g, function() {
	      return (Math.random() * 16 | 0).toString(16);
	    });
	  };
	
	  function MultipartData(boundary) {
	    this.boundary = boundary;
	    this.boundary = this.boundary || this.randomBoundary();
	    this.data = ['--' + this.boundary + '\r\n'];
	  }
	
	  MultipartData.prototype.addPart = function(headers, body) {
	    var name, value;
	    for (name in headers) {
	      value = headers[name];
	      this.data.push(name + ': ' + value + '\r\n');
	    }
	    this.data.push('\r\n');
	    if (body != null) {
	      this.data.push(body);
	    }
	    return this.data.push('\r\n--' + this.boundary + '\r\n');
	  };
	
	  MultipartData.prototype.dataPromise = function() {
	    return new Promise((function(_this) {
	      return function(resolve) {
	        var reader;
	        reader = new FileReader();
	        reader.onload = function(e) {
	          return resolve(e.target.result);
	        };
	        return reader.readAsArrayBuffer(new Blob(_this.data));
	      };
	    })(this));
	  };
	
	  return MultipartData;
	
	})();
	
	module.exports = MultipartData;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Cube, MultipartData, PushQueue, Request,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	Cube = __webpack_require__(269);
	
	Request = __webpack_require__(17);
	
	MultipartData = __webpack_require__(274);
	
	PushQueue = (function() {
	  PushQueue.prototype.BATCH_LIMIT = 1;
	
	  PushQueue.prototype.BATCH_SIZE = 32;
	
	  PushQueue.prototype.DEBOUNCE_TIME = 1000;
	
	  PushQueue.prototype.MESSAGE_TIMEOUT = 10000;
	
	  function PushQueue(dataSetName, cube, layer, tracingId, updatePipeline, sendData) {
	    this.dataSetName = dataSetName;
	    this.cube = cube;
	    this.layer = layer;
	    this.tracingId = tracingId;
	    this.updatePipeline = updatePipeline;
	    this.sendData = sendData != null ? sendData : true;
	    this.pushImpl = bind(this.pushImpl, this);
	    this.url = this.layer.url + "/data/datasets/" + this.dataSetName + "/layers/" + this.layer.name + "/data?cubeSize=" + (1 << this.cube.BUCKET_SIZE_P) + "&annotationId=" + this.tracingId + "&token=" + this.layer.token;
	    this.queue = [];
	    this.push = _.debounce(this.pushImpl, this.DEBOUNCE_TIME);
	  }
	
	  PushQueue.prototype.insert = function(bucket) {
	    this.queue.push(bucket);
	    this.removeDuplicates();
	    return this.push();
	  };
	
	  PushQueue.prototype.insertFront = function(bucket) {
	    this.queue.unshift(bucket);
	    this.removeDuplicates();
	    return this.push();
	  };
	
	  PushQueue.prototype.clear = function() {
	    return this.queue = [];
	  };
	
	  PushQueue.prototype.removeDuplicates = function() {
	    var i, results;
	    this.queue.sort(this.comparePositions);
	    i = 0;
	    results = [];
	    while (i < this.queue.length - 1) {
	      if (this.comparePositions(this.queue[i], this.queue[i + 1]) === 0) {
	        results.push(this.queue.splice(i, 1));
	      } else {
	        results.push(i++);
	      }
	    }
	    return results;
	  };
	
	  PushQueue.prototype.comparePositions = function(arg, arg1) {
	    var x1, x2, y1, y2, z1, z2;
	    x1 = arg[0], y1 = arg[1], z1 = arg[2];
	    x2 = arg1[0], y2 = arg1[1], z2 = arg1[2];
	    return (x1 - x2) || (y1 - y2) || (z1 - z2);
	  };
	
	  PushQueue.prototype.print = function() {
	    var e, j, len, ref, results;
	    ref = this.queue;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      e = ref[j];
	      results.push(console.log(e));
	    }
	    return results;
	  };
	
	  PushQueue.prototype.pushImpl = function() {
	    return this.cube.temporalBucketManager.getAllLoadedPromise().then((function(_this) {
	      return function() {
	        var batch, batchSize;
	        if (!_this.sendData) {
	          return Promise.resolve();
	        }
	        while (_this.queue.length) {
	          batchSize = Math.min(_this.BATCH_SIZE, _this.queue.length);
	          batch = _this.queue.splice(0, batchSize);
	          _this.pushBatch(batch);
	        }
	        return _this.updatePipeline.getLastActionPromise();
	      };
	    })(this));
	  };
	
	  PushQueue.prototype.pushBatch = function(batch) {
	    var bucket, j, len, transmitData, zoomStep;
	    transmitData = new MultipartData();
	    for (j = 0, len = batch.length; j < len; j++) {
	      bucket = batch[j];
	      zoomStep = bucket[3];
	      transmitData.addPart({
	        "X-Bucket": JSON.stringify({
	          position: [bucket[0] << (zoomStep + this.cube.BUCKET_SIZE_P), bucket[1] << (zoomStep + this.cube.BUCKET_SIZE_P), bucket[2] << (zoomStep + this.cube.BUCKET_SIZE_P)],
	          zoomStep: zoomStep,
	          cubeSize: 1 << this.cube.BUCKET_SIZE_P
	        })
	      }, this.cube.getBucketByZoomedAddress(bucket).getData());
	    }
	    return this.updatePipeline.executePassAlongAction((function(_this) {
	      return function() {
	        return transmitData.dataPromise().then(function(data) {
	          return Request.sendArraybufferReceiveArraybuffer(_this.layer.url + "/data/datasets/" + _this.dataSetName + "/layers/" + _this.layer.name + "/data?token=" + _this.layer.token, {
	            method: "PUT",
	            data: data,
	            headers: {
	              "Content-Type": "multipart/mixed; boundary=" + transmitData.boundary
	            },
	            timeout: _this.MESSAGE_TIMEOUT,
	            compress: true
	          });
	        });
	      };
	    })(this)).then(void 0, function(err) {
	      throw new Error("Uploading data failed.", err);
	      return Promise.reject(err);
	    });
	  };
	
	  return PushQueue;
	
	})();
	
	module.exports = PushQueue;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, Cube, Dimensions, Plane2D, Queue, bufferOffsetByTileMacro, subTileMacro, tileIndexByTileMacro,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Backbone = __webpack_require__(3);
	
	Cube = __webpack_require__(269);
	
	Queue = __webpack_require__(273);
	
	Dimensions = __webpack_require__(277);
	
	tileIndexByTileMacro = function(_this, tile) {
	  return tile[0] * (1 << _this.TEXTURE_SIZE_P - _this.cube.BUCKET_SIZE_P) + tile[1];
	};
	
	subTileMacro = function(tile, index) {
	  return [(tile[0] << 1) + (index % 2), (tile[1] << 1) + (index >> 1)];
	};
	
	bufferOffsetByTileMacro = function(_this, tile, tileSize) {
	  return tile[0] * (1 << tileSize) + tile[1] * (1 << tileSize) * (1 << _this.TEXTURE_SIZE_P);
	};
	
	Plane2D = (function() {
	  Plane2D.prototype.TEXTURE_SIZE_P = 0;
	
	  Plane2D.prototype.BUCKETS_PER_ROW = 0;
	
	  Plane2D.prototype.MAP_SIZE = 0;
	
	  Plane2D.prototype.RECURSION_PLACEHOLDER = {};
	
	  Plane2D.prototype.DELTA = [0, 5, 10];
	
	  Plane2D.prototype.U = 0;
	
	  Plane2D.prototype.V = 0;
	
	  Plane2D.prototype.W = 0;
	
	  Plane2D.prototype.cube = null;
	
	  Plane2D.prototype.queue = null;
	
	  Plane2D.prototype.dataTexture = null;
	
	  function Plane2D(index, cube, queue, TEXTURE_SIZE_P, DATA_BIT_DEPTH, TEXTURE_BIT_DEPTH, MAPPED_DATA_BIT_DEPTH) {
	    var i, j, ref, ref1;
	    this.cube = cube;
	    this.queue = queue;
	    this.TEXTURE_SIZE_P = TEXTURE_SIZE_P;
	    this.DATA_BIT_DEPTH = DATA_BIT_DEPTH;
	    this.TEXTURE_BIT_DEPTH = TEXTURE_BIT_DEPTH;
	    this.MAPPED_DATA_BIT_DEPTH = MAPPED_DATA_BIT_DEPTH;
	    _.extend(this, Backbone.Events);
	    this.BUCKETS_PER_ROW = 1 << (this.TEXTURE_SIZE_P - this.cube.BUCKET_SIZE_P);
	    this.TEXTURE_SIZE = (1 << (this.TEXTURE_SIZE_P << 1)) * (this.TEXTURE_BIT_DEPTH >> 3);
	    this._forceRedraw = false;
	    for (i = j = 0, ref = this.cube.LOOKUP_DEPTH_DOWN; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
	      this.MAP_SIZE += 1 << (i << 1);
	    }
	    ref1 = Dimensions.getIndices(index), this.U = ref1[0], this.V = ref1[1], this.W = ref1[2];
	    this.dataTexture = {
	      renderTile: this.renderDataTile
	    };
	    this.listenTo(this.cube, "bucketLoaded", function(bucket) {
	      var k, l, m, n, ref2, ref3, ref4, ref5, ref6, ref7, results, results1, results2, results3, tile, u, v, zoomStepDiff;
	      zoomStepDiff = this.dataTexture.zoomStep - bucket[3];
	      if (zoomStepDiff > 0) {
	        bucket = [bucket[0] >> zoomStepDiff, bucket[1] >> zoomStepDiff, bucket[2] >> zoomStepDiff, this.dataTexture.zoomStep];
	      }
	      if (this.dataTexture.layer >> (this.cube.BUCKET_SIZE_P + bucket[3]) === bucket[this.W] && (this.dataTexture.topLeftBucket != null)) {
	        u = bucket[this.U] - this.dataTexture.topLeftBucket[this.U];
	        v = bucket[this.V] - this.dataTexture.topLeftBucket[this.V];
	        if (indexOf.call((function() {
	          results = [];
	          for (var k = 0, ref2 = this.BUCKETS_PER_ROW; 0 <= ref2 ? k < ref2 : k > ref2; 0 <= ref2 ? k++ : k--){ results.push(k); }
	          return results;
	        }).apply(this), u) >= 0 && indexOf.call((function() {
	          results1 = [];
	          for (var l = 0, ref3 = this.BUCKETS_PER_ROW; 0 <= ref3 ? l < ref3 : l > ref3; 0 <= ref3 ? l++ : l--){ results1.push(l); }
	          return results1;
	        }).apply(this), v) >= 0) {
	          tile = [u, v];
	          this.dataTexture.tiles[tileIndexByTileMacro(this, tile)] = false;
	          return this.dataTexture.ready &= !(indexOf.call((function() {
	            results2 = [];
	            for (var m = ref4 = this.dataTexture.area[0], ref5 = this.dataTexture.area[2]; ref4 <= ref5 ? m <= ref5 : m >= ref5; ref4 <= ref5 ? m++ : m--){ results2.push(m); }
	            return results2;
	          }).apply(this), u) >= 0 && indexOf.call((function() {
	            results3 = [];
	            for (var n = ref6 = this.dataTexture.area[1], ref7 = this.dataTexture.area[3]; ref6 <= ref7 ? n <= ref7 : n >= ref7; ref6 <= ref7 ? n++ : n--){ results3.push(n); }
	            return results3;
	          }).apply(this), v) >= 0);
	        }
	      }
	    });
	    this.cube.on("volumeLabeled", (function(_this) {
	      return function() {
	        return _this.reset();
	      };
	    })(this));
	    this.cube.on("mappingChanged", (function(_this) {
	      return function() {
	        return _this.reset();
	      };
	    })(this));
	  }
	
	  Plane2D.prototype.reset = function() {
	    this.dataTexture.tiles = new Array(this.BUCKETS_PER_ROW * this.BUCKETS_PER_ROW);
	    return this.dataTexture.ready = false;
	  };
	
	  Plane2D.prototype.forceRedraw = function() {
	    return this._forceRedraw = true;
	  };
	
	  Plane2D.prototype.hasChanged = function() {
	    return !this.dataTexture.ready;
	  };
	
	  Plane2D.prototype.get = function(arg) {
	    var area, position, zoomStep;
	    position = arg.position, zoomStep = arg.zoomStep, area = arg.area;
	    return this.getTexture(this.dataTexture, position, zoomStep, area);
	  };
	
	  Plane2D.prototype.getTexture = function(texture, position, zoomStep, area) {
	    var du, dv, height, j, k, l, layer, m, newOffset, newTile, newTileIndex, oldBuffer, oldOffset, oldTile, oldTileIndex, oldTiles, oldTopLeftBucket, ref, ref1, ref2, ref3, ref4, ref5, tile, tileIndex, topLeftBucket, topLeftPosition, u, v, width;
	    if (texture.counter == null) {
	      texture.counter = 0;
	    }
	    texture.counter++;
	    layer = position[this.W];
	    position = [position[0] & ~0x1f, position[1] & ~0x1f, position[2] & ~0x1f];
	    topLeftPosition = position.slice(0);
	    topLeftPosition[this.U] -= 1 << this.TEXTURE_SIZE_P - 1 + zoomStep;
	    topLeftPosition[this.V] -= 1 << this.TEXTURE_SIZE_P - 1 + zoomStep;
	    topLeftBucket = this.cube.positionToZoomedAddress(topLeftPosition, zoomStep);
	    area = [area[0] >> this.cube.BUCKET_SIZE_P, area[1] >> this.cube.BUCKET_SIZE_P, area[2] - 1 >> this.cube.BUCKET_SIZE_P, area[3] - 1 >> this.cube.BUCKET_SIZE_P];
	    if (this._forceRedraw || !_.isEqual(texture.layer, layer) || !_.isEqual(texture.zoomStep, zoomStep)) {
	      texture.layer = layer;
	      texture.zoomStep = zoomStep;
	      texture.topLeftBucket = topLeftBucket;
	      texture.area = area;
	      texture.tiles = new Array(this.BUCKETS_PER_ROW * this.BUCKETS_PER_ROW);
	      texture.buffer = new Uint8Array(this.TEXTURE_SIZE);
	      texture.ready = false;
	      this._forceRedraw = false;
	    }
	    if (!_.isEqual(texture.topLeftBucket, topLeftBucket)) {
	      oldTopLeftBucket = texture.topLeftBucket;
	      texture.topLeftBucket = topLeftBucket;
	      oldTiles = texture.tiles;
	      oldBuffer = texture.buffer;
	      texture.tiles = new Array(this.BUCKETS_PER_ROW * this.BUCKETS_PER_ROW);
	      texture.buffer = new Uint8Array(this.TEXTURE_SIZE);
	      texture.ready = false;
	      width = (1 << this.TEXTURE_SIZE_P - this.cube.BUCKET_SIZE_P) - Math.abs(texture.topLeftBucket[this.U] - oldTopLeftBucket[this.U]);
	      height = (1 << this.TEXTURE_SIZE_P - this.cube.BUCKET_SIZE_P) - Math.abs(texture.topLeftBucket[this.V] - oldTopLeftBucket[this.V]);
	      oldOffset = [Math.max(texture.topLeftBucket[this.U] - oldTopLeftBucket[this.U], 0), Math.max(texture.topLeftBucket[this.V] - oldTopLeftBucket[this.V], 0)];
	      newOffset = [Math.max(oldTopLeftBucket[this.U] - texture.topLeftBucket[this.U], 0), Math.max(oldTopLeftBucket[this.V] - texture.topLeftBucket[this.V], 0)];
	      for (du = j = 1, ref = width; j < ref; du = j += 1) {
	        for (dv = k = 1, ref1 = height; k < ref1; dv = k += 1) {
	          oldTile = [oldOffset[0] + du, oldOffset[1] + dv];
	          newTile = [newOffset[0] + du, newOffset[1] + dv];
	          oldTileIndex = tileIndexByTileMacro(this, oldTile);
	          newTileIndex = tileIndexByTileMacro(this, newTile);
	        }
	      }
	    }
	    if (!(texture.ready && _.isEqual(texture.area, area))) {
	      texture.ready = true;
	      texture.area = area;
	      for (u = l = ref2 = area[2], ref3 = area[0]; l >= ref3; u = l += -1) {
	        for (v = m = ref4 = area[3], ref5 = area[1]; m >= ref5; v = m += -1) {
	          tile = [u, v];
	          tileIndex = tileIndexByTileMacro(this, tile);
	          if (!texture.tiles[tileIndex]) {
	            texture.renderTile.call(this, tile);
	            texture.tiles[tileIndex] = true;
	          }
	        }
	      }
	      return texture.buffer;
	    } else {
	      return null;
	    }
	  };
	
	  Plane2D.prototype.copyTile = function(destTile, sourceTile, destBuffer, sourceBuffer) {
	    var destOffset, sourceOffset;
	    destOffset = bufferOffsetByTileMacro(this, destTile, this.cube.BUCKET_SIZE_P);
	    sourceOffset = bufferOffsetByTileMacro(this, sourceTile, this.cube.BUCKET_SIZE_P);
	    return this.renderToBuffer({
	      buffer: destBuffer,
	      offset: destOffset,
	      widthP: this.cube.BUCKET_SIZE_P,
	      rowDelta: 1 << this.TEXTURE_SIZE_P
	    }, {
	      buffer: sourceBuffer,
	      offset: sourceOffset,
	      pixelDelta: 1,
	      rowDelta: 1 << this.TEXTURE_SIZE_P,
	      pixelRepeatP: 0,
	      rowRepeatP: 0
	    }, null);
	  };
	
	  Plane2D.prototype.renderDataTile = function(tile) {
	    var bucket, map;
	    bucket = this.dataTexture.topLeftBucket.slice(0);
	    bucket[this.U] += tile[0];
	    bucket[this.V] += tile[1];
	    map = this.generateRenderMap(bucket);
	    return this.renderSubTile(map, 0, tile, this.dataTexture.zoomStep);
	  };
	
	  Plane2D.prototype.renderSubTile = function(map, mapIndex, tile, tileZoomStep) {
	    var bucket, bucketData, bucketZoomStep, destOffset, i, j, mapping, offsetMask, repeatP, results, scaleFactorP, skipP, sourceOffset, sourceOffsets, subTile, tileSizeP;
	    if (!map[mapIndex]) {
	      return;
	    }
	    if (map[mapIndex] === this.RECURSION_PLACEHOLDER) {
	      results = [];
	      for (i = j = 0; j <= 3; i = j += 1) {
	        subTile = subTileMacro(tile, i);
	        results.push(this.renderSubTile(map, (mapIndex << 2) + 1 + i, subTile, tileZoomStep - 1));
	      }
	      return results;
	    } else {
	      bucket = map[mapIndex];
	      bucketZoomStep = bucket[3];
	      tileSizeP = this.cube.BUCKET_SIZE_P - (this.dataTexture.zoomStep - tileZoomStep);
	      skipP = Math.max(this.dataTexture.zoomStep - bucketZoomStep, 0);
	      repeatP = Math.max(bucketZoomStep - this.dataTexture.zoomStep, 0);
	      destOffset = bufferOffsetByTileMacro(this, tile, tileSizeP);
	      offsetMask = (1 << bucketZoomStep - tileZoomStep) - 1;
	      scaleFactorP = this.cube.BUCKET_SIZE_P - (bucketZoomStep - tileZoomStep);
	      sourceOffsets = [(((this.dataTexture.topLeftBucket[this.U] << this.dataTexture.zoomStep - tileZoomStep) + tile[0]) & offsetMask) << scaleFactorP, (((this.dataTexture.topLeftBucket[this.V] << this.dataTexture.zoomStep - tileZoomStep) + tile[1]) & offsetMask) << scaleFactorP, (this.dataTexture.layer >> bucketZoomStep) & (1 << this.cube.BUCKET_SIZE_P) - 1];
	      sourceOffset = (sourceOffsets[0] << this.DELTA[this.U]) + (sourceOffsets[1] << this.DELTA[this.V]) + (sourceOffsets[2] << this.DELTA[this.W]);
	      bucketData = this.cube.getBucketByZoomedAddress(bucket).getData();
	      mapping = this.cube.currentMapping;
	      return this.renderToBuffer({
	        buffer: this.dataTexture.buffer,
	        offset: destOffset,
	        widthP: tileSizeP,
	        rowDelta: 1 << this.TEXTURE_SIZE_P
	      }, {
	        buffer: bucketData,
	        mapping: mapping,
	        offset: sourceOffset,
	        pixelDelta: 1 << (this.DELTA[this.U] + skipP),
	        rowDelta: 1 << (this.DELTA[this.V] + skipP),
	        pixelRepeatP: repeatP,
	        rowRepeatP: repeatP
	      });
	    }
	  };
	
	  Plane2D.prototype.generateRenderMap = function(arg) {
	    var bucket, bucket_x, bucket_y, bucket_z, i, j, map, maxZoomStepOffset, ref, zoomStep;
	    bucket_x = arg[0], bucket_y = arg[1], bucket_z = arg[2], zoomStep = arg[3];
	    if (this.cube.getBucketByZoomedAddress([bucket_x, bucket_y, bucket_z, zoomStep]).hasData()) {
	      return [[bucket_x, bucket_y, bucket_z, zoomStep]];
	    }
	    map = new Array(this.MAP_SIZE);
	    map[0] = void 0;
	    maxZoomStepOffset = Math.max(0, Math.min(this.cube.LOOKUP_DEPTH_UP, this.cube.ZOOM_STEP_COUNT - zoomStep - 1));
	    if (zoomStep < this.cube.ZOOM_STEP_COUNT) {
	      for (i = j = ref = maxZoomStepOffset; ref <= 0 ? j < 0 : j > 0; i = ref <= 0 ? ++j : --j) {
	        bucket = [bucket_x >> i, bucket_y >> i, bucket_z >> i, zoomStep + i];
	        if (this.cube.getBucketByZoomedAddress(bucket).hasData()) {
	          map[0] = bucket;
	        }
	      }
	    }
	    if (zoomStep !== 0 && this.enhanceRenderMap(map, 0, [bucket_x, bucket_y, bucket_z, zoomStep], map[0], this.cube.LOOKUP_DEPTH_DOWN)) {
	      map[0] = this.RECURSION_PLACEHOLDER;
	    }
	    return map;
	  };
	
	  Plane2D.prototype.enhanceRenderMap = function(map, mapIndex, arg, fallback, level) {
	    var bucket_x, bucket_y, bucket_z, du, dv, dw, enhanced, j, k, recursive, subBucket, zoomStep;
	    bucket_x = arg[0], bucket_y = arg[1], bucket_z = arg[2], zoomStep = arg[3];
	    enhanced = false;
	    if (this.cube.getBucketByZoomedAddress([bucket_x, bucket_y, bucket_z, zoomStep]).hasData()) {
	      map[mapIndex] = [bucket_x, bucket_y, bucket_z, zoomStep];
	      enhanced = true;
	    } else {
	      map[mapIndex] = fallback;
	    }
	    dw = this.dataTexture.layer >> (this.cube.BUCKET_SIZE_P + zoomStep - 1) & 0x1;
	    recursive = false;
	    if (level && zoomStep) {
	      for (du = j = 0; j <= 1; du = ++j) {
	        for (dv = k = 0; k <= 1; dv = ++k) {
	          subBucket = [bucket_x << 1, bucket_y << 1, bucket_z << 1, zoomStep - 1];
	          subBucket[this.U] += du;
	          subBucket[this.V] += dv;
	          subBucket[this.W] += dw;
	          recursive |= this.enhanceRenderMap(map, (mapIndex << 2) + 2 * dv + du + 1, subBucket, map[mapIndex], level - 1);
	        }
	      }
	    }
	    if (recursive) {
	      map[mapIndex] = this.RECURSION_PLACEHOLDER;
	      enhanced = true;
	    }
	    return enhanced;
	  };
	
	  Plane2D.prototype.renderVolumeTile = function(tile) {
	    var bucket, bucketData, destOffset, sourceOffset;
	    bucket = this.volumeTexture.topLeftBucket.slice(0);
	    bucket[this.U] += tile[0];
	    bucket[this.V] += tile[1];
	    destOffset = bufferOffsetByTileMacro(this, tile, this.cube.BUCKET_SIZE_P);
	    sourceOffset = ((this.volumeTexture.layer >> this.volumeTexture.zoomStep) & (1 << this.cube.BUCKET_SIZE_P) - 1) << this.DELTA[this.W];
	    bucketData = this.cube.getVolumeBucketByZoomedAddress(bucket);
	    if (bucketData == null) {
	      return;
	    }
	    return this.renderToBuffer({
	      buffer: this.volumeTexture.buffer,
	      offset: destOffset,
	      widthP: this.cube.BUCKET_SIZE_P,
	      rowDelta: 1 << this.TEXTURE_SIZE_P
	    }, {
	      buffer: bucketData,
	      offset: sourceOffset,
	      pixelDelta: 1 << this.DELTA[this.U],
	      rowDelta: 1 << this.DELTA[this.V],
	      pixelRepeatP: 0,
	      rowRepeatP: 0
	    }, null);
	  };
	
	  Plane2D.prototype.renderToBuffer = function(destination, source) {
	    var b, bytesDest, bytesSrc, bytesSrcMapped, dest, i, j, k, mapping, ref, ref1, shorten, sourceValue, src, value;
	    i = 1 << (destination.widthP << 1);
	    destination.nextRowMask = (1 << destination.widthP) - 1;
	    source.nextPixelMask = (1 << source.pixelRepeatP) - 1;
	    source.nextRowMask = (1 << destination.widthP + source.rowRepeatP) - 1;
	    mapping = source.mapping;
	    bytesSrc = this.DATA_BIT_DEPTH >> 3;
	    bytesSrcMapped = (mapping != null) && mapping.length ? this.MAPPED_DATA_BIT_DEPTH >> 3 : bytesSrc;
	    bytesDest = this.TEXTURE_BIT_DEPTH >> 3;
	    shorten = bytesDest < bytesSrcMapped;
	    while (i--) {
	      dest = destination.offset++ * bytesDest;
	      src = source.offset * bytesSrc;
	      sourceValue = 0;
	      for (b = j = 0, ref = bytesSrc; 0 <= ref ? j < ref : j > ref; b = 0 <= ref ? ++j : --j) {
	        sourceValue += (1 << (b * 8)) * source.buffer[src + b];
	      }
	      sourceValue = (mapping != null) && (mapping[sourceValue] != null) ? mapping[sourceValue] : sourceValue;
	      for (b = k = 0, ref1 = bytesSrcMapped; 0 <= ref1 ? k < ref1 : k > ref1; b = 0 <= ref1 ? ++k : --k) {
	        if ((value = (sourceValue >> (b * 8)) % 256) || b === bytesSrcMapped - 1 || (!shorten)) {
	          destination.buffer[dest++] = value;
	          if (shorten) {
	            break;
	          }
	        }
	      }
	      if ((i & source.nextPixelMask) === 0) {
	        source.offset += source.pixelDelta;
	      }
	      if ((i & destination.nextRowMask) === 0) {
	        destination.offset += destination.rowDelta - (1 << destination.widthP);
	        source.offset -= source.pixelDelta << (destination.widthP - source.pixelRepeatP);
	      }
	      if ((i & source.nextRowMask) === 0) {
	        source.offset += source.rowDelta;
	      }
	    }
	  };
	
	  return Plane2D;
	
	})();
	
	module.exports = Plane2D;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var Dimensions, constants;
	
	constants = __webpack_require__(61);
	
	Dimensions = {
	  PLANE_XY: constants.PLANE_XY,
	  PLANE_YZ: constants.PLANE_YZ,
	  PLANE_XZ: constants.PLANE_XZ,
	  TDView: constants.TDView,
	  getIndices: function(planeID) {
	    switch (planeID) {
	      case constants.PLANE_XY:
	        return [0, 1, 2];
	      case constants.PLANE_YZ:
	        return [2, 1, 0];
	      case constants.PLANE_XZ:
	        return [0, 2, 1];
	    }
	  },
	  transDim: function(array, planeID) {
	    var ind;
	    ind = this.getIndices(planeID);
	    return [array[ind[0]], array[ind[1]], array[ind[2]]];
	  },
	  planeForThirdDimension: function(dim) {
	    switch (dim) {
	      case 2:
	        return this.PLANE_XY;
	      case 0:
	        return this.PLANE_YZ;
	      case 1:
	        return this.PLANE_XZ;
	    }
	  },
	  thirdDimensionForPlane: function(planeID) {
	    switch (planeID) {
	      case this.PLANE_XY:
	        return 2;
	      case this.PLANE_YZ:
	        return 0;
	      case this.PLANE_XZ:
	        return 1;
	    }
	  },
	  round: function(number) {
	    return ~~number;
	  },
	  roundCoordinate: function(coordinate) {
	    var i, j, ref, res;
	    res = coordinate.slice();
	    for (i = j = 0, ref = res.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      res[i] = this.round(res[i]);
	    }
	    return res;
	  },
	  distance: function(pos1, pos2) {
	    var diff, i, j, ref, sumOfSquares;
	    sumOfSquares = 0;
	    for (i = j = 0, ref = pos1.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      diff = pos1[i] - pos2[i];
	      sumOfSquares += diff * diff;
	    }
	    return Math.sqrt(sumOfSquares);
	  }
	};
	
	module.exports = Dimensions;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Dimensions, PingStrategy,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Dimensions = __webpack_require__(277);
	
	PingStrategy = (function() {
	  PingStrategy.prototype.TEXTURE_SIZE_P = 0;
	
	  PingStrategy.prototype.MAX_ZOOM_STEP_DIFF = 1;
	
	  PingStrategy.prototype.velocityRangeStart = 0;
	
	  PingStrategy.prototype.velocityRangeEnd = 0;
	
	  PingStrategy.prototype.roundTripTimeRangeStart = 0;
	
	  PingStrategy.prototype.roundTripTimeRangeEnd = 0;
	
	  PingStrategy.prototype.contentTypes = [];
	
	  PingStrategy.prototype.cube = null;
	
	  PingStrategy.prototype.name = 'ABSTRACT';
	
	  function PingStrategy(cube, TEXTURE_SIZE_P) {
	    this.cube = cube;
	    this.TEXTURE_SIZE_P = TEXTURE_SIZE_P;
	  }
	
	  PingStrategy.prototype.forContentType = function(contentType) {
	    return _.isEmpty(this.contentTypes) || ~this.contentTypes.indexOf(contentType);
	  };
	
	  PingStrategy.prototype.inVelocityRange = function(value) {
	    return (this.velocityRangeStart <= value && value <= this.velocityRangeEnd);
	  };
	
	  PingStrategy.prototype.inRoundTripTimeRange = function(value) {
	    return (this.roundTripTimeRangeStart <= value && value <= this.roundTripTimeRangeEnd);
	  };
	
	  PingStrategy.prototype.ping = function() {
	    throw "Needs to be implemented in subclass";
	    return {
	      pullQueue: [x0, y0, z0, zoomStep0, x1, y1, z1, zoomStep1],
	      extent: {
	        min_x: min_x,
	        min_y: min_y,
	        min_z: min_z,
	        max_x: max_x,
	        max_y: max_y,
	        max_z: max_z
	      }
	    };
	  };
	
	  PingStrategy.prototype.getBucketArray = function(center, width, height) {
	    var bucket, buckets, i, j, ref, ref1, ref2, ref3, u, uOffset, v, vOffset;
	    buckets = [];
	    uOffset = Math.ceil(width / 2);
	    vOffset = Math.ceil(height / 2);
	    for (u = i = ref = -uOffset, ref1 = uOffset; ref <= ref1 ? i <= ref1 : i >= ref1; u = ref <= ref1 ? ++i : --i) {
	      for (v = j = ref2 = -vOffset, ref3 = vOffset; ref2 <= ref3 ? j <= ref3 : j >= ref3; v = ref2 <= ref3 ? ++j : --j) {
	        bucket = center.slice(0);
	        bucket[this.u] += u;
	        bucket[this.v] += v;
	        buckets.push(_.min(bucket) >= 0 ? bucket : null);
	      }
	    }
	    return buckets;
	  };
	
	  return PingStrategy;
	
	})();
	
	PingStrategy.BaseStrategy = (function(superClass) {
	  extend(BaseStrategy, superClass);
	
	  function BaseStrategy() {
	    return BaseStrategy.__super__.constructor.apply(this, arguments);
	  }
	
	  BaseStrategy.prototype.velocityRangeStart = 0;
	
	  BaseStrategy.prototype.velocityRangeEnd = Infinity;
	
	  BaseStrategy.prototype.roundTripTimeRangeStart = 0;
	
	  BaseStrategy.prototype.roundTripTimeRangeEnd = Infinity;
	
	  BaseStrategy.prototype.preloadingSlides = 0;
	
	  BaseStrategy.prototype.preloadingPriorityOffset = 0;
	
	  BaseStrategy.prototype.ping = function(position, direction, requestedZoomStep, areas, activePlane) {
	    var bucket, bucketArea, buckets, centerBucket, height, i, j, k, len, plane, preloadingPriority, priority, pullQueue, ref, ref1, slide, width, zoomStep, zoomStepDiff;
	    zoomStep = Math.min(requestedZoomStep, this.cube.MAX_ZOOM_STEP);
	    zoomStepDiff = requestedZoomStep - zoomStep;
	    pullQueue = [];
	    if (!(zoomStepDiff <= this.MAX_ZOOM_STEP_DIFF)) {
	      return pullQueue;
	    }
	    for (plane = i = 0; i <= 2; plane = ++i) {
	      ref = Dimensions.getIndices(plane), this.u = ref[0], this.v = ref[1], this.w = ref[2];
	      bucketArea = [areas[plane][0] >> this.cube.BUCKET_SIZE_P, areas[plane][1] >> this.cube.BUCKET_SIZE_P, areas[plane][2] - 1 >> this.cube.BUCKET_SIZE_P, areas[plane][3] - 1 >> this.cube.BUCKET_SIZE_P];
	      width = (bucketArea[2] - bucketArea[0]) << zoomStepDiff;
	      height = (bucketArea[3] - bucketArea[1]) << zoomStepDiff;
	      centerBucket = this.cube.positionToZoomedAddress(position, zoomStep);
	      buckets = this.getBucketArray(centerBucket, width, height);
	      for (j = 0, len = buckets.length; j < len; j++) {
	        bucket = buckets[j];
	        if (bucket != null) {
	          priority = Math.abs(bucket[0] - centerBucket[0]) + Math.abs(bucket[1] - centerBucket[1]) + Math.abs(bucket[2] - centerBucket[2]);
	          pullQueue.push({
	            bucket: [bucket[0], bucket[1], bucket[2], zoomStep],
	            priority: priority
	          });
	          if (plane === activePlane) {
	            for (slide = k = 0, ref1 = this.preloadingSlides; 0 <= ref1 ? k < ref1 : k > ref1; slide = 0 <= ref1 ? ++k : --k) {
	              if (direction[this.w] >= 0) {
	                bucket[this.w]++;
	              } else {
	                bucket[this.w]--;
	              }
	              preloadingPriority = (priority << (slide + 1)) + this.preloadingPriorityOffset;
	              pullQueue.push({
	                bucket: [bucket[0], bucket[1], bucket[2], zoomStep],
	                priority: preloadingPriority
	              });
	            }
	          }
	        }
	      }
	    }
	    return pullQueue;
	  };
	
	  return BaseStrategy;
	
	})(PingStrategy);
	
	PingStrategy.Skeleton = (function(superClass) {
	  extend(Skeleton, superClass);
	
	  function Skeleton() {
	    return Skeleton.__super__.constructor.apply(this, arguments);
	  }
	
	  Skeleton.prototype.contentTypes = ["skeletonTracing"];
	
	  Skeleton.prototype.name = 'SKELETON';
	
	  Skeleton.prototype.preloadingSlides = 2;
	
	  return Skeleton;
	
	})(PingStrategy.BaseStrategy);
	
	PingStrategy.Volume = (function(superClass) {
	  extend(Volume, superClass);
	
	  function Volume() {
	    return Volume.__super__.constructor.apply(this, arguments);
	  }
	
	  Volume.prototype.contentTypes = ["volumeTracing"];
	
	  Volume.prototype.name = 'VOLUME';
	
	  Volume.prototype.preloadingSlides = 1;
	
	  Volume.prototype.preloadingPriorityOffset = 80;
	
	  return Volume;
	
	})(PingStrategy.BaseStrategy);
	
	module.exports = PingStrategy;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var M4x4, PingStrategy3d, PolyhedronRasterizer, V3, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	PolyhedronRasterizer = __webpack_require__(280);
	
	ref = __webpack_require__(189), M4x4 = ref.M4x4, V3 = ref.V3;
	
	PingStrategy3d = (function() {
	  function PingStrategy3d() {}
	
	  PingStrategy3d.prototype.velocityRangeStart = 0;
	
	  PingStrategy3d.prototype.velocityRangeEnd = 0;
	
	  PingStrategy3d.prototype.roundTripTimeRangeStart = 0;
	
	  PingStrategy3d.prototype.roundTripTimeRangeEnd = 0;
	
	  PingStrategy3d.prototype.contentTypes = [];
	
	  PingStrategy3d.prototype.name = 'Abstract';
	
	  PingStrategy3d.prototype.forContentType = function(contentType) {
	    return _.isEmpty(this.contentTypes) || _.contains(this.contentTypes, contentType);
	  };
	
	  PingStrategy3d.prototype.inVelocityRange = function(value) {
	    return (this.velocityRangeStart <= value && value <= this.velocityRangeEnd);
	  };
	
	  PingStrategy3d.prototype.inRoundTripTimeRange = function(value) {
	    return (this.roundTripTimeRangeStart <= value && value <= this.roundTripTimeRangeEnd);
	  };
	
	  PingStrategy3d.prototype.ping = function() {
	    throw "Needs to be implemented in subclass";
	  };
	
	  PingStrategy3d.prototype.getExtentObject = function(poly0, poly1, zoom0, zoom1) {
	    return {
	      min_x: Math.min(poly0.min_x << zoom0, poly1.min_x << zoom1),
	      min_y: Math.min(poly0.min_y << zoom0, poly1.min_y << zoom1),
	      min_z: Math.min(poly0.min_z << zoom0, poly1.min_z << zoom1),
	      max_x: Math.max(poly0.max_x << zoom0, poly1.max_x << zoom1),
	      max_y: Math.max(poly0.max_y << zoom0, poly1.max_y << zoom1),
	      max_z: Math.max(poly0.max_z << zoom0, poly1.max_z << zoom1)
	    };
	  };
	
	  PingStrategy3d.prototype.modifyMatrixForPoly = function(matrix, zoomStep) {
	    matrix[12] >>= 5 + zoomStep;
	    matrix[13] >>= 5 + zoomStep;
	    matrix[14] >>= 5 + zoomStep;
	    matrix[12] += 1;
	    matrix[13] += 1;
	    return matrix[14] += 1;
	  };
	
	  return PingStrategy3d;
	
	})();
	
	PingStrategy3d.DslSlow = (function(superClass) {
	  extend(DslSlow, superClass);
	
	  function DslSlow() {
	    return DslSlow.__super__.constructor.apply(this, arguments);
	  }
	
	  DslSlow.prototype.velocityRangeStart = 0;
	
	  DslSlow.prototype.velocityRangeEnd = Infinity;
	
	  DslSlow.prototype.roundTripTimeRangeStart = 0;
	
	  DslSlow.prototype.roundTripTimeRangeEnd = Infinity;
	
	  DslSlow.prototype.name = 'DSL_SLOW';
	
	  DslSlow.prototype.pingPolyhedron0 = PolyhedronRasterizer.Master.squareFrustum(5, 5, -0.5, 4, 4, 2);
	
	  DslSlow.prototype.pingPolyhedron1 = PolyhedronRasterizer.Master.squareFrustum(3, 3, -0.0, 3, 3, -3);
	
	  DslSlow.prototype.ping = function(matrix) {
	    var bucket_x, bucket_y, bucket_z, i, matrix0, matrix1, polyhedron0, polyhedron1, pullQueue, testAddresses;
	    pullQueue = [];
	    matrix1 = M4x4.clone(matrix);
	    this.modifyMatrixForPoly(matrix1, 1);
	    polyhedron1 = this.pingPolyhedron1.transformAffine(matrix1);
	    testAddresses = polyhedron1.collectPointsOnion(matrix1[12], matrix1[13], matrix1[14]);
	    i = 0;
	    while (i < testAddresses.length) {
	      bucket_x = testAddresses[i++];
	      bucket_y = testAddresses[i++];
	      bucket_z = testAddresses[i++];
	      pullQueue.push({
	        bucket: [bucket_x, bucket_y, bucket_z, 1],
	        priority: 0
	      });
	    }
	    matrix0 = M4x4.clone(matrix);
	    this.modifyMatrixForPoly(matrix0, 0);
	    polyhedron0 = this.pingPolyhedron0.transformAffine(matrix0);
	    testAddresses = polyhedron0.collectPointsOnion(matrix0[12], matrix0[13], matrix0[14]);
	    i = 0;
	    while (i < testAddresses.length) {
	      bucket_x = testAddresses[i++];
	      bucket_y = testAddresses[i++];
	      bucket_z = testAddresses[i++];
	      pullQueue.push({
	        bucket: [bucket_x, bucket_y, bucket_z, 0],
	        priority: 0
	      });
	    }
	    return pullQueue;
	  };
	
	  return DslSlow;
	
	})(PingStrategy3d);
	
	module.exports = PingStrategy3d;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var HEAP, HEAP_SIZE, Int32_MAX, Int32_MIN, M4x4, PolyhedronRasterizer, V3, drawFunction, nextFreeBit, ref;
	
	ref = __webpack_require__(189), M4x4 = ref.M4x4, V3 = ref.V3;
	
	HEAP_SIZE = 1 << 25;
	
	HEAP = new ArrayBuffer(HEAP_SIZE);
	
	Int32_MIN = -2147483648;
	
	Int32_MAX = 2147483647;
	
	drawFunction = function(x, y, z, buffer, shift_z) {
	  var __index_y;
	  __index_y = (z << shift_z) + (y << 1);
	  if (x < buffer[__index_y]) {
	    buffer[__index_y] = x;
	  }
	  if (x > buffer[__index_y + 1]) {
	    return buffer[__index_y + 1] = x;
	  }
	};
	
	nextFreeBit = function(x) {
	  var n;
	  n = 1;
	  if ((x >> 16) === 0) {
	    n = n + 16;
	    x <<= 16;
	  }
	  if ((x >> 24) === 0) {
	    n = n + 8;
	    x <<= 8;
	  }
	  if ((x >> 28) === 0) {
	    n = n + 4;
	    x <<= 4;
	  }
	  if ((x >> 30) === 0) {
	    n = n + 2;
	    x <<= 2;
	  }
	  return 32 - n - (x >> 31);
	};
	
	PolyhedronRasterizer = (function() {
	  PolyhedronRasterizer.prototype.orientation = 1;
	
	  function PolyhedronRasterizer(vertices1, indices1) {
	    var buffer, bufferLength, delta_y, delta_z, i, index, index_y, k, l, min_x, min_y, min_z, ref1, ref2, shift_z, vertices, z;
	    this.vertices = vertices1;
	    this.indices = indices1;
	    this.calcExtent();
	    min_x = this.min_x, min_y = this.min_y, min_z = this.min_z, delta_z = this.delta_z, delta_y = this.delta_y, shift_z = this.shift_z, vertices = this.vertices;
	    this.bufferLength = bufferLength = delta_z << shift_z;
	    this.buffer = buffer = new Int32Array(HEAP, 0, bufferLength);
	    for (z = k = 0, ref1 = delta_z; k < ref1; z = k += 1) {
	      index = z << shift_z;
	      for (index_y = l = 0, ref2 = delta_y; l < ref2; index_y = l += 1) {
	        buffer[index++] = Int32_MAX;
	        buffer[index++] = Int32_MIN;
	      }
	    }
	    i = vertices.length;
	    while (i) {
	      vertices[--i] -= min_z;
	      vertices[--i] -= min_y;
	      vertices[--i] -= min_x;
	    }
	    this.pointsBuffer = new Int32Array(delta_y << 2);
	    this.drawEdges();
	    this.drawPolygons();
	  }
	
	  PolyhedronRasterizer.prototype.calcExtent = function() {
	    var i, max_x, max_y, max_z, min_x, min_y, min_z, vertices, x, y, z;
	    min_x = min_y = min_z = Int32_MAX;
	    max_x = max_y = max_z = Int32_MIN;
	    vertices = this.vertices;
	    i = 0;
	    while (i < vertices.length) {
	      x = vertices[i++];
	      y = vertices[i++];
	      z = vertices[i++];
	      if (x < min_x) {
	        min_x = x;
	      }
	      if (y < min_y) {
	        min_y = y;
	      }
	      if (z < min_z) {
	        min_z = z;
	      }
	      if (x > max_x) {
	        max_x = x;
	      }
	      if (y > max_y) {
	        max_y = y;
	      }
	      if (z > max_z) {
	        max_z = z;
	      }
	    }
	    this.min_x = min_x;
	    this.min_y = min_y;
	    this.min_z = min_z;
	    this.max_x = max_x;
	    this.max_y = max_y;
	    this.max_z = max_z;
	    this.delta_x = max_x - min_x + 1;
	    this.delta_y = max_y - min_y + 1;
	    this.delta_z = max_z - min_z + 1;
	    this.shift_z = nextFreeBit((this.delta_y << 1) - 1);
	  };
	
	  PolyhedronRasterizer.prototype.draw = function(x, y, z) {
	    var buffer, shift_z;
	    buffer = this.buffer, shift_z = this.shift_z;
	    drawFunction(x, y, z, buffer, shift_z);
	  };
	
	  PolyhedronRasterizer.prototype.drawEdges = function() {
	    var i, i0, i1, indices, vertices;
	    indices = this.indices, vertices = this.vertices;
	    i = indices.length;
	    while (i) {
	      i0 = indices[--i];
	      i1 = indices[--i];
	      this.drawLine3d(vertices[i0++], vertices[i0++], vertices[i0], vertices[i1++], vertices[i1++], vertices[i1]);
	    }
	  };
	
	  PolyhedronRasterizer.prototype.drawLine3d = function(x, y, z, x1, y1, z1) {
	    var __tmp, buffer, d, dx, dx2, dy, dy2, dz, dz2, err_1, err_2, i, k, mode, ref1, shift_z, x_inc, y_inc, z_inc;
	    shift_z = this.shift_z, buffer = this.buffer;
	    x_inc = (dx = x1 - x) < 0 ? -1 : 1;
	    y_inc = (dy = y1 - y) < 0 ? -1 : 1;
	    z_inc = (dz = z1 - z) < 0 ? -1 : 1;
	    drawFunction(x, y, z, buffer, shift_z);
	    dx = dx < 0 ? -dx : dx;
	    dy = dy < 0 ? -dy : dy;
	    dz = dz < 0 ? -dz : dz;
	    dx2 = dx << 1;
	    dy2 = dy << 1;
	    dz2 = dz << 1;
	    if (dx >= dy && dx >= dz) {
	      d = dx;
	      mode = 0;
	    } else if (dy >= dz) {
	      __tmp = y;
	      y = x;
	      x = __tmp;
	      __tmp = y_inc;
	      y_inc = x_inc;
	      x_inc = __tmp;
	      __tmp = dy2;
	      dy2 = dx2;
	      dx2 = __tmp;
	      d = dy;
	      mode = 1;
	    } else {
	      __tmp = z;
	      z = x;
	      x = __tmp;
	      __tmp = z_inc;
	      z_inc = x_inc;
	      x_inc = __tmp;
	      __tmp = dz2;
	      dz2 = dx2;
	      dx2 = __tmp;
	      d = dz;
	      mode = 2;
	    }
	    err_1 = dy2 - d;
	    err_2 = dz2 - d;
	    for (i = k = 0, ref1 = d; k < ref1; i = k += 1) {
	      if (err_1 > 0) {
	        y += y_inc;
	        err_1 -= dx2;
	      }
	      if (err_2 > 0) {
	        z += z_inc;
	        err_2 -= dx2;
	      }
	      err_1 += dy2;
	      err_2 += dz2;
	      x += x_inc;
	      switch (mode) {
	        case 0:
	          drawFunction(x, y, z, buffer, shift_z);
	          break;
	        case 1:
	          drawFunction(y, x, z, buffer, shift_z);
	          break;
	        default:
	          drawFunction(z, y, x, buffer, shift_z);
	      }
	    }
	  };
	
	  PolyhedronRasterizer.prototype.drawLine2d = function(x, y, x1, y1, z) {
	    var __tmp, buffer, d, dx, dx2, dy, dy2, err, i, k, mode, ref1, shift_z, x_inc, y_inc;
	    shift_z = this.shift_z, buffer = this.buffer;
	    x_inc = (dx = x1 - x) < 0 ? -1 : 1;
	    y_inc = (dy = y1 - y) < 0 ? -1 : 1;
	    dx = dx < 0 ? -dx : dx;
	    dy = dy < 0 ? -dy : dy;
	    dx2 = dx << 1;
	    dy2 = dy << 1;
	    drawFunction(x, y, z, buffer, shift_z);
	    if (dx >= dy) {
	      d = dx;
	      mode = 0;
	    } else {
	      __tmp = y;
	      y = x;
	      x = __tmp;
	      __tmp = y_inc;
	      y_inc = x_inc;
	      x_inc = __tmp;
	      __tmp = dy2;
	      dy2 = dx2;
	      dx2 = __tmp;
	      d = dy;
	      mode = 1;
	    }
	    err = dy2 - d;
	    for (i = k = 0, ref1 = d; k < ref1; i = k += 1) {
	      if (err > 0) {
	        y += y_inc;
	        err -= dx2;
	      }
	      err += dy2;
	      x += x_inc;
	      if (mode) {
	        drawFunction(y, x, z, buffer, shift_z);
	      } else {
	        drawFunction(x, y, z, buffer, shift_z);
	      }
	    }
	  };
	
	  PolyhedronRasterizer.prototype.drawPolygons = function() {
	    var buffer, delta_x, delta_y, delta_z, i, index_y, j, k, l, pointsBuffer, pointsPointer, ref1, ref2, shift_z, x0, x1, y, y0, y1, z;
	    delta_x = this.delta_x, delta_y = this.delta_y, delta_z = this.delta_z, shift_z = this.shift_z, buffer = this.buffer, pointsBuffer = this.pointsBuffer;
	    for (z = k = 0, ref1 = delta_z; k < ref1; z = k += 1) {
	      pointsPointer = 0;
	      index_y = z << shift_z;
	      for (y = l = 0, ref2 = delta_y; l < ref2; y = l += 1) {
	        if ((x0 = buffer[index_y++]) !== Int32_MAX) {
	          pointsBuffer[pointsPointer++] = y;
	          pointsBuffer[pointsPointer++] = x0;
	          if ((x1 = buffer[index_y++]) !== x0) {
	            pointsBuffer[pointsPointer++] = y;
	            pointsBuffer[pointsPointer++] = x1;
	          }
	        } else {
	          index_y++;
	        }
	      }
	      i = 0;
	      while (i < pointsPointer) {
	        y0 = pointsBuffer[i++];
	        x0 = pointsBuffer[i++];
	        j = i;
	        while (j < pointsPointer) {
	          y1 = pointsBuffer[j++];
	          x1 = pointsBuffer[j++];
	          this.drawLine2d(x0, y0, x1, y1, z);
	        }
	      }
	    }
	  };
	
	  PolyhedronRasterizer.prototype.collectPoints = function() {
	    var buffer, delta_y, delta_z, index, k, l, m, min_x, min_y, min_z, output, ref1, ref2, ref3, ref4, shift_z, x, x0, x1, y, z;
	    buffer = this.buffer, min_x = this.min_x, min_y = this.min_y, min_z = this.min_z, shift_z = this.shift_z, delta_y = this.delta_y, delta_z = this.delta_z;
	    output = [];
	    for (z = k = 0, ref1 = delta_z; k < ref1; z = k += 1) {
	      index = z << shift_z;
	      for (y = l = 0, ref2 = delta_y; l < ref2; y = l += 1) {
	        x0 = buffer[index++];
	        x1 = buffer[index++];
	        if (x0 !== Int32_MAX) {
	          for (x = m = ref3 = x0, ref4 = x1; ref3 <= ref4 ? m <= ref4 : m >= ref4; x = ref3 <= ref4 ? ++m : --m) {
	            output.push(x + min_x, y + min_y, z + min_z);
	          }
	        }
	      }
	    }
	    return output;
	  };
	
	  PolyhedronRasterizer.prototype.collectPointsOnion = function(xs, ys, zs) {
	    var buffer, delta_x, delta_y, delta_z, index, k, l, m, maxRadius, max_x, max_y, max_z, min_x, min_y, min_z, o, outputBuffer, outputLength, radius, radius_end_z, radius_max_y, radius_max_z, radius_min_y, radius_min_z, radius_start_z, ref1, ref2, ref3, ref4, ref5, ref6, ref7, shift_z, x, x0, x1, y, z;
	    buffer = this.buffer, min_x = this.min_x, max_x = this.max_x, min_y = this.min_y, max_y = this.max_y, min_z = this.min_z, max_z = this.max_z, delta_x = this.delta_x, delta_y = this.delta_y, delta_z = this.delta_z, shift_z = this.shift_z;
	    maxRadius = Math.max(Math.abs(xs - min_x), Math.abs(xs - max_x), Math.abs(ys - min_y), Math.abs(ys - max_y), Math.abs(zs - min_z), Math.abs(zs - max_z));
	    outputBuffer = new Int32Array(HEAP, this.bufferLength * Int32Array.BYTES_PER_ELEMENT, delta_x * delta_y * delta_z * 3);
	    outputLength = 0;
	    for (radius = k = 0, ref1 = maxRadius; k <= ref1; radius = k += 1) {
	      radius_min_z = Math.max(zs - radius, min_z);
	      radius_max_z = Math.min(zs + radius, max_z);
	      radius_min_y = Math.max(ys - radius, min_y);
	      radius_max_y = Math.min(ys + radius, max_y);
	      if (this.orientation === 1) {
	        radius_start_z = radius_max_z;
	        radius_end_z = radius_min_z;
	      } else {
	        radius_end_z = radius_max_z;
	        radius_start_z = radius_min_z;
	      }
	      for (z = l = ref2 = radius_start_z, ref3 = radius_end_z; ref2 <= ref3 ? l <= ref3 : l >= ref3; z = ref2 <= ref3 ? ++l : --l) {
	        for (y = m = ref4 = radius_min_y, ref5 = radius_max_y; m <= ref5; y = m += 1) {
	          index = ((z - min_z) << shift_z) + ((y - min_y) << 1);
	          x0 = buffer[index++];
	          x1 = buffer[index++];
	          if (x0 !== Int32_MAX) {
	            x0 += min_x;
	            x1 += min_x;
	            for (x = o = ref6 = Math.max(xs - radius, x0), ref7 = Math.min(xs + radius, x1); ref6 <= ref7 ? o <= ref7 : o >= ref7; x = ref6 <= ref7 ? ++o : --o) {
	              if (x === xs - radius || x === xs + radius || y === ys - radius || y === ys + radius || z === zs - radius || z === zs + radius) {
	                outputBuffer[outputLength++] = x;
	                outputBuffer[outputLength++] = y;
	                outputBuffer[outputLength++] = z;
	              }
	            }
	          }
	        }
	      }
	    }
	    return outputBuffer.subarray(0, outputLength);
	  };
	
	  return PolyhedronRasterizer;
	
	})();
	
	PolyhedronRasterizer.Master = (function() {
	  function Master(vertices1, indices1) {
	    this.vertices = vertices1;
	    this.indices = indices1;
	  }
	
	  Master.prototype.transformAffine = function(matrix) {
	    var indices, orientationVector, transformedPolyhdron, vertices;
	    vertices = this.vertices, indices = this.indices;
	    transformedPolyhdron = new PolyhedronRasterizer(M4x4.transformPointsAffine(matrix, vertices, new Int32Array(vertices.length)), indices);
	    orientationVector = M4x4.transformLineAffine(matrix, [0, 0, 1], [0, 0, 0]);
	    transformedPolyhdron.orientation = orientationVector[2] < 0 ? -1 : 1;
	    return transformedPolyhdron;
	  };
	
	  Master.squareFrustum = function(nearFaceXWidth, nearFaceYWidth, nearFaceZ, farFaceXWidth, farFaceYWidth, farFaceZ) {
	    var indices, vertices;
	    vertices = [-nearFaceXWidth / 2, -nearFaceYWidth / 2, nearFaceZ, -farFaceXWidth / 2, -farFaceYWidth / 2, farFaceZ, -nearFaceXWidth / 2, nearFaceYWidth / 2, nearFaceZ, -farFaceXWidth / 2, farFaceYWidth / 2, farFaceZ, nearFaceXWidth / 2, -nearFaceYWidth / 2, nearFaceZ, farFaceXWidth / 2, -farFaceYWidth / 2, farFaceZ, nearFaceXWidth / 2, nearFaceYWidth / 2, nearFaceZ, farFaceXWidth / 2, farFaceYWidth / 2, farFaceZ];
	    indices = [0, 3, 0, 6, 0, 12, 3, 9, 3, 15, 6, 9, 6, 18, 9, 21, 12, 15, 12, 18, 15, 21, 18, 21];
	    return new PolyhedronRasterizer.Master(vertices, indices);
	  };
	
	  Master.cuboid = function(width_x, width_y, width_z) {
	    return this.squareFrustum(width_x, width_y, 0, width_x, width_y, width_z);
	  };
	
	  Master.cube = function(width) {
	    return this.cuboid(width, width, width);
	  };
	
	  return Master;
	
	})();
	
	module.exports = PolyhedronRasterizer;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var BoundingBox, _;
	
	_ = __webpack_require__(2);
	
	BoundingBox = (function() {
	  function BoundingBox(boundingBox, cube) {
	    var ref;
	    this.boundingBox = boundingBox;
	    this.cube = cube;
	    this.BUCKET_SIZE_P = this.cube.BUCKET_SIZE_P;
	    this.BYTE_OFFSET = this.cube.BYTE_OFFSET;
	    if (this.boundingBox != null) {
	      ref = this.boundingBox, this.min = ref.min, this.max = ref.max;
	    }
	  }
	
	  BoundingBox.prototype.getBoxForZoomStep = function(zoomStep) {
	    return {
	      min: _.map(this.min, (function(_this) {
	        return function(e) {
	          return e >> (_this.BUCKET_SIZE_P + zoomStep);
	        };
	      })(this)),
	      max: _.map(this.max, (function(_this) {
	        return function(e) {
	          return e >> (_this.BUCKET_SIZE_P + zoomStep);
	        };
	      })(this))
	    };
	  };
	
	  BoundingBox.prototype.containsBucket = function(arg) {
	    var max, min, ref, x, y, z, zoomStep;
	    x = arg[0], y = arg[1], z = arg[2], zoomStep = arg[3];
	    if (this.boundingBox == null) {
	      return true;
	    }
	    ref = this.getBoxForZoomStep(zoomStep), min = ref.min, max = ref.max;
	    return (min[0] <= x && x <= max[0]) && (min[1] <= y && y <= max[1]) && (min[2] <= z && z <= max[2]);
	  };
	
	  BoundingBox.prototype.containsFullBucket = function(arg) {
	    var max, min, ref, x, y, z, zoomStep;
	    x = arg[0], y = arg[1], z = arg[2], zoomStep = arg[3];
	    if (this.boundingBox == null) {
	      return true;
	    }
	    ref = this.getBoxForZoomStep(zoomStep), min = ref.min, max = ref.max;
	    return (min[0] < x && x < max[0]) && (min[1] < y && y < max[1]) && (min[2] < z && z < max[2]);
	  };
	
	  BoundingBox.prototype.removeOutsideArea = function(bucket, bucketData) {
	    var b, baseVoxel, dx, dy, dz, i, index, j, k, l, ref, ref1, ref2, ref3, x, y, z;
	    if (this.containsFullBucket(bucket)) {
	      return;
	    }
	    baseVoxel = _.map(bucket.slice(0, 3), (function(_this) {
	      return function(e) {
	        return e << (_this.BUCKET_SIZE_P + bucket[3]);
	      };
	    })(this));
	    for (dx = i = 0, ref = 1 << this.BUCKET_SIZE_P; 0 <= ref ? i < ref : i > ref; dx = 0 <= ref ? ++i : --i) {
	      for (dy = j = 0, ref1 = 1 << this.BUCKET_SIZE_P; 0 <= ref1 ? j < ref1 : j > ref1; dy = 0 <= ref1 ? ++j : --j) {
	        for (dz = k = 0, ref2 = 1 << this.BUCKET_SIZE_P; 0 <= ref2 ? k < ref2 : k > ref2; dz = 0 <= ref2 ? ++k : --k) {
	          x = baseVoxel[0] + (dx << bucket[3]);
	          y = baseVoxel[1] + (dy << bucket[3]);
	          z = baseVoxel[2] + (dz << bucket[3]);
	          if ((this.min[0] <= x && x <= this.max[0]) && (this.min[1] <= y && y <= this.max[1]) && (this.min[2] <= z && z <= this.max[2])) {
	            continue;
	          }
	          index = this.cube.getVoxelIndexByVoxelOffset([dx, dy, dz]);
	          for (b = l = 0, ref3 = this.BYTE_OFFSET; 0 <= ref3 ? l < ref3 : l > ref3; b = 0 <= ref3 ? ++l : --l) {
	            bucketData[index + b] = 0;
	          }
	        }
	      }
	    }
	  };
	
	  return BoundingBox;
	
	})();
	
	module.exports = BoundingBox;


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var ErrorHandling, Mappings, Request, _;
	
	_ = __webpack_require__(2);
	
	Request = __webpack_require__(17);
	
	ErrorHandling = __webpack_require__(5);
	
	Mappings = (function() {
	  function Mappings(datasetName, layer) {
	    this.mappings = _.indexBy(layer.mappings, "name");
	    this.baseUrl = "/data/datasets/" + datasetName + "/layers/" + layer.name + "/mappings/";
	    this.getParams = "?token=" + layer.token;
	  }
	
	  Mappings.prototype.getMappingNames = function() {
	    return _.keys(this.mappings);
	  };
	
	  Mappings.prototype.getMappingArrayAsync = function(mappingName) {
	    return this.fetchMappings(mappingName).then((function(_this) {
	      return function() {
	        return _this.getMappingArray(mappingName);
	      };
	    })(this));
	  };
	
	  Mappings.prototype.fetchMappings = function(mappingName) {
	    var mappingChain, promises;
	    mappingChain = this.getMappingChain(mappingName);
	    promises = _.map(mappingChain, (function(_this) {
	      return function(mappingName) {
	        return _this.fetchMapping(mappingName);
	      };
	    })(this));
	    return Promise.all(promises);
	  };
	
	  Mappings.prototype.fetchMapping = function(mappingName) {
	    if (this.mappings[mappingName].mappingObject != null) {
	      return Promise.resolve();
	    }
	    return Request.receiveJSON(this.baseUrl + mappingName + this.getParams).then((function(_this) {
	      return function(mapping) {
	        _this.mappings[mappingName].mappingObject = mapping;
	        return console.log("Done downloading:", mappingName);
	      };
	    })(this), function(error) {
	      return console.error("Error downloading:", mappingName, error);
	    });
	  };
	
	  Mappings.prototype.getMappingArray = function(mappingName) {
	    var mapping;
	    mapping = this.mappings[mappingName];
	    if (mapping.mappingArray != null) {
	      return mapping.mappingArray;
	    }
	    return mapping.mappingArray = this.buildMappingArray(mappingName);
	  };
	
	  Mappings.prototype.buildMappingArray = function(mappingName) {
	    var currentMappingName, i, id, j, k, len, len1, len2, mappedId, mappingArray, mappingClass, mappingObject, minId, ref, ref1;
	    mappingArray = [];
	    ref = this.getMappingChain(mappingName);
	    for (i = 0, len = ref.length; i < len; i++) {
	      currentMappingName = ref[i];
	      mappingObject = this.mappings[currentMappingName].mappingObject;
	      ErrorHandling.assert(mappingObject, "mappingObject must have been fetched at this point");
	      ref1 = mappingObject.classes;
	      for (j = 0, len1 = ref1.length; j < len1; j++) {
	        mappingClass = ref1[j];
	        minId = this.min(mappingClass);
	        mappedId = mappingArray[minId] || minId;
	        for (k = 0, len2 = mappingClass.length; k < len2; k++) {
	          id = mappingClass[k];
	          mappingArray[id] = mappedId;
	        }
	      }
	    }
	    return mappingArray;
	  };
	
	  Mappings.prototype.getMappingChain = function(mappingName) {
	    var chain, mapping;
	    chain = [mappingName];
	    mapping = this.mappings[mappingName];
	    while (mapping.parent != null) {
	      chain.push(mapping.parent);
	      mapping = this.mappings[mapping.parent];
	    }
	    return chain;
	  };
	
	  Mappings.prototype.min = function(array) {
	    var entry, i, len, min;
	    min = Infinity;
	    for (i = 0, len = array.length; i < len; i++) {
	      entry = array[i];
	      min = Math.min(min, entry);
	    }
	    return min;
	  };
	
	  return Mappings;
	
	})();
	
	module.exports = Mappings;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var Deferred, Pipeline, _,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	_ = __webpack_require__(2);
	
	Deferred = __webpack_require__(284);
	
	Pipeline = (function() {
	  function Pipeline(firstArguments, options) {
	    this.options = options != null ? options : {};
	    this.executeNext = bind(this.executeNext, this);
	    this.actions = [];
	    this.nextArguments = firstArguments;
	    this.retryCount = 0;
	    this.running = false;
	    this.failed = false;
	    _.defaults(this.options, {
	      maxRetry: 3,
	      retryTimeMs: 1000
	    });
	  }
	
	  Pipeline.prototype.getLastActionPromise = function() {
	    if (this.actions.length === 0) {
	      return Promise.resolve();
	    }
	    return this.actions[this.actions.length - 1]._deferred.promise();
	  };
	
	  Pipeline.prototype.executeAction = function(action) {
	    action._deferred = new Deferred();
	    this.actions.push(action);
	    if (!this.running) {
	      this.executeNext();
	    }
	    return action._deferred.promise();
	  };
	
	  Pipeline.prototype.executePassAlongAction = function(action) {
	    var newAction;
	    newAction = function() {
	      var args;
	      args = arguments;
	      return action.apply(null, args).then(function() {
	        return args[0];
	      });
	    };
	    return this.executeAction(newAction);
	  };
	
	  Pipeline.prototype.executeActions = function(actionList) {
	    var action, i, len, promise;
	    for (i = 0, len = actionList.length; i < len; i++) {
	      action = actionList[i];
	      promise = this.executeAction(action);
	    }
	    return promise;
	  };
	
	  Pipeline.prototype.restart = function() {
	    if (this.failed && this.actions.length > 0) {
	      this.failed = false;
	      this.retryCount = 0;
	      this.running = false;
	      return this.executeAction(this.actions.shift());
	    }
	    return Promise.resolve();
	  };
	
	  Pipeline.prototype.executeNext = function() {
	    var currentAction;
	    currentAction = this.actions.shift();
	    if (currentAction != null) {
	      this.running = true;
	      return currentAction.apply(null, this.nextArguments).then((function(_this) {
	        return function(response) {
	          currentAction._deferred.resolve(response);
	          _this.nextArguments = arguments;
	          _this.retryCount = 0;
	          return _this.executeNext();
	        };
	      })(this), (function(_this) {
	        return function(response) {
	          _this.retryCount++;
	          _this.actions.unshift(currentAction);
	          if (_this.retryCount >= _this.options.maxRetry) {
	            _this.failed = true;
	            return currentAction._deferred.reject(response);
	          } else {
	            return setTimeout(_this.executeNext, _this.options.retryTimeMs);
	          }
	        };
	      })(this));
	    } else {
	      return this.running = false;
	    }
	  };
	
	  return Pipeline;
	
	})();
	
	module.exports = Pipeline;


/***/ },
/* 284 */
/***/ function(module, exports) {

	var Deferred;
	
	Deferred = (function() {
	  function Deferred() {
	    this._resolve = null;
	    this._reject = null;
	    this._promise = new Promise((function(_this) {
	      return function(resolve, reject) {
	        _this._resolve = resolve;
	        return _this._reject = reject;
	      };
	    })(this));
	  }
	
	  Deferred.prototype.resolve = function(arg) {
	    return this._resolve(arg);
	  };
	
	  Deferred.prototype.reject = function(arg) {
	    return this._reject(arg);
	  };
	
	  Deferred.prototype.promise = function() {
	    return this._promise;
	  };
	
	  return Deferred;
	
	})();
	
	module.exports = Deferred;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, ColorGenerator, CommentsCollection, Request, RestrictionHandler, SkeletonTracing, SkeletonTracingStateLogger, TracePoint, TraceTree, TracingParser, _, app, backbone, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	_ = __webpack_require__(2);
	
	backbone = __webpack_require__(3);
	
	Request = __webpack_require__(17);
	
	ColorGenerator = __webpack_require__(286);
	
	TracePoint = __webpack_require__(287);
	
	TraceTree = __webpack_require__(288);
	
	SkeletonTracingStateLogger = __webpack_require__(289);
	
	constants = __webpack_require__(61);
	
	RestrictionHandler = __webpack_require__(291);
	
	TracingParser = __webpack_require__(292);
	
	CommentsCollection = __webpack_require__(293);
	
	SkeletonTracing = (function() {
	  SkeletonTracing.prototype.TYPE_USUAL = constants.TYPE_USUAL;
	
	  SkeletonTracing.prototype.TYPE_BRANCH = constants.TYPE_BRANCH;
	
	  SkeletonTracing.prototype.MIN_RADIUS = 1;
	
	  SkeletonTracing.prototype.MAX_RADIUS = 5000;
	
	  SkeletonTracing.prototype.branchStack = [];
	
	  SkeletonTracing.prototype.trees = [];
	
	  SkeletonTracing.prototype.comments = new CommentsCollection();
	
	  SkeletonTracing.prototype.activeNode = null;
	
	  SkeletonTracing.prototype.activeTree = null;
	
	  SkeletonTracing.prototype.firstEdgeDirection = null;
	
	  function SkeletonTracing(tracing, flycam, flycam3d, user) {
	    var edge, j, k, len, len1, ref, ref1, ref2, ref3, sourceNode, targetNode, tracingParser, tracingType, tree;
	    this.flycam = flycam;
	    this.flycam3d = flycam3d;
	    this.user = user;
	    this.getPlainComments = bind(this.getPlainComments, this);
	    this.getPlainComments = bind(this.getPlainComments, this);
	    this.getComments = bind(this.getComments, this);
	    _.extend(this, Backbone.Events);
	    this.doubleBranchPop = false;
	    this.data = tracing.content.contentData;
	    this.restrictionHandler = new RestrictionHandler(tracing.restrictions);
	    this.stateLogger = new SkeletonTracingStateLogger(this.flycam, this.flycam3d, tracing.version, tracing.id, tracing.typ, tracing.restrictions.allowUpdate, this);
	    tracingParser = new TracingParser(this, this.data);
	    ref = tracingParser.parse(), this.idCount = ref.idCount, this.treeIdCount = ref.treeIdCount, this.trees = ref.trees, this.comments = ref.comments, this.activeNode = ref.activeNode, this.activeTree = ref.activeTree;
	    this.colorIdCounter = this.treeIdCount;
	    ref1 = this.trees;
	    for (j = 0, len = ref1.length; j < len; j++) {
	      tree = ref1[j];
	      if (tree.color == null) {
	        this.shuffleTreeColor(tree);
	      }
	    }
	    if (!this.activeTree) {
	      if (this.trees.length > 0) {
	        this.activeTree = this.trees[0];
	      } else {
	        this.createNewTree();
	      }
	    }
	    tracingType = tracing.typ;
	    if ((tracingType === "Task") && this.getNodeListOfAllTrees().length === 0) {
	      this.addNode(tracing.content.editPosition, tracing.content.editRotation, this.TYPE_USUAL, 0, 0, 4, false);
	    }
	    this.branchPointsAllowed = tracing.content.settings.branchPointsAllowed;
	    if (!this.branchPointsAllowed) {
	      this.TYPE_BRANCH = this.TYPE_USUAL;
	      if (((ref2 = this.data.trees[0]) != null ? ref2.edges : void 0) != null) {
	        ref3 = this.data.trees[0].edges;
	        for (k = 0, len1 = ref3.length; k < len1; k++) {
	          edge = ref3[k];
	          sourceNode = this.findNodeInList(this.trees[0].nodes, edge.source).pos;
	          targetNode = this.findNodeInList(this.trees[0].nodes, edge.target).pos;
	          if (sourceNode[0] !== targetNode[0] || sourceNode[1] !== targetNode[1] || sourceNode[2] !== targetNode[2]) {
	            this.firstEdgeDirection = [targetNode[0] - sourceNode[0], targetNode[1] - sourceNode[1], targetNode[2] - sourceNode[2]];
	            break;
	          }
	        }
	      }
	      if (this.firstEdgeDirection) {
	        this.flycam.setSpaceDirection(this.firstEdgeDirection);
	      }
	    }
	    app.router.on("beforeunload", (function(_this) {
	      return function() {
	        if (!_this.stateLogger.stateSaved() && _this.stateLogger.allowUpdate) {
	          _this.stateLogger.pushNow(false);
	          return "You haven't saved your progress, please give us 2 seconds to do so and and then leave this site.";
	        } else {
	
	        }
	      };
	    })(this));
	  }
	
	  SkeletonTracing.prototype.benchmark = function(numberOfTrees, numberOfNodesPerTree) {
	    var centered, i, j, k, offset, point, pos, ref, ref1, size, startTime;
	    if (numberOfTrees == null) {
	      numberOfTrees = 1;
	    }
	    if (numberOfNodesPerTree == null) {
	      numberOfNodesPerTree = 10000;
	    }
	    console.log("[benchmark] start inserting " + numberOfNodesPerTree + " nodes");
	    startTime = (new Date()).getTime();
	    offset = 0;
	    size = numberOfNodesPerTree / 10;
	    for (i = j = 0, ref = numberOfTrees; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      this.createNewTree();
	      for (i = k = 0, ref1 = numberOfNodesPerTree; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
	        pos = [Math.random() * size + offset, Math.random() * size + offset, Math.random() * size + offset];
	        point = new TracePoint(this.TYPE_USUAL, this.idCount++, pos, Math.random() * 200, this.activeTree.treeId, null, [0, 0, 0]);
	        this.activeTree.nodes.push(point);
	        if (this.activeNode) {
	          this.activeNode.appendNext(point);
	          point.appendNext(this.activeNode);
	          this.activeNode = point;
	        } else {
	          this.activeNode = point;
	          point.type = this.TYPE_BRANCH;
	          if (this.branchPointsAllowed) {
	            centered = true;
	            this.pushBranch();
	          }
	        }
	        this.doubleBranchPop = false;
	      }
	      offset += size;
	    }
	    this.trigger("reloadTrees");
	    return console.log("[benchmark] done. Took me " + (((new Date()).getTime() - startTime) / 1000) + " seconds.");
	  };
	
	  SkeletonTracing.prototype.pushBranch = function() {
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (this.branchPointsAllowed) {
	      if (this.activeNode) {
	        this.branchStack.push(this.activeNode);
	        this.activeNode.type = this.TYPE_BRANCH;
	        this.stateLogger.push();
	        return this.trigger("setBranch", true, this.activeNode);
	      }
	    } else {
	      return this.trigger("noBranchPoints");
	    }
	  };
	
	  SkeletonTracing.prototype.popBranch = function() {
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        var point;
	        if (_this.branchPointsAllowed) {
	          if (_this.branchStack.length && _this.doubleBranchPop) {
	            return _this.trigger("doubleBranch", function() {
	              var point;
	              point = _this.branchStack.pop();
	              _this.stateLogger.push();
	              _this.setActiveNode(point.id);
	              _this.activeNode.type = _this.TYPE_USUAL;
	              _this.trigger("setBranch", false, _this.activeNode);
	              _this.doubleBranchPop = true;
	              return resolve(_this.activeNode.id);
	            });
	          } else {
	            point = _this.branchStack.pop();
	            _this.stateLogger.push();
	            if (point) {
	              _this.setActiveNode(point.id);
	              _this.activeNode.type = _this.TYPE_USUAL;
	              _this.trigger("setBranch", false, _this.activeNode);
	              _this.doubleBranchPop = true;
	              return resolve(_this.activeNode.id);
	            } else {
	              _this.trigger("emptyBranchStack");
	              return reject();
	            }
	          }
	        } else {
	          _this.trigger("noBranchPoints");
	          return reject();
	        }
	      };
	    })(this));
	  };
	
	  SkeletonTracing.prototype.deleteBranch = function(node) {
	    var i, results;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (node.type !== this.TYPE_BRANCH) {
	      return;
	    }
	    i = 0;
	    results = [];
	    while (i < this.branchStack.length) {
	      if (this.branchStack[i].id === node.id) {
	        results.push(this.branchStack.splice(i, 1));
	      } else {
	        results.push(i++);
	      }
	    }
	    return results;
	  };
	
	  SkeletonTracing.prototype.isBranchPoint = function(id) {
	    var node;
	    return indexOf.call((function() {
	      var j, len, ref, results;
	      ref = this.branchStack;
	      results = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        node = ref[j];
	        results.push(node.id);
	      }
	      return results;
	    }).call(this), id) >= 0;
	  };
	
	  SkeletonTracing.prototype.addNode = function(position, rotation, type, viewport, resolution, bitDepth, interpolation) {
	    var metaInfo, point, radius;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (this.ensureDirection(position)) {
	      radius = 10 * app.scaleInfo.baseVoxel;
	      if (this.activeNode) {
	        radius = this.activeNode.radius;
	      }
	      metaInfo = {
	        timestamp: (new Date()).getTime(),
	        viewport: viewport,
	        resolution: resolution,
	        bitDepth: bitDepth,
	        interpolation: interpolation
	      };
	      point = new TracePoint(type, this.idCount++, position, radius, this.activeTree.treeId, metaInfo, rotation);
	      this.activeTree.nodes.push(point);
	      if (this.activeNode) {
	        this.activeNode.appendNext(point);
	        point.appendNext(this.activeNode);
	        this.activeNode = point;
	      } else {
	        this.activeNode = point;
	        point.type = this.TYPE_BRANCH;
	        if (this.branchPointsAllowed) {
	          this.pushBranch();
	        }
	      }
	      this.doubleBranchPop = false;
	      this.stateLogger.createNode(point, this.activeTree.treeId);
	      this.trigger("newNode", this.activeNode.id, this.activeTree.treeId);
	      return this.trigger("newActiveNode", this.activeNode.id);
	    } else {
	      return this.trigger("wrongDirection");
	    }
	  };
	
	  SkeletonTracing.prototype.ensureDirection = function(position) {
	    var secondEdgeDirection, sourceNodeNm, targetNodeNm;
	    if (!this.branchPointsAllowed && this.activeTree.nodes.length === 2 && this.firstEdgeDirection && this.activeTree.treeId === this.trees[0].treeId) {
	      sourceNodeNm = app.scaleInfo.voxelToNm(this.activeTree.nodes[1].pos);
	      targetNodeNm = app.scaleInfo.voxelToNm(position);
	      secondEdgeDirection = [targetNodeNm[0] - sourceNodeNm[0], targetNodeNm[1] - sourceNodeNm[1], targetNodeNm[2] - sourceNodeNm[2]];
	      return this.firstEdgeDirection[0] * secondEdgeDirection[0] + this.firstEdgeDirection[1] * secondEdgeDirection[1] + this.firstEdgeDirection[2] * secondEdgeDirection[2] > 0;
	    } else {
	      return true;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveNode = function() {
	    return this.activeNode;
	  };
	
	  SkeletonTracing.prototype.getActiveNodeId = function() {
	    if (this.activeNode) {
	      return this.activeNode.id;
	    } else {
	      return null;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveNodePos = function() {
	    if (this.activeNode) {
	      return this.activeNode.pos;
	    } else {
	      return null;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveNodeType = function() {
	    if (this.activeNode) {
	      return this.activeNode.type;
	    } else {
	      return null;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveNodeRadius = function() {
	    if (this.activeNode) {
	      return this.activeNode.radius;
	    } else {
	      return 10 * app.scaleInfo.baseVoxel;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveNodeRotation = function() {
	    if (this.activeNode) {
	      return this.activeNode.rotation;
	    } else {
	      return null;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveTreeId = function() {
	    if (this.activeTree) {
	      return this.activeTree.treeId;
	    } else {
	      return null;
	    }
	  };
	
	  SkeletonTracing.prototype.getActiveTreeName = function() {
	    if (this.activeTree) {
	      return this.activeTree.name;
	    } else {
	      return null;
	    }
	  };
	
	  SkeletonTracing.prototype.setTreeName = function(name) {
	    if (this.activeTree) {
	      if (name) {
	        this.activeTree.name = name;
	      } else {
	        this.activeTree.name = "Tree" + (('00' + this.activeTree.treeId).slice(-3));
	      }
	      this.stateLogger.updateTree(this.activeTree);
	      return this.trigger("newTreeName", this.activeTree.treeId);
	    }
	  };
	
	  SkeletonTracing.prototype.getNode = function(id) {
	    var j, k, len, len1, node, ref, ref1, tree;
	    ref = this.trees;
	    for (j = 0, len = ref.length; j < len; j++) {
	      tree = ref[j];
	      ref1 = tree.nodes;
	      for (k = 0, len1 = ref1.length; k < len1; k++) {
	        node = ref1[k];
	        if (node.id === id) {
	          return node;
	        }
	      }
	    }
	    return null;
	  };
	
	  SkeletonTracing.prototype.setActiveNode = function(nodeID, mergeTree) {
	    var j, k, lastActiveNode, lastActiveTree, len, len1, node, ref, ref1, tree;
	    if (mergeTree == null) {
	      mergeTree = false;
	    }
	    lastActiveNode = this.activeNode;
	    lastActiveTree = this.activeTree;
	    ref = this.trees;
	    for (j = 0, len = ref.length; j < len; j++) {
	      tree = ref[j];
	      ref1 = tree.nodes;
	      for (k = 0, len1 = ref1.length; k < len1; k++) {
	        node = ref1[k];
	        if (node.id === nodeID) {
	          this.activeNode = node;
	          this.activeTree = tree;
	          break;
	        }
	      }
	    }
	    this.stateLogger.push();
	    this.trigger("newActiveNode", this.activeNode.id);
	    if (mergeTree) {
	      return this.mergeTree(lastActiveNode, lastActiveTree);
	    }
	  };
	
	  SkeletonTracing.prototype.setActiveNodeRadius = function(radius) {
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (this.activeNode != null) {
	      this.activeNode.radius = Math.min(this.MAX_RADIUS, Math.max(this.MIN_RADIUS, radius));
	      this.stateLogger.updateNode(this.activeNode, this.activeNode.treeId);
	      return this.trigger("newActiveNodeRadius", radius);
	    }
	  };
	
	  SkeletonTracing.prototype.setComment = function(commentText) {
	    var i, j, ref;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (this.activeNode) {
	      for (i = j = 0, ref = this.comments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	        if (this.comments[i].node.id === this.activeNode.id) {
	          this.comments.splice(i, 1);
	          this.deletedCommentIndex = i;
	          break;
	        }
	      }
	      if (commentText !== "") {
	        this.comments.push({
	          node: this.activeNode,
	          content: commentText
	        });
	      }
	      this.stateLogger.push();
	      return this.trigger("updateComments");
	    }
	  };
	
	  SkeletonTracing.prototype.getComment = function(nodeID) {
	    var comment, j, len, ref;
	    if (nodeID == null) {
	      if (this.activeNode) {
	        nodeID = this.activeNode.id;
	      }
	    }
	    ref = this.comments;
	    for (j = 0, len = ref.length; j < len; j++) {
	      comment = ref[j];
	      if (comment.node.id === nodeID) {
	        return comment.content;
	      }
	    }
	    return "";
	  };
	
	  SkeletonTracing.prototype.deleteComment = function(nodeID) {
	    var i, j, ref, results;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    results = [];
	    for (i = j = 0, ref = this.comments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (this.comments[i].node.id === nodeID) {
	        this.comments.splice(i, 1);
	        this.stateLogger.push();
	        this.trigger("updateComments");
	        break;
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  SkeletonTracing.prototype.nextCommentNodeID = function(forward) {
	    var i, j, length, offset, ref;
	    length = this.comments.length;
	    offset = forward ? 1 : -1;
	    if (!this.activeNode) {
	      if (length > 0) {
	        return this.comments[0].node.id;
	      }
	    }
	    if (length === 0) {
	      return null;
	    }
	    for (i = j = 0, ref = this.comments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (this.comments[i].node.id === this.activeNode.id) {
	        return this.comments[(length + i + offset) % length].node.id;
	      }
	    }
	    if (this.deletedCommentIndex != null) {
	      offset = forward ? 0 : -1;
	      return this.comments[(length + this.deletedCommentIndex + offset) % length].node.id;
	    }
	    return this.comments[0].node.id;
	  };
	
	  SkeletonTracing.prototype.getComments = function(ascendingOrder) {
	    if (ascendingOrder == null) {
	      ascendingOrder = true;
	    }
	    this.comments.sort(this.compareNodes);
	    if (!ascendingOrder) {
	      return this.comments.reverse();
	    }
	    return this.comments;
	  };
	
	  SkeletonTracing.prototype.getPlainComments = function() {
	    var comment, j, len, plainComments, ref;
	    plainComments = [];
	    ref = this.comments;
	    for (j = 0, len = ref.length; j < len; j++) {
	      comment = ref[j];
	      plainComments.push({
	        node: comment.node.id,
	        content: comment.content
	      });
	    }
	    return plainComments;
	  };
	
	  SkeletonTracing.prototype.selectNextTree = function(forward) {
	    var diff, i, j, ref, trees;
	    trees = this.getTreesSorted(this.user.get("sortTreesByName"));
	    for (i = j = 0, ref = trees.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (this.activeTree.treeId === trees[i].treeId) {
	        break;
	      }
	    }
	    diff = (forward ? 1 : -1) + trees.length;
	    return this.setActiveTree(trees[(i + diff) % trees.length].treeId);
	  };
	
	  SkeletonTracing.prototype.centerActiveNode = function() {
	    var position;
	    position = this.getActiveNodePos();
	    if (position) {
	      return this.flycam.setPosition(position);
	    }
	  };
	
	  SkeletonTracing.prototype.setActiveTree = function(id) {
	    var j, len, ref, tree;
	    ref = this.trees;
	    for (j = 0, len = ref.length; j < len; j++) {
	      tree = ref[j];
	      if (tree.treeId === id) {
	        this.activeTree = tree;
	        break;
	      }
	    }
	    if (this.activeTree.nodes.length === 0) {
	      this.activeNode = null;
	    } else {
	      this.activeNode = this.activeTree.nodes[0];
	      this.trigger("newActiveNode", this.activeNode.id);
	    }
	    this.stateLogger.push();
	    return this.trigger("newActiveTree", this.activeTree.treeId);
	  };
	
	  SkeletonTracing.prototype.getNewTreeColor = function() {
	    return ColorGenerator.distinctColorForId(this.colorIdCounter++);
	  };
	
	  SkeletonTracing.prototype.shuffleTreeColor = function(tree) {
	    if (!tree) {
	      tree = this.activeTree;
	    }
	    tree.color = this.getNewTreeColor();
	    if (this.restrictionHandler.handleUpdate()) {
	      this.stateLogger.updateTree(tree);
	    }
	    return this.trigger("newTreeColor", tree.treeId);
	  };
	
	  SkeletonTracing.prototype.shuffleAllTreeColors = function() {
	    var j, len, ref, results, tree;
	    ref = this.trees;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      tree = ref[j];
	      results.push(this.shuffleTreeColor(tree));
	    }
	    return results;
	  };
	
	  SkeletonTracing.prototype.createNewTree = function() {
	    var tree;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    tree = new TraceTree(this.treeIdCount++, this.getNewTreeColor(), "Tree" + (('00' + (this.treeIdCount - 1)).slice(-3)), (new Date()).getTime());
	    this.trees.push(tree);
	    this.activeTree = tree;
	    this.activeNode = null;
	    this.stateLogger.createTree(tree);
	    return this.trigger("newTree", tree.treeId, tree.color);
	  };
	
	  SkeletonTracing.prototype.deleteActiveNode = function() {
	    var deletedNode, i, j, k, l, len, len1, len2, m, neighbor, newTrees, node, nodeIds, oldActiveTreeId, ref, ref1, ref2, ref3;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (!this.activeNode) {
	      return;
	    }
	    this.trigger("deleteComment", this.activeNode.id);
	    ref = this.activeNode.neighbors;
	    for (j = 0, len = ref.length; j < len; j++) {
	      neighbor = ref[j];
	      neighbor.removeNeighbor(this.activeNode.id);
	    }
	    this.activeTree.removeNode(this.activeNode.id);
	    deletedNode = this.activeNode;
	    this.stateLogger.deleteNode(deletedNode, this.activeTree.treeId);
	    this.deleteBranch(deletedNode);
	    if (deletedNode.neighbors.length > 1) {
	      newTrees = [];
	      oldActiveTreeId = this.activeTree.treeId;
	      for (i = k = 0, ref1 = this.activeNode.neighbors.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
	        if (i !== 0) {
	          this.createNewTree();
	        }
	        this.activeTree.nodes = [];
	        this.getNodeListForRoot(this.activeTree.nodes, deletedNode.neighbors[i]);
	        if (i !== 0) {
	          ref2 = this.activeTree.nodes;
	          for (l = 0, len1 = ref2.length; l < len1; l++) {
	            node = ref2[l];
	            node.treeId = this.activeTree.treeId;
	          }
	        }
	        this.setActiveNode(deletedNode.neighbors[i].id);
	        newTrees.push(this.activeTree);
	        if (this.activeTree.treeId !== oldActiveTreeId) {
	          nodeIds = [];
	          ref3 = this.activeTree.nodes;
	          for (m = 0, len2 = ref3.length; m < len2; m++) {
	            node = ref3[m];
	            nodeIds.push(node.id);
	          }
	          this.stateLogger.moveTreeComponent(oldActiveTreeId, this.activeTree.treeId, nodeIds);
	        }
	      }
	      return this.trigger("reloadTrees", newTrees);
	    } else if (this.activeNode.neighbors.length === 1) {
	      this.setActiveNode(deletedNode.neighbors[0].id);
	      return this.trigger("deleteActiveNode", deletedNode, this.activeTree.treeId);
	    } else {
	      return this.deleteTree(false);
	    }
	  };
	
	  SkeletonTracing.prototype.deleteTree = function(notify, id, deleteBranchesAndComments, notifyServer) {
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (notify) {
	      if (confirm("Do you really want to delete the whole tree?")) {
	        return this.reallyDeleteTree(id, deleteBranchesAndComments, notifyServer);
	      } else {
	
	      }
	    } else {
	      return this.reallyDeleteTree(id, deleteBranchesAndComments, notifyServer);
	    }
	  };
	
	  SkeletonTracing.prototype.reallyDeleteTree = function(id, deleteBranchesAndComments, notifyServer) {
	    var i, index, j, k, len, node, ref, ref1, tree;
	    if (deleteBranchesAndComments == null) {
	      deleteBranchesAndComments = true;
	    }
	    if (notifyServer == null) {
	      notifyServer = true;
	    }
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (!id) {
	      id = this.activeTree.treeId;
	    }
	    tree = this.getTree(id);
	    for (i = j = 0, ref = this.trees.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
	      if (this.trees[i].treeId === tree.treeId) {
	        index = i;
	        break;
	      }
	    }
	    this.trees.splice(index, 1);
	    ref1 = tree.nodes;
	    for (k = 0, len = ref1.length; k < len; k++) {
	      node = ref1[k];
	      if (deleteBranchesAndComments) {
	        this.trigger("deleteComment", node.id);
	        this.deleteBranch(node);
	      }
	    }
	    if (notifyServer) {
	      this.stateLogger.deleteTree(tree);
	    }
	    this.trigger("deleteTree", index);
	    if (this.trees.length === 0) {
	      return this.createNewTree();
	    } else {
	      return this.setActiveTree(this.trees[this.trees.length - 1].treeId);
	    }
	  };
	
	  SkeletonTracing.prototype.mergeTree = function(lastNode, lastTree) {
	    var activeNodeID, j, len, node, ref;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (!lastNode) {
	      return;
	    }
	    activeNodeID = this.activeNode.id;
	    if (lastNode.id !== activeNodeID) {
	      if (lastTree.treeId !== this.activeTree.treeId) {
	        this.activeTree.nodes = this.activeTree.nodes.concat(lastTree.nodes);
	        this.activeNode.appendNext(lastNode);
	        lastNode.appendNext(this.activeNode);
	        ref = this.activeTree.nodes;
	        for (j = 0, len = ref.length; j < len; j++) {
	          node = ref[j];
	          node.treeId = this.activeTree.treeId;
	        }
	        this.stateLogger.mergeTree(lastTree, this.activeTree, lastNode.id, activeNodeID);
	        this.trigger("mergeTree", lastTree.treeId, lastNode, this.activeNode);
	        this.deleteTree(false, lastTree.treeId, false, false);
	        return this.setActiveNode(activeNodeID);
	      } else {
	        return this.trigger("mergeDifferentTrees");
	      }
	    }
	  };
	
	  SkeletonTracing.prototype.getTree = function(id) {
	    var j, len, ref, tree;
	    if (!id) {
	      return this.activeTree;
	    }
	    ref = this.trees;
	    for (j = 0, len = ref.length; j < len; j++) {
	      tree = ref[j];
	      if (tree.treeId === id) {
	        return tree;
	      }
	    }
	    return null;
	  };
	
	  SkeletonTracing.prototype.getTrees = function() {
	    return this.trees;
	  };
	
	  SkeletonTracing.prototype.getTreesSorted = function() {
	    if (this.user.get("sortTreesByName")) {
	      return (this.trees.slice(0)).sort(this.compareNames);
	    } else {
	      return (this.trees.slice(0)).sort(this.compareTimestamps);
	    }
	  };
	
	  SkeletonTracing.prototype.getNodeListForRoot = function(result, root, previous) {
	    var j, len, neighbor, newNext, next;
	    result.push(root);
	    next = root.getNext(previous);
	    while (next != null) {
	      if (_.isArray(next)) {
	        for (j = 0, len = next.length; j < len; j++) {
	          neighbor = next[j];
	          this.getNodeListForRoot(result, neighbor, root);
	        }
	        return;
	      } else {
	        result.push(next);
	        newNext = next.getNext(root);
	        root = next;
	        next = newNext;
	      }
	    }
	  };
	
	  SkeletonTracing.prototype.getNodeListOfAllTrees = function() {
	    var j, len, ref, result, tree;
	    result = [];
	    ref = this.trees;
	    for (j = 0, len = ref.length; j < len; j++) {
	      tree = ref[j];
	      result = result.concat(tree.nodes);
	    }
	    return result;
	  };
	
	  SkeletonTracing.prototype.findNodeInList = function(list, id) {
	    var j, len, node;
	    for (j = 0, len = list.length; j < len; j++) {
	      node = list[j];
	      if (node.id === id) {
	        return node;
	      }
	    }
	    return null;
	  };
	
	  SkeletonTracing.prototype.compareNames = function(a, b) {
	    if (a.name < b.name) {
	      return -1;
	    }
	    if (a.name > b.name) {
	      return 1;
	    }
	    return 0;
	  };
	
	  SkeletonTracing.prototype.compareTimestamps = function(a, b) {
	    if (a.timestamp < b.timestamp) {
	      return -1;
	    }
	    if (a.timestamp > b.timestamp) {
	      return 1;
	    }
	    return 0;
	  };
	
	  SkeletonTracing.prototype.compareNodes = function(a, b) {
	    if (a.node.treeId < b.node.treeId) {
	      return -1;
	    }
	    if (a.node.treeId > b.node.treeId) {
	      return 1;
	    }
	    return a.node.id - b.node.id;
	  };
	
	  SkeletonTracing.prototype.getPlainComments = function() {
	    return this.comments.toJSON();
	  };
	
	  return SkeletonTracing;
	
	})();
	
	module.exports = SkeletonTracing;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var ColorConverter, ColorGenerator, GOLDEN_RATIO, THREE;
	
	THREE = __webpack_require__(245);
	
	ColorConverter = __webpack_require__(244);
	
	GOLDEN_RATIO = 0.618033988749895;
	
	ColorGenerator = {
	  distinctColorForId: function(id) {
	    var hue;
	    hue = id * GOLDEN_RATIO;
	    hue %= 1;
	    return ColorConverter.setHSV(new THREE.Color(), hue, 1, 1).getHex();
	  }
	};
	
	module.exports = ColorGenerator;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var TracePoint,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	TracePoint = (function() {
	  function TracePoint(type, id1, pos, radius, treeId, metaInfo, rotation) {
	    this.type = type;
	    this.id = id1;
	    this.pos = pos;
	    this.radius = radius;
	    this.treeId = treeId;
	    this.metaInfo = metaInfo;
	    this.rotation = rotation;
	    this.setChildRelation = bind(this.setChildRelation, this);
	    this.neighbors = [];
	  }
	
	  TracePoint.prototype.appendNext = function(next) {
	    return this.neighbors.push(next);
	  };
	
	  TracePoint.prototype.getNext = function(parent) {
	    var j, k, len, len1, minN, neighbor, ref, ref1, res;
	    if (parent != null) {
	      minN = 2;
	    } else {
	      minN = 1;
	    }
	    if (this.neighbors.length < minN) {
	      return null;
	    }
	    if (this.neighbors.length === minN) {
	      ref = this.neighbors;
	      for (j = 0, len = ref.length; j < len; j++) {
	        neighbor = ref[j];
	        if (neighbor !== parent) {
	          return neighbor;
	        }
	      }
	    }
	    res = [];
	    ref1 = this.neighbors;
	    for (k = 0, len1 = ref1.length; k < len1; k++) {
	      neighbor = ref1[k];
	      if (neighbor !== parent) {
	        res.push(neighbor);
	      }
	    }
	    return res;
	  };
	
	  TracePoint.prototype.buildTree = function(parent) {
	    var child, childrenIterator, j, len, parentIterator, results;
	    if (parent == null) {
	      parent = null;
	    }
	    this.setChildRelation(parent);
	    childrenIterator = this.children;
	    parentIterator = this;
	    while (childrenIterator.length === 1) {
	      childrenIterator[0].setChildRelation(parentIterator);
	      parentIterator = childrenIterator[0];
	      childrenIterator = parentIterator.children;
	    }
	    results = [];
	    for (j = 0, len = childrenIterator.length; j < len; j++) {
	      child = childrenIterator[j];
	      results.push(child.buildTree(parentIterator));
	    }
	    return results;
	  };
	
	  TracePoint.prototype.setChildRelation = function(parent1) {
	    this.parent = parent1;
	    if (this._seen) {
	      throw "CyclicTree";
	    }
	    this._seen = true;
	    this.children = this.getNext(this.parent);
	    if (this.children == null) {
	      this.children = [];
	    }
	    if (!_.isArray(this.children)) {
	      return this.children = [this.children];
	    }
	  };
	
	  TracePoint.prototype.removeNeighbor = function(id) {
	    var i, j, ref;
	    for (i = j = 0, ref = this.neighbors.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (this.neighbors[i].id === id) {
	        this.neighbors.splice(i, 1);
	        return;
	      }
	    }
	  };
	
	  return TracePoint;
	
	})();
	
	module.exports = TracePoint;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 288 */
/***/ function(module, exports) {

	var TraceTree;
	
	TraceTree = (function() {
	  function TraceTree(treeId, color, name, timestamp) {
	    this.treeId = treeId;
	    this.color = color;
	    this.name = name;
	    this.timestamp = timestamp;
	    this.nodes = [];
	  }
	
	  TraceTree.prototype.removeNode = function(id) {
	    var i, j, ref;
	    for (i = j = 0, ref = this.nodes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (this.nodes[i].id === id) {
	        this.nodes.splice(i, 1);
	        return;
	      }
	    }
	  };
	
	  TraceTree.prototype.buildTree = function() {
	    var j, len, node, ref, root;
	    ref = this.nodes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      node = ref[j];
	      node._seen = false;
	      if (typeof root !== "undefined" && root !== null) {
	        if (root.id > node.id) {
	          root = node;
	        }
	      } else {
	        root = node;
	      }
	    }
	    if (root != null) {
	      root.buildTree();
	    }
	    return root;
	  };
	
	  return TraceTree;
	
	})();
	
	module.exports = TraceTree;


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var ErrorHandling, SkeletonTracingStateLogger, StateLogger, THREE, V3,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	StateLogger = __webpack_require__(290);
	
	THREE = __webpack_require__(245);
	
	V3 = __webpack_require__(189).V3;
	
	ErrorHandling = __webpack_require__(5);
	
	SkeletonTracingStateLogger = (function(superClass) {
	  extend(SkeletonTracingStateLogger, superClass);
	
	  function SkeletonTracingStateLogger(flycam, flycam3d, version, tracingId, tracingType, allowUpdate, skeletonTracing) {
	    this.flycam3d = flycam3d;
	    this.skeletonTracing = skeletonTracing;
	    SkeletonTracingStateLogger.__super__.constructor.call(this, flycam, version, tracingId, tracingType, allowUpdate);
	  }
	
	  SkeletonTracingStateLogger.prototype.treeObject = function(tree, oldId) {
	    var treeColor;
	    treeColor = new THREE.Color(tree.color);
	    return {
	      id: oldId ? oldId : tree.treeId,
	      updatedId: oldId ? tree.treeId : void 0,
	      color: [treeColor.r, treeColor.g, treeColor.b, 1],
	      name: tree.name,
	      timestamp: tree.timestamp
	    };
	  };
	
	  SkeletonTracingStateLogger.prototype.createTree = function(tree) {
	    return this.pushDiff("createTree", this.treeObject(tree));
	  };
	
	  SkeletonTracingStateLogger.prototype.updateTree = function(tree, oldId) {
	    if (oldId == null) {
	      oldId = false;
	    }
	    return this.pushDiff("updateTree", this.treeObject(tree, oldId));
	  };
	
	  SkeletonTracingStateLogger.prototype.deleteTree = function(tree) {
	    return this.pushDiff("deleteTree", {
	      id: tree.treeId
	    });
	  };
	
	  SkeletonTracingStateLogger.prototype.mergeTree = function(sourceTree, targetTree, lastNodeId, activeNodeId) {
	    var found, i, j, len, len1, node, ref, ref1, treeIds;
	    found = false;
	    treeIds = [];
	    ref = sourceTree.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      found |= node.id === lastNodeId;
	      treeIds.push(node.id);
	    }
	    ErrorHandling.assert(found, "lastNodeId not in sourceTree", {
	      sourceTreeNodeIds: treeIds,
	      lastNodeId: lastNodeId
	    });
	    found = false;
	    treeIds = [];
	    ref1 = targetTree.nodes;
	    for (j = 0, len1 = ref1.length; j < len1; j++) {
	      node = ref1[j];
	      found |= node.id === activeNodeId;
	      treeIds.push(node.id);
	    }
	    ErrorHandling.assert(found, "activeNodeId not in targetTree", {
	      targetTreeNodeIds: treeIds,
	      activeNodeId: activeNodeId
	    });
	    this.pushDiff("mergeTree", {
	      sourceId: sourceTree.treeId,
	      targetId: targetTree.treeId
	    }, false);
	    return this.createEdge(lastNodeId, activeNodeId, targetTree.treeId);
	  };
	
	  SkeletonTracingStateLogger.prototype.nodeObject = function(node, treeId) {
	    return _.extend(node.metaInfo, {
	      treeId: treeId,
	      id: node.id,
	      radius: node.radius,
	      position: V3.floor(node.pos),
	      rotation: node.rotation
	    });
	  };
	
	  SkeletonTracingStateLogger.prototype.edgeObject = function(node, treeId) {
	    ErrorHandling.assert(node.neighbors.length === 1, "Node has to have exactly one neighbor", node.neighbors.length);
	    return {
	      treeId: treeId,
	      source: node.neighbors[0].id,
	      target: node.id
	    };
	  };
	
	  SkeletonTracingStateLogger.prototype.createNode = function(node, treeId) {
	    var needsEdge;
	    ErrorHandling.assert(node.neighbors.length <= 1, "New node can't have more than one neighbor", node.neighbors.length);
	    if (node.neighbors[0]) {
	      ErrorHandling.assert(node.treeId === node.neighbors[0].treeId, "Neighbor has different treeId", {
	        treeId1: node.treeId,
	        treeId2: node.neighbors[0].treeId
	      });
	    }
	    needsEdge = node.neighbors.length === 1;
	    this.pushDiff("createNode", this.nodeObject(node, treeId), !needsEdge);
	    if (needsEdge) {
	      return this.pushDiff("createEdge", this.edgeObject(node, treeId));
	    }
	  };
	
	  SkeletonTracingStateLogger.prototype.updateNode = function(node, treeId) {
	    return this.pushDiff("updateNode", this.nodeObject(node, treeId));
	  };
	
	  SkeletonTracingStateLogger.prototype.deleteNode = function(node, treeId) {
	    return this.pushDiff("deleteNode", {
	      treeId: treeId,
	      id: node.id
	    });
	  };
	
	  SkeletonTracingStateLogger.prototype.moveTreeComponent = function(sourceId, targetId, nodeIds) {
	    return this.pushDiff("moveTreeComponent", {
	      sourceId: sourceId,
	      targetId: targetId,
	      nodeIds: nodeIds
	    });
	  };
	
	  SkeletonTracingStateLogger.prototype.createEdge = function(source, target, treeId) {
	    return this.pushDiff("createEdge", {
	      treeId: treeId,
	      source: source,
	      target: target
	    });
	  };
	
	  SkeletonTracingStateLogger.prototype.concatUpdateTracing = function() {
	    var branchPoint, branchPoints, i, len, ref;
	    branchPoints = [];
	    ref = this.skeletonTracing.branchStack;
	    for (i = 0, len = ref.length; i < len; i++) {
	      branchPoint = ref[i];
	      branchPoints.push({
	        id: branchPoint.id
	      });
	    }
	    this.pushDiff("updateTracing", {
	      branchPoints: branchPoints,
	      comments: this.skeletonTracing.getPlainComments(),
	      activeNode: this.skeletonTracing.getActiveNodeId(),
	      editPosition: V3.floor(this.flycam.getPosition()),
	      editRotation: this.flycam3d.getRotation(),
	      zoomLevel: this.flycam.getZoomStep()
	    }, false);
	    return ErrorHandling.assert(this.newDiffs.length > 0, "newDiffs empty after concatUpdateTracing", {
	      newDiffs: this.newDiffs
	    });
	  };
	
	  return SkeletonTracingStateLogger;
	
	})(StateLogger);
	
	module.exports = SkeletonTracingStateLogger;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	var $, Backbone, ErrorHandling, Request, StateLogger, Toast, _, app;
	
	Backbone = __webpack_require__(3);
	
	_ = __webpack_require__(2);
	
	$ = __webpack_require__(1);
	
	app = __webpack_require__(48);
	
	Request = __webpack_require__(17);
	
	Toast = __webpack_require__(18);
	
	ErrorHandling = __webpack_require__(5);
	
	StateLogger = (function() {
	  StateLogger.prototype.PUSH_THROTTLE_TIME = 30000;
	
	  StateLogger.prototype.SAVE_RETRY_WAITING_TIME = 5000;
	
	  function StateLogger(flycam, version, tracingId, tracingType, allowUpdate) {
	    this.flycam = flycam;
	    this.version = version;
	    this.tracingId = tracingId;
	    this.tracingType = tracingType;
	    this.allowUpdate = allowUpdate;
	    _.extend(this, Backbone.Events);
	    this.mutexedPush = _.mutexPromise(this.pushImpl, -1);
	    this.newDiffs = [];
	    this.listenTo(this.flycam, "positionChanged", this.push);
	  }
	
	  StateLogger.prototype.pushDiff = function(action, value, push) {
	    if (push == null) {
	      push = true;
	    }
	    this.newDiffs.push({
	      action: action,
	      value: value
	    });
	    if (push) {
	      return this.push();
	    }
	  };
	
	  StateLogger.prototype.concatUpdateTracing = function() {
	    throw new Error("concatUpdateTracing has to be overwritten by subclass!");
	  };
	
	  StateLogger.prototype.stateSaved = function() {
	    return this.newDiffs.length === 0;
	  };
	
	  StateLogger.prototype.push = function() {
	    if (this.allowUpdate) {
	      return this.pushThrottled();
	    }
	  };
	
	  StateLogger.prototype.pushThrottled = function() {
	    this.pushThrottled = _.throttle(this.mutexedPush, this.PUSH_THROTTLE_TIME);
	    return this.pushThrottled();
	  };
	
	  StateLogger.prototype.pushNow = function() {
	    return this.mutexedPush(false);
	  };
	
	  StateLogger.prototype.save = function() {
	    return this.pushNow();
	  };
	
	  StateLogger.prototype.pushImpl = function(notifyOnFailure) {
	    var diffsCurrentLength;
	    if (!this.allowUpdate) {
	      return Promise.resolve();
	    }
	    this.concatUpdateTracing();
	    diffsCurrentLength = this.newDiffs.length;
	    console.log("Sending data: ", this.newDiffs);
	    ErrorHandling.assert(this.newDiffs.length > 0, "Empty update sent to server!", {
	      newDiffs: this.newDiffs
	    });
	    return Request.sendJSONReceiveJSON("/annotations/" + this.tracingType + "/" + this.tracingId + "?version=" + (this.version + 1), {
	      method: "PUT",
	      data: this.newDiffs
	    }).then((function(_this) {
	      return function(response) {
	        _this.newDiffs = _this.newDiffs.slice(diffsCurrentLength);
	        _this.version = response.version;
	        return _this.pushDoneCallback();
	      };
	    })(this), (function(_this) {
	      return function(responseObject) {
	        return _this.pushFailCallback(responseObject, notifyOnFailure);
	      };
	    })(this));
	  };
	
	  StateLogger.prototype.pushFailCallback = function(response, notifyOnFailure) {
	    $('body').addClass('save-error');
	    if (response.status === 409) {
	      app.router.off("beforeunload");
	      alert("It seems that you edited the tracing simultaneously in different windows.\nEditing should be done in a single window only.\n\nIn order to restore the current window, a reload is necessary.");
	      app.router.reload();
	    }
	    setTimeout(((function(_this) {
	      return function() {
	        return _this.pushNow();
	      };
	    })(this)), this.SAVE_RETRY_WAITING_TIME);
	    if (notifyOnFailure) {
	      return this.trigger("pushFailed");
	    }
	  };
	
	  StateLogger.prototype.pushDoneCallback = function() {
	    this.trigger("pushDone");
	    return $('body').removeClass('save-error');
	  };
	
	  return StateLogger;
	
	})();
	
	module.exports = StateLogger;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var RestrictionHandler, Toast;
	
	Toast = __webpack_require__(18);
	
	RestrictionHandler = (function() {
	  RestrictionHandler.prototype.UPDATE_ERROR = "You cannot update this tracing, because you are in Read-only mode!";
	
	  function RestrictionHandler(restrictions) {
	    this.restrictions = restrictions;
	    this.issuedUpdateError = false;
	  }
	
	  RestrictionHandler.prototype.handleUpdate = function() {
	    if (this.restrictions.allowUpdate) {
	      return false;
	    } else {
	      if (!this.issuedUpdateError) {
	        Toast.error(this.UPDATE_ERROR);
	        this.issuedUpdateError = true;
	      }
	      return true;
	    }
	  };
	
	  return RestrictionHandler;
	
	})();
	
	module.exports = RestrictionHandler;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var CommentsCollection, THREE, Toast, TracePoint, TraceTree, TracingParser, _;
	
	_ = __webpack_require__(2);
	
	THREE = __webpack_require__(245);
	
	TracePoint = __webpack_require__(287);
	
	TraceTree = __webpack_require__(288);
	
	Toast = __webpack_require__(18);
	
	CommentsCollection = __webpack_require__(293);
	
	TracingParser = (function() {
	  function TracingParser(skeletonTracing, data) {
	    this.skeletonTracing = skeletonTracing;
	    this.data = data;
	    this.idCount = 1;
	    this.treeIdCount = 1;
	    this.trees = [];
	    this.comments = new CommentsCollection();
	    this.activeNode = null;
	    this.activeTree = null;
	  }
	
	  TracingParser.prototype.buildTrees = function() {
	    var activeNodeT, edge, i, j, k, len, len1, len2, metaInfo, node, ref, ref1, ref2, sourceNode, targetNode, tree, treeData;
	    ref = this.data.trees;
	    for (i = 0, len = ref.length; i < len; i++) {
	      treeData = ref[i];
	      tree = new TraceTree(treeData.id, this.convertColor(treeData.color), treeData.name ? treeData.name : "Tree" + (('00' + treeData.id).slice(-3)), treeData.timestamp);
	      ref1 = treeData.nodes;
	      for (j = 0, len1 = ref1.length; j < len1; j++) {
	        node = ref1[j];
	        metaInfo = _.pick(node, 'timestamp', 'viewport', 'resolution', 'bitDepth', 'interpolation');
	        tree.nodes.push(new TracePoint(this.skeletonTracing.TYPE_USUAL, node.id, node.position, node.radius, treeData.id, metaInfo, node.rotation));
	        this.idCount = Math.max(node.id + 1, this.idCount);
	      }
	      ref2 = treeData.edges;
	      for (k = 0, len2 = ref2.length; k < len2; k++) {
	        edge = ref2[k];
	        sourceNode = this.skeletonTracing.findNodeInList(tree.nodes, edge.source);
	        targetNode = this.skeletonTracing.findNodeInList(tree.nodes, edge.target);
	        if (sourceNode && targetNode) {
	          sourceNode.appendNext(targetNode);
	          targetNode.appendNext(sourceNode);
	        } else {
	          if (!sourceNode) {
	            Toast.error("Node with id " + edge.source + " doesn't exist. Ignored edge due to missing source node.");
	          }
	          if (!targetNode) {
	            Toast.error("Node with id " + edge.target + " doesn't exist. Ignored edge due to missing target node.");
	          }
	        }
	      }
	      activeNodeT = this.skeletonTracing.findNodeInList(tree.nodes, this.data.activeNode);
	      if (activeNodeT) {
	        this.activeNode = activeNodeT;
	        this.activeTree = tree;
	      }
	      this.treeIdCount = Math.max(tree.treeId + 1, this.treeIdCount);
	      this.trees.push(tree);
	    }
	    if (this.data.activeNode && !this.activeNode) {
	      return Toast.error("Node with id " + this.data.activeNode + " doesn't exist. Ignored active node.");
	    }
	  };
	
	  TracingParser.prototype.convertColor = function(colorArray) {
	    var ref;
	    if (colorArray != null) {
	      return (ref = new THREE.Color()).setRGB.apply(ref, colorArray).getHex();
	    }
	    return null;
	  };
	
	  TracingParser.prototype.setBranchpoints = function(nodeList) {
	    var branchpoint, i, len, node, ref, results;
	    ref = this.data.branchPoints;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      branchpoint = ref[i];
	      node = this.skeletonTracing.findNodeInList(nodeList, branchpoint.id);
	      if (node) {
	        node.type = this.skeletonTracing.TYPE_BRANCH;
	        results.push(this.skeletonTracing.branchStack.push(node));
	      } else {
	        results.push(Toast.error("Node with id " + branchpoint.id + " doesn't exist. Ignored branchpoint."));
	      }
	    }
	    return results;
	  };
	
	  TracingParser.prototype.setComments = function(nodeList) {
	    var filteredComments;
	    filteredComments = _.filter(this.data.comments, function(comment) {
	      return _.some(nodeList, function(node) {
	        return node.id === comment.node;
	      });
	    });
	    return this.comments.add(filteredComments);
	  };
	
	  TracingParser.prototype.parse = function() {
	    var i, len, nodeList, ref, tree;
	    if (this.data == null) {
	      return {
	        idCount: 0,
	        treeIdCount: 0,
	        trees: [],
	        comments: new CommentsCollection(),
	        activeNode: null,
	        activeTree: null
	      };
	    }
	    this.buildTrees();
	    nodeList = [];
	    ref = this.trees;
	    for (i = 0, len = ref.length; i < len; i++) {
	      tree = ref[i];
	      nodeList = nodeList.concat(tree.nodes);
	    }
	    this.setBranchpoints(nodeList);
	    this.setComments(nodeList);
	    return {
	      idCount: this.idCount,
	      treeIdCount: this.treeIdCount,
	      trees: this.trees,
	      comments: this.comments,
	      activeNode: this.activeNode,
	      activeTree: this.activeTree
	    };
	  };
	
	  return TracingParser;
	
	})();
	
	module.exports = TracingParser;


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	var CommentsCollection, _, backbone,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	backbone = __webpack_require__(3);
	
	CommentsCollection = (function(superClass) {
	  extend(CommentsCollection, superClass);
	
	  function CommentsCollection() {
	    return CommentsCollection.__super__.constructor.apply(this, arguments);
	  }
	
	  CommentsCollection.prototype.intitalize = function() {
	    return this.coefficient = 1;
	  };
	
	  CommentsCollection.prototype.comparator = function(model) {
	    return model.get("node") * this.coefficient;
	  };
	
	  CommentsCollection.prototype.sort = function(isAscending) {
	    this.coefficient = isAscending ? 1 : -1;
	    return CommentsCollection.__super__.sort.call(this);
	  };
	
	  CommentsCollection.prototype.findCommentByNodeId = function(id) {
	    return this.findWhere({
	      node: id
	    });
	  };
	
	  CommentsCollection.prototype.hasCommentWithNodeId = function(id) {
	    return this.findCommentByNodeId(id) !== void 0;
	  };
	
	  return CommentsCollection;
	
	})(Backbone.Collection);
	
	module.exports = CommentsCollection;


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, User, _, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	app = __webpack_require__(48);
	
	User = (function(superClass) {
	  extend(User, superClass);
	
	  function User() {
	    return User.__super__.constructor.apply(this, arguments);
	  }
	
	  User.prototype.url = "/api/user/userConfiguration";
	
	  User.prototype.initialize = function() {
	    return this.listenTo(this, "change", _.debounce(((function(_this) {
	      return function() {
	        return _this.save();
	      };
	    })(this)), 500));
	  };
	
	  User.prototype.getMouseInversionX = function() {
	    if (this.get("inverseX")) {
	      return 1;
	    } else {
	      return -1;
	    }
	  };
	
	  User.prototype.getMouseInversionY = function() {
	    if (this.get("inverseY")) {
	      return 1;
	    } else {
	      return -1;
	    }
	  };
	
	  User.prototype.getOrCreateBrightnessContrastColorSettings = function(model) {
	    var binary, datasetSettings, i, len, ref, settings;
	    settings = this.get("brightnessContrastColorSettings");
	    datasetSettings = settings[model.datasetPostfix] || {};
	    ref = model.getColorBinaries();
	    for (i = 0, len = ref.length; i < len; i++) {
	      binary = ref[i];
	      datasetSettings[binary.name] = datasetSettings[binary.name] || {};
	      _.defaults(datasetSettings[binary.name], settings["default"]);
	    }
	    return settings[model.datasetPostfix] = datasetSettings;
	  };
	
	  User.prototype.resetBrightnessContrastColorSettings = function(model) {
	    return Request.receiveJSON("/user/configuration/default").then((function(_this) {
	      return function(defaultData) {
	        _this.get("brightnessContrastColorSettings")[model.datasetPostfix] = defaultData.brightnessContrastColorSettings[model.datasetPostfix];
	        return _this.getOrCreateBrightnessContrastColorSettings(model);
	      };
	    })(this));
	  };
	
	  User.prototype.triggerAll = function() {
	    var property, results;
	    results = [];
	    for (property in this.attributes) {
	      results.push(this.trigger("change:" + property, this, this.get(property)));
	    }
	    return results;
	  };
	
	  return User;
	
	})(Backbone.Model);
	
	module.exports = User;


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, DatasetConfiguration, NestedObjModel, Request, _,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Request = __webpack_require__(17);
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	NestedObjModel = __webpack_require__(296);
	
	DatasetConfiguration = (function(superClass) {
	  extend(DatasetConfiguration, superClass);
	
	  function DatasetConfiguration() {
	    this.reset = bind(this.reset, this);
	    return DatasetConfiguration.__super__.constructor.apply(this, arguments);
	  }
	
	  DatasetConfiguration.prototype.initialize = function(arg) {
	    var datasetName;
	    datasetName = arg.datasetName, this.dataLayerNames = arg.dataLayerNames;
	    this.url = "/api/dataSetConfigurations/" + datasetName;
	    this.listenTo(this, "change", _.debounce(((function(_this) {
	      return function() {
	        return _this.save();
	      };
	    })(this)), 500));
	    return this.listenTo(this, "sync", (function(_this) {
	      return function() {
	        return _this.setDefaultBinaryColors();
	      };
	    })(this));
	  };
	
	  DatasetConfiguration.prototype.reset = function() {
	    return this.setDefaultBinaryColors(true);
	  };
	
	  DatasetConfiguration.prototype.triggerAll = function() {
	    var property, results;
	    results = [];
	    for (property in this.attributes) {
	      results.push(this.trigger("change:" + property, this, this.get(property)));
	    }
	    return results;
	  };
	
	  DatasetConfiguration.prototype.setDefaultBinaryColors = function(forceDefault) {
	    var defaultColors, defaults, i, j, layer, layerName, layers, len, ref, results;
	    if (forceDefault == null) {
	      forceDefault = false;
	    }
	    layers = this.get("layers");
	    if (this.dataLayerNames.length === 1) {
	      defaultColors = [[255, 255, 255]];
	    } else {
	      defaultColors = [[255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [0, 255, 255], [255, 0, 255]];
	    }
	    ref = this.dataLayerNames;
	    results = [];
	    for (i = j = 0, len = ref.length; j < len; i = ++j) {
	      layerName = ref[i];
	      defaults = {
	        color: defaultColors[i % defaultColors.length],
	        brightness: 0,
	        contrast: 1
	      };
	      if (forceDefault || !layers[layerName]) {
	        layer = defaults;
	      } else {
	        layer = _.defaults(layers[layerName], defaults);
	      }
	      results.push(this.set("layers." + layerName, layer));
	    }
	    return results;
	  };
	
	  return DatasetConfiguration;
	
	})(NestedObjModel);
	
	module.exports = DatasetConfiguration;


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone, NestedObjModel, _,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Backbone = __webpack_require__(3);
	
	NestedObjModel = (function(superClass) {
	  extend(NestedObjModel, superClass);
	
	  function NestedObjModel() {
	    this.triggerDeepChange = bind(this.triggerDeepChange, this);
	    this.deepSet = bind(this.deepSet, this);
	    this.set = bind(this.set, this);
	    return NestedObjModel.__super__.constructor.apply(this, arguments);
	  }
	
	  NestedObjModel.prototype.get = function(attributeString) {
	    var attributes, valueObj;
	    attributes = attributeString.split(".");
	    valueObj = this.attributes;
	    return _.reduce(attributes, function(value, attribute) {
	      return value != null ? value[attribute] : void 0;
	    }, valueObj);
	  };
	
	  NestedObjModel.prototype.set = function(attributeString, val, options) {
	    if (options == null) {
	      options = {};
	    }
	    if (_.isObject(attributeString)) {
	      return NestedObjModel.__super__.set.call(this, attributeString, val, options);
	    }
	    this.changed = {};
	    return this.deepSet(this.attributes, attributeString, val, options.silent);
	  };
	
	  NestedObjModel.prototype.deepSet = function(obj, attributeString, val, silent) {
	    var attributes;
	    if (silent == null) {
	      silent = false;
	    }
	    attributes = attributeString.split(".");
	    return _.reduce(attributes, (function(_this) {
	      return function(value, attribute, ind) {
	        var oldVal;
	        if (ind < attributes.length - 1) {
	          if (value[attribute] == null) {
	            value[attribute] = {};
	          }
	          return value[attribute];
	        } else {
	          if (value[attribute] !== val) {
	            oldVal = value[attribute];
	            value[attribute] = val;
	            if (!silent) {
	              _this.triggerDeepChange(oldVal, val, attributeString);
	              return _this.trigger("change", _this);
	            }
	          }
	        }
	      };
	    })(this), obj);
	  };
	
	  NestedObjModel.prototype.triggerDeepChange = function(oldObj, newObj, deepKey) {
	    if (_.isPlainObject(newObj)) {
	      return _.forOwn(newObj, (function(_this) {
	        return function(value, key) {
	          return _this.triggerDeepChange((oldObj != null ? oldObj[key] : oldObj), newObj[key], deepKey + "." + key);
	        };
	      })(this));
	    } else if (oldObj !== newObj) {
	      this.deepSet(this.changed, deepKey, newObj, true);
	      return this.trigger("change:" + deepKey, this, newObj);
	    }
	  };
	
	  return NestedObjModel;
	
	})(Backbone.Model);
	
	module.exports = NestedObjModel;


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, Constants, Dimensions, Drawing, RestrictionHandler, VolumeCell, VolumeLayer, VolumeTracing, VolumeTracingStateLogger;
	
	Backbone = __webpack_require__(3);
	
	VolumeCell = __webpack_require__(298);
	
	VolumeLayer = __webpack_require__(299);
	
	Dimensions = __webpack_require__(277);
	
	RestrictionHandler = __webpack_require__(291);
	
	Drawing = __webpack_require__(300);
	
	VolumeTracingStateLogger = __webpack_require__(301);
	
	Constants = __webpack_require__(61);
	
	VolumeTracing = (function() {
	  function VolumeTracing(tracing, flycam, flycam3d, binary) {
	    this.flycam = flycam;
	    this.flycam3d = flycam3d;
	    this.binary = binary;
	    _.extend(this, Backbone.Events);
	    this.contentData = tracing.content.contentData;
	    this.restrictionHandler = new RestrictionHandler(tracing.restrictions);
	    this.mode = Constants.VOLUME_MODE_MOVE;
	    this.cells = [];
	    this.activeCell = null;
	    this.currentLayer = null;
	    this.idCount = this.contentData.nextCell || 1;
	    this.lastCentroid = null;
	    this.stateLogger = new VolumeTracingStateLogger(this.flycam, tracing.version, tracing.id, tracing.typ, tracing.restrictions.allowUpdate, this, this.binary.pushQueue);
	    this.createCell(this.contentData.activeCell);
	    this.listenTo(this.binary.cube, "newMapping", function() {
	      return this.trigger("newActiveCell", this.getActiveCellId());
	    });
	    window.setAlpha = function(v) {
	      return Drawing.setAlpha(v);
	    };
	    window.setSmoothLength = function(v) {
	      return Drawing.setSmoothLength(v);
	    };
	  }
	
	  VolumeTracing.prototype.setMode = function(mode) {
	    this.mode = mode;
	    return this.trigger("change:mode", this.mode);
	  };
	
	  VolumeTracing.prototype.toggleMode = function() {
	    return this.setMode(this.mode === Constants.VOLUME_MODE_TRACE ? Constants.VOLUME_MODE_MOVE : Constants.VOLUME_MODE_TRACE);
	  };
	
	  VolumeTracing.prototype.createCell = function(id) {
	    var newCell;
	    if (id == null) {
	      id = this.idCount++;
	    }
	    this.cells.push(newCell = new VolumeCell(id));
	    this.setActiveCell(newCell.id);
	    return this.currentLayer = null;
	  };
	
	  VolumeTracing.prototype.startEditing = function(planeId) {
	    var pos, thirdDimValue;
	    if (this.restrictionHandler.handleUpdate()) {
	      return false;
	    }
	    if ((typeof currentLayer !== "undefined" && currentLayer !== null) || this.flycam.getIntegerZoomStep() > 0) {
	      return false;
	    }
	    pos = Dimensions.roundCoordinate(this.flycam.getPosition());
	    thirdDimValue = pos[Dimensions.thirdDimensionForPlane(planeId)];
	    this.currentLayer = new VolumeLayer(planeId, thirdDimValue);
	    return true;
	  };
	
	  VolumeTracing.prototype.addToLayer = function(pos) {
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if (this.currentLayer == null) {
	      return;
	    }
	    this.currentLayer.addContour(pos);
	    return this.trigger("updateLayer", this.getActiveCellId(), this.currentLayer.getSmoothedContourList());
	  };
	
	  VolumeTracing.prototype.finishLayer = function() {
	    var iterator, labelValue, start;
	    if (this.restrictionHandler.handleUpdate()) {
	      return;
	    }
	    if ((this.currentLayer == null) || this.currentLayer.isEmpty()) {
	      return;
	    }
	    start = (new Date()).getTime();
	    this.currentLayer.finish();
	    iterator = this.currentLayer.getVoxelIterator();
	    labelValue = this.activeCell ? this.activeCell.id : 0;
	    this.binary.cube.labelVoxels(iterator, labelValue);
	    console.log("Labeling time:", (new Date()).getTime() - start);
	    this.updateDirection(this.currentLayer.getCentroid());
	    this.currentLayer = null;
	    return this.trigger("volumeAnnotated");
	  };
	
	  VolumeTracing.prototype.updateDirection = function(centroid) {
	    if (this.lastCentroid != null) {
	      this.flycam.setDirection([centroid[0] - this.lastCentroid[0], centroid[1] - this.lastCentroid[1], centroid[2] - this.lastCentroid[2]]);
	    }
	    return this.lastCentroid = centroid;
	  };
	
	  VolumeTracing.prototype.getActiveCellId = function() {
	    if (this.activeCell != null) {
	      return this.activeCell.id;
	    } else {
	      return 0;
	    }
	  };
	
	  VolumeTracing.prototype.getMappedActiveCellId = function() {
	    return this.binary.cube.mapId(this.getActiveCellId());
	  };
	
	  VolumeTracing.prototype.setActiveCell = function(id) {
	    var cell, i, len, ref;
	    this.activeCell = null;
	    ref = this.cells;
	    for (i = 0, len = ref.length; i < len; i++) {
	      cell = ref[i];
	      if (cell.id === id) {
	        this.activeCell = cell;
	      }
	    }
	    if ((this.activeCell == null) && id > 0) {
	      this.createCell(id);
	    }
	    return this.trigger("newActiveCell", id);
	  };
	
	  return VolumeTracing;
	
	})();
	
	module.exports = VolumeTracing;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 298 */
/***/ function(module, exports) {

	var VolumeCell;
	
	VolumeCell = (function() {
	  function VolumeCell(id) {
	    this.id = id;
	  }
	
	  return VolumeCell;
	
	})();
	
	module.exports = VolumeCell;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var Dimensions, Drawing, VolumeLayer;
	
	Dimensions = __webpack_require__(277);
	
	Drawing = __webpack_require__(300);
	
	VolumeLayer = (function() {
	  function VolumeLayer(plane, thirdDimensionValue) {
	    this.plane = plane;
	    this.thirdDimensionValue = thirdDimensionValue;
	    this.contourList = [];
	    this.maxCoord = null;
	    this.minCoord = null;
	  }
	
	  VolumeLayer.prototype.addContour = function(pos) {
	    this.contourList.push(pos);
	    return this.updateArea(pos);
	  };
	
	  VolumeLayer.prototype.updateArea = function(pos) {
	    var i, j, results;
	    if (this.maxCoord == null) {
	      this.maxCoord = pos.slice();
	      this.minCoord = pos.slice();
	    }
	    results = [];
	    for (i = j = 0; j <= 2; i = ++j) {
	      this.minCoord[i] = Math.min(this.minCoord[i], Math.floor(pos[i]) - 2);
	      results.push(this.maxCoord[i] = Math.max(this.maxCoord[i], Math.ceil(pos[i]) + 2));
	    }
	    return results;
	  };
	
	  VolumeLayer.prototype.getSmoothedContourList = function() {
	    return Drawing.smoothLine(this.contourList, ((function(_this) {
	      return function(pos) {
	        return _this.updateArea(pos);
	      };
	    })(this)));
	  };
	
	  VolumeLayer.prototype.finish = function() {
	    if (!this.isEmpty()) {
	      return this.addContour(this.contourList[0]);
	    }
	  };
	
	  VolumeLayer.prototype.isEmpty = function() {
	    return this.contourList.length === 0;
	  };
	
	  VolumeLayer.prototype.getVoxelIterator = function() {
	    var height, iterator, j, k, map, maxCoord2d, minCoord2d, ref, ref1, setMap, width, x, y;
	    if (this.isEmpty()) {
	      return {
	        hasNext: false
	      };
	    }
	    minCoord2d = this.get2DCoordinate(this.minCoord);
	    maxCoord2d = this.get2DCoordinate(this.maxCoord);
	    width = maxCoord2d[0] - minCoord2d[0] + 1;
	    height = maxCoord2d[1] - minCoord2d[1] + 1;
	    map = new Array(width);
	    for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
	      map[x] = new Array(height);
	      for (y = k = 0, ref1 = height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
	        map[x][y] = true;
	      }
	    }
	    setMap = function(x, y, value) {
	      if (value == null) {
	        value = true;
	      }
	      x = Math.floor(x);
	      y = Math.floor(y);
	      return map[x - minCoord2d[0]][y - minCoord2d[1]] = value;
	    };
	    this.drawOutlineVoxels(function(x, y) {
	      return setMap(x, y, false);
	    });
	    this.fillOutsideArea(map, width, height);
	    this.drawOutlineVoxels(setMap);
	    iterator = {
	      hasNext: true,
	      x: 0,
	      y: 0,
	      getNext: function() {
	        var res;
	        res = this.get3DCoordinate([this.x + minCoord2d[0], this.y + minCoord2d[1]]);
	        while (true) {
	          this.x = (this.x + 1) % width;
	          if (this.x === 0) {
	            this.y++;
	          }
	          if (map[this.x][this.y] || this.y === height) {
	            this.hasNext = this.y !== height;
	            break;
	          }
	        }
	        return res;
	      },
	      initialize: function() {
	        if (!map[0][0]) {
	          return this.getNext();
	        }
	      },
	      get3DCoordinate: (function(_this) {
	        return function(arg) {
	          return _this.get3DCoordinate(arg);
	        };
	      })(this)
	    };
	    iterator.initialize();
	    return iterator;
	  };
	
	  VolumeLayer.prototype.drawOutlineVoxels = function(setMap) {
	    var i, j, p1, p2, ref, results;
	    results = [];
	    for (i = j = 0, ref = this.contourList.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      p1 = this.get2DCoordinate(this.contourList[i]);
	      p2 = this.get2DCoordinate(this.contourList[(i + 1) % this.contourList.length]);
	      results.push(Drawing.drawLine2d(p1[0], p1[1], p2[0], p2[1], setMap));
	    }
	    return results;
	  };
	
	  VolumeLayer.prototype.fillOutsideArea = function(map, width, height) {
	    var isEmpty, setMap;
	    setMap = function(x, y) {
	      return map[x][y] = false;
	    };
	    isEmpty = function(x, y) {
	      return map[x][y] === true;
	    };
	    return Drawing.fillArea(0, 0, width, height, false, isEmpty, setMap);
	  };
	
	  VolumeLayer.prototype.get2DCoordinate = function(coord3d) {
	    var i, j, result;
	    result = [];
	    for (i = j = 0; j <= 2; i = ++j) {
	      if (i !== Dimensions.thirdDimensionForPlane(this.plane)) {
	        result.push(coord3d[i]);
	      }
	    }
	    return result;
	  };
	
	  VolumeLayer.prototype.get3DCoordinate = function(coord2d) {
	    var i, index, index2d, j, res;
	    index = Dimensions.thirdDimensionForPlane(this.plane);
	    index2d = 0;
	    res = [0, 0, 0];
	    for (i = j = 0; j <= 2; i = ++j) {
	      if (i !== index) {
	        res[i] = coord2d[index2d++];
	      } else {
	        res[i] = this.thirdDimensionValue;
	      }
	    }
	    return res;
	  };
	
	  VolumeLayer.prototype.contains2dCoordinate = function(point, list) {
	    var contour, contour2d, diff, j, len, newQuadrant, prevQuadrant, quadrant, totalDiff;
	    if (list == null) {
	      list = this.contourList;
	    }
	    totalDiff = 0;
	    for (j = 0, len = list.length; j < len; j++) {
	      contour = list[j];
	      contour2d = this.get2DCoordinate(contour);
	      newQuadrant = this.getQuadrantWithRespectToPoint(contour2d, point);
	      prevQuadrant = typeof quadrant !== "undefined" && quadrant !== null ? quadrant : newQuadrant;
	      quadrant = newQuadrant;
	      if (Math.abs(prevQuadrant - quadrant) === 2 || quadrant === 0) {
	        return true;
	      }
	      diff = quadrant - prevQuadrant;
	      if (diff === 3) {
	        diff = -1;
	      }
	      if (diff === -3) {
	        diff = 1;
	      }
	      totalDiff -= diff;
	    }
	    return totalDiff !== 0;
	  };
	
	  VolumeLayer.prototype.getQuadrantWithRespectToPoint = function(vertex, point) {
	    var xDiff, yDiff;
	    xDiff = vertex[0] - point[0];
	    yDiff = vertex[1] - point[1];
	    if (xDiff === 0 && yDiff === 0) {
	      return 0;
	    }
	    switch (false) {
	      case !(xDiff <= 0 && yDiff > 0):
	        return 1;
	      case !(xDiff <= 0 && yDiff <= 0):
	        return 2;
	      case !(xDiff > 0 && yDiff <= 0):
	        return 3;
	      case !(xDiff > 0 && yDiff > 0):
	        return 4;
	    }
	  };
	
	  VolumeLayer.prototype.calculateDistance = function(p1, p2) {
	    var diff;
	    diff = [p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
	    return Math.sqrt(diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2]);
	  };
	
	  VolumeLayer.prototype.interpolatePositions = function(pos1, pos2, f) {
	    var sPos1, sPos2;
	    sPos1 = [pos1[0] * (1 - f), pos1[1] * (1 - f), pos1[2] * (1 - f)];
	    sPos2 = [pos2[0] * f, pos2[1] * f, pos2[2] * f];
	    return [sPos1[0] + sPos2[0], sPos1[1] + sPos2[1], sPos1[2] + sPos2[2]];
	  };
	
	  VolumeLayer.prototype.getCentroid = function() {
	    var area, cx, cy, i, j, ref, ref1, ref2, sumArea, sumCx, sumCy, x_i, x_i_1, y_i, y_i_1;
	    sumArea = 0;
	    sumCx = 0;
	    sumCy = 0;
	    for (i = j = 0, ref = this.contourList.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      ref1 = this.get2DCoordinate(this.contourList[i]), x_i = ref1[0], y_i = ref1[1];
	      ref2 = this.get2DCoordinate(this.contourList[i + 1]), x_i_1 = ref2[0], y_i_1 = ref2[1];
	      sumArea += x_i * y_i_1 - x_i_1 * y_i;
	      sumCx += (x_i + x_i_1) * (x_i * y_i_1 - x_i_1 * y_i);
	      sumCy += (y_i + y_i_1) * (x_i * y_i_1 - x_i_1 * y_i);
	    }
	    area = sumArea / 2;
	    cx = sumCx / 6 / area;
	    cy = sumCy / 6 / area;
	    return this.get3DCoordinate([cx, cy]);
	  };
	
	  return VolumeLayer;
	
	})();
	
	module.exports = VolumeLayer;


/***/ },
/* 300 */
/***/ function(module, exports) {

	var Drawing, SMOOTH_ALPHA, SMOOTH_LENGTH;
	
	SMOOTH_LENGTH = 4;
	
	SMOOTH_ALPHA = 0.2;
	
	Drawing = {
	  drawLine2d: function(x, y, x1, y1, draw) {
	    var __tmp, d, dx, dx2, dy, dy2, err, i, l, mode, ref, x_inc, y_inc;
	    x_inc = (dx = x1 - x) < 0 ? -1 : 1;
	    y_inc = (dy = y1 - y) < 0 ? -1 : 1;
	    dx = Math.abs(dx);
	    dy = Math.abs(dy);
	    dx2 = dx << 1;
	    dy2 = dy << 1;
	    draw(x, y);
	    if (dx >= dy) {
	      d = dx;
	      mode = 0;
	    } else {
	      __tmp = y;
	      y = x;
	      x = __tmp;
	      __tmp = y_inc;
	      y_inc = x_inc;
	      x_inc = __tmp;
	      __tmp = dy2;
	      dy2 = dx2;
	      dx2 = __tmp;
	      d = dy;
	      mode = 1;
	    }
	    err = dy2 - d;
	    for (i = l = 0, ref = d; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
	      if (err > 0) {
	        y += y_inc;
	        err -= dx2;
	      }
	      err += dy2;
	      x += x_inc;
	      if (mode) {
	        draw(y, x);
	      } else {
	        draw(x, y);
	      }
	    }
	  },
	  fillArea: function(x, y, width, height, diagonal, test, paint) {
	    var addNextLine, down, extendLeft, extendRight, maxX, minX, r, ranges, results, up;
	    ranges = [[x, x, y, null, true, true]];
	    paint(x, y);
	    results = [];
	    while (ranges.length) {
	      addNextLine = function(newY, isNext, downwards) {
	        var empty, inRange, rMinX;
	        rMinX = minX;
	        inRange = false;
	        x = minX;
	        while (x <= maxX) {
	          empty = (isNext || (x < r[0] || x > r[1])) && test(x, newY);
	          if (!inRange && empty) {
	            rMinX = x;
	            inRange = true;
	          } else if (inRange && !empty) {
	            ranges.push([rMinX, x - 1, newY, downwards, rMinX === minX, false]);
	            inRange = false;
	          }
	          if (inRange) {
	            paint(x, newY);
	          }
	          if (!isNext && x === r[0]) {
	            x = r[1];
	          }
	          x++;
	        }
	        if (inRange) {
	          return ranges.push([rMinX, x - 1, newY, downwards, rMinX === minX, true]);
	        }
	      };
	      r = ranges.pop();
	      minX = r[0];
	      maxX = r[1];
	      y = r[2];
	      down = r[3] === true;
	      up = r[3] === false;
	      extendLeft = r[4];
	      extendRight = r[5];
	      if (extendLeft) {
	        while (minX > 0 && test(minX - 1, y)) {
	          minX--;
	          paint(minX, y);
	        }
	      }
	      if (extendRight) {
	        while (maxX < width - 1 && test(maxX + 1, y)) {
	          maxX++;
	          paint(maxX, y);
	        }
	      }
	      if (diagonal) {
	        if (minX > 0) {
	          minX--;
	        }
	        if (maxX < width - 1) {
	          maxX++;
	        }
	      } else {
	        r[0]--;
	        r[1]++;
	      }
	      if (y < height) {
	        addNextLine(y + 1, !up, true);
	      }
	      if (y > 0) {
	        results.push(addNextLine(y - 1, !down, false));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  },
	  smoothLine: function(points, callback) {
	    var a, i, j, k, l, m, p, p0, p1, ref, ref1, smoothLength;
	    smoothLength = this.smoothLength || SMOOTH_LENGTH;
	    a = this.alpha || SMOOTH_ALPHA;
	    if (points.length > 2 + smoothLength) {
	      for (i = l = 0, ref = smoothLength; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
	        j = points.length - i - 2;
	        p0 = points[j];
	        p1 = points[j + 1];
	        p = [];
	        for (k = m = 0, ref1 = p0.length; 0 <= ref1 ? m < ref1 : m > ref1; k = 0 <= ref1 ? ++m : --m) {
	          p.push(p0[k] * (1 - a) + p1[k] * a);
	        }
	        callback(p);
	        points[j] = p;
	      }
	    }
	    return points;
	  },
	  setSmoothLength: function(v) {
	    return this.smoothLength = v;
	  },
	  setAlpha: function(v) {
	    return this.alpha = v;
	  }
	};
	
	module.exports = Drawing;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var StateLogger, VolumeTracingStateLogger,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	StateLogger = __webpack_require__(290);
	
	VolumeTracingStateLogger = (function(superClass) {
	  extend(VolumeTracingStateLogger, superClass);
	
	  function VolumeTracingStateLogger(flycam, version, tracingId, tracingType, allowUpdate, volumeTracing, pushQueue) {
	    this.volumeTracing = volumeTracing;
	    this.pushQueue = pushQueue;
	    VolumeTracingStateLogger.__super__.constructor.call(this, flycam, version, tracingId, tracingType, allowUpdate);
	  }
	
	  VolumeTracingStateLogger.prototype.pushDiff = function(action, value, push) {
	    if (push == null) {
	      push = true;
	    }
	    this.pushQueue.pushImpl();
	    VolumeTracingStateLogger.__super__.pushDiff.apply(this, arguments);
	    if (push) {
	      return this.pushImpl();
	    }
	  };
	
	  VolumeTracingStateLogger.prototype.pushNow = function() {
	    var pushQueuePromise, stateLoggerPromise;
	    pushQueuePromise = this.pushQueue.pushImpl();
	    stateLoggerPromise = VolumeTracingStateLogger.__super__.pushNow.apply(this, arguments);
	    return Promise.all([pushQueuePromise, stateLoggerPromise]);
	  };
	
	  VolumeTracingStateLogger.prototype.concatUpdateTracing = function() {
	    return this.pushDiff("updateTracing", {
	      activeCell: this.volumeTracing.getActiveCellId(),
	      editPosition: this.flycam.getPosition(),
	      nextCell: this.volumeTracing.idCount
	    }, false);
	  };
	
	  return VolumeTracingStateLogger;
	
	})(StateLogger);
	
	module.exports = VolumeTracingStateLogger;


/***/ },
/* 302 */
/***/ function(module, exports) {

	var BinaryDataConnectionInfo;
	
	BinaryDataConnectionInfo = (function() {
	  function BinaryDataConnectionInfo() {}
	
	  BinaryDataConnectionInfo.prototype.ROUND_TRIP_TIME_SMOOTHER = .125;
	
	  BinaryDataConnectionInfo.prototype.BANDWIDTH_SMOOTHER = .125;
	
	  BinaryDataConnectionInfo.prototype.roundTripTime = 200;
	
	  BinaryDataConnectionInfo.prototype.bandwidth = 100000;
	
	  BinaryDataConnectionInfo.prototype.loggedData = [];
	
	  BinaryDataConnectionInfo.prototype.totalBuckets = 0;
	
	  BinaryDataConnectionInfo.prototype.totalBytes = 0;
	
	  BinaryDataConnectionInfo.prototype.log = function(dataLayerName, startTime, loadedBuckets, loadedBytes) {
	    var bandwidth, endTime, roundTripTime;
	    endTime = new Date().getTime();
	    roundTripTime = endTime - startTime;
	    bandwidth = loadedBytes / roundTripTime * 1000;
	    this.loggedData.push({
	      timestamp: endTime,
	      duration: roundTripTime,
	      dataLayer: dataLayerName,
	      bytes: loadedBytes,
	      buckets: loadedBuckets
	    });
	    this.totalBuckets += loadedBuckets;
	    this.totalBytes += loadedBytes;
	    this.roundTripTime = (1 - this.ROUND_TRIP_TIME_SMOOTHER) * this.roundTripTime + this.ROUND_TRIP_TIME_SMOOTHER * roundTripTime;
	    return this.bandwidth = (1 - this.BANDWIDTH_SMOOTHER) * this.bandwidth + this.BANDWIDTH_SMOOTHER * bandwidth;
	  };
	
	  return BinaryDataConnectionInfo;
	
	})();
	
	module.exports = BinaryDataConnectionInfo;


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	var ScaleInfo, THREE;
	
	THREE = __webpack_require__(245);
	
	ScaleInfo = (function() {
	  function ScaleInfo(scale) {
	    var i, j, ref;
	    this.nmPerVoxel = scale;
	    this.voxelPerNM = [0, 0, 0];
	    for (i = j = 0, ref = this.nmPerVoxel.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
	      this.voxelPerNM[i] = 1 / this.nmPerVoxel[i];
	    }
	    this.baseVoxel = Math.min.apply(null, this.nmPerVoxel);
	    this.baseVoxelFactors = [this.baseVoxel / this.nmPerVoxel[0], this.baseVoxel / this.nmPerVoxel[1], this.baseVoxel / this.nmPerVoxel[2]];
	  }
	
	  ScaleInfo.prototype.getNmPerVoxelVector = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Vector3, this.nmPerVoxel, function(){});
	  };
	
	  ScaleInfo.prototype.getVoxelPerNMVector = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Vector3, this.voxelPerNM, function(){});
	  };
	
	  ScaleInfo.prototype.voxelToNm = function(posArray) {
	    var i, j, nmPos, results;
	    nmPos = posArray.slice();
	    results = [];
	    for (i = j = 0; j <= 2; i = ++j) {
	      results.push(nmPos[i] *= this.nmPerVoxel[i]);
	    }
	    return results;
	  };
	
	  ScaleInfo.prototype.baseVoxelToVoxel = function(baseVoxel) {
	    var i, j, res;
	    res = this.baseVoxelFactors.slice();
	    for (i = j = 0; j <= 2; i = ++j) {
	      res *= baseVoxel;
	    }
	    return res;
	  };
	
	  return ScaleInfo;
	
	})();
	
	module.exports = ScaleInfo;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Dimensions, Flycam2d, app, constants;
	
	app = __webpack_require__(48);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	Flycam2d = (function() {
	  Flycam2d.prototype.TEXTURE_WIDTH = 512;
	
	  Flycam2d.prototype.MAX_TEXTURE_OFFSET = 31;
	
	  Flycam2d.prototype.MAX_ZOOM_THRESHOLD = 2;
	
	  Flycam2d.prototype.viewportWidth = 0;
	
	  function Flycam2d(viewportWidth, zoomStepCount, model1) {
	    var _trigger;
	    this.viewportWidth = viewportWidth;
	    this.zoomStepCount = zoomStepCount;
	    this.model = model1;
	    _.extend(this, Backbone.Events);
	    console.log("ZoomStepCount: ", this.zoomStepCount);
	    this.user = this.model.user;
	    this.maxZoomStepDiff = this.calculateMaxZoomStepDiff();
	    this.zoomStep = 0.0;
	    this.integerZoomStep = 0;
	    this.buffer = [[0, 0], [0, 0], [0, 0]];
	    this.position = [0, 0, 0];
	    this.direction = [0, 0, 1];
	    this.rayThreshold = [10, 10, 10, 100];
	    this.spaceDirection = [1, 1, 1];
	    this.quality = 0;
	    this.updateStoredValues();
	    this.user.set("zoom", Math.max(0.01, Math.min(this.user.get("zoom"), Math.floor(this.getMaxZoomStep()))));
	    this.listenTo(this.model.get("datasetConfiguration"), "change:quality", function(model, quality) {
	      return this.setQuality(quality);
	    });
	    this.listenTo(this.user, "change:zoom", function(model, zoomFactor) {
	      return this.zoom(Math.log(zoomFactor) / Math.LN2);
	    });
	    _trigger = this.trigger;
	    this.trigger = (function(_this) {
	      return function() {
	        _trigger.apply(_this, arguments);
	        return _trigger.call(_this, "changed");
	      };
	    })(this);
	  }
	
	  Flycam2d.prototype.calculateMaxZoomStepDiff = function() {
	    var zoomThreshold;
	    zoomThreshold = Math.min(this.MAX_ZOOM_THRESHOLD, (this.TEXTURE_WIDTH - this.MAX_TEXTURE_OFFSET) / this.viewportWidth);
	    return Math.log(zoomThreshold) / Math.LN2;
	  };
	
	  Flycam2d.prototype.zoomByDelta = function(delta) {
	    return this.zoom(this.zoomStep - delta * constants.ZOOM_DIFF);
	  };
	
	  Flycam2d.prototype.zoom = function(zoom) {
	    if (zoom < this.zoomStepCount + this.maxZoomStepDiff) {
	      return this.setZoomStep(zoom);
	    }
	  };
	
	  Flycam2d.prototype.setQuality = function(value) {
	    var i, j;
	    this.quality = value;
	    for (i = j = 0; j <= 2; i = ++j) {
	      this.updateStoredValues();
	    }
	    return this.update();
	  };
	
	  Flycam2d.prototype.calculateIntegerZoomStep = function() {
	    this.integerZoomStep = Math.ceil(this.zoomStep - this.maxZoomStepDiff + this.quality);
	    this.integerZoomStep = Math.min(this.integerZoomStep, this.zoomStepCount);
	    return this.integerZoomStep = Math.max(this.integerZoomStep, 0);
	  };
	
	  Flycam2d.prototype.getZoomStep = function() {
	    return this.zoomStep;
	  };
	
	  Flycam2d.prototype.setZoomStep = function(zoomStep) {
	    this.zoomStep = zoomStep;
	    this.update();
	    this.updateStoredValues();
	    return this.trigger("zoomStepChanged", zoomStep);
	  };
	
	  Flycam2d.prototype.getMaxZoomStep = function() {
	    var maxZoomStep;
	    maxZoomStep = this.zoomStepCount - 1;
	    return Math.pow(2, maxZoomStep + this.maxZoomStepDiff);
	  };
	
	  Flycam2d.prototype.calculateBuffer = function() {
	    var j, pixelNeeded, planeID, results, scaleArray;
	    results = [];
	    for (planeID = j = 0; j <= 2; planeID = ++j) {
	      scaleArray = Dimensions.transDim(app.scaleInfo.baseVoxelFactors, planeID);
	      pixelNeeded = this.viewportWidth * this.getTextureScalingFactor();
	      results.push(this.buffer[planeID] = [this.TEXTURE_WIDTH - pixelNeeded * scaleArray[0], this.TEXTURE_WIDTH - pixelNeeded * scaleArray[1]]);
	    }
	    return results;
	  };
	
	  Flycam2d.prototype.updateStoredValues = function() {
	    this.calculateIntegerZoomStep();
	    return this.calculateBuffer();
	  };
	
	  Flycam2d.prototype.getIntegerZoomStep = function() {
	    if (!this.integerZoomStep) {
	      this.calculateIntegerZoomStep();
	    }
	    return this.integerZoomStep;
	  };
	
	  Flycam2d.prototype.getTextureScalingFactor = function() {
	    return Math.pow(2, this.zoomStep) / Math.pow(2, this.integerZoomStep);
	  };
	
	  Flycam2d.prototype.getPlaneScalingFactor = function() {
	    return Math.pow(2, this.zoomStep);
	  };
	
	  Flycam2d.prototype.getDirection = function() {
	    return this.direction;
	  };
	
	  Flycam2d.prototype.setDirection = function(direction) {
	    this.direction = direction;
	    if (this.user.get("dynamicSpaceDirection")) {
	      return this.setSpaceDirection(direction);
	    }
	  };
	
	  Flycam2d.prototype.setSpaceDirection = function(direction) {
	    var index, j, results;
	    results = [];
	    for (index = j = 0; j <= 2; index = ++j) {
	      if (direction[index] <= 0) {
	        results.push(this.spaceDirection[index] = -1);
	      } else {
	        results.push(this.spaceDirection[index] = 1);
	      }
	    }
	    return results;
	  };
	
	  Flycam2d.prototype.getSpaceDirection = function() {
	    return this.spaceDirection;
	  };
	
	  Flycam2d.prototype.getRotation = function(planeID) {
	    switch (planeID) {
	      case constants.PLANE_XY:
	        return [0, 0, 0];
	      case constants.PLANE_YZ:
	        return [0, 270, 0];
	      case constants.PLANE_XZ:
	        return [90, 0, 0];
	    }
	  };
	
	  Flycam2d.prototype.move = function(p, planeID) {
	    if ((planeID != null)) {
	      p[Dimensions.getIndices(planeID)[2]] *= this.spaceDirection[Dimensions.getIndices(planeID)[2]];
	    }
	    return this.setPosition([this.position[0] + p[0], this.position[1] + p[1], this.position[2] + p[2]]);
	  };
	
	  Flycam2d.prototype.movePlane = function(vector, planeID, increaseSpeedWithZoom) {
	    var delta, ind, scaleFactor, zoomFactor;
	    if (increaseSpeedWithZoom == null) {
	      increaseSpeedWithZoom = true;
	    }
	    vector = Dimensions.transDim(vector, planeID);
	    ind = Dimensions.getIndices(planeID);
	    zoomFactor = increaseSpeedWithZoom ? Math.pow(2, this.zoomStep) : 1;
	    scaleFactor = app.scaleInfo.baseVoxelFactors;
	    delta = [vector[0] * zoomFactor * scaleFactor[0], vector[1] * zoomFactor * scaleFactor[1], vector[2] * zoomFactor * scaleFactor[2]];
	    return this.move(delta, planeID);
	  };
	
	  Flycam2d.prototype.toString = function() {
	    var position;
	    position = this.position;
	    return "(x, y, z) = (" + position[0] + ", " + position[1] + ", " + position[2] + ")";
	  };
	
	  Flycam2d.prototype.getPosition = function() {
	    return this.position;
	  };
	
	  Flycam2d.prototype.getViewportBoundingBox = function() {
	    var i, j, max, min, offset, position;
	    position = this.getPosition();
	    offset = this.getPlaneScalingFactor() * this.viewportWidth / 2;
	    min = [];
	    max = [];
	    for (i = j = 0; j <= 2; i = ++j) {
	      min.push(position[i] - offset * app.scaleInfo.baseVoxelFactors[i]);
	      max.push(position[i] + offset * app.scaleInfo.baseVoxelFactors[i]);
	    }
	    return {
	      min: min,
	      max: max
	    };
	  };
	
	  Flycam2d.prototype.getTexturePosition = function(planeID) {
	    var i, j, texturePosition;
	    texturePosition = this.position.slice();
	    for (i = j = 0; j <= 2; i = ++j) {
	      if (i !== Dimensions.getIndices(planeID)[2]) {
	        texturePosition[i] &= -1 << (5 + this.integerZoomStep);
	      }
	    }
	    return texturePosition;
	  };
	
	  Flycam2d.prototype.setPositionSilent = function(position) {
	    var i, j;
	    for (i = j = 0; j <= 2; i = ++j) {
	      if (position[i] == null) {
	        position[i] = this.position[i];
	      }
	    }
	    this.position = position;
	    return this.update();
	  };
	
	  Flycam2d.prototype.setPosition = function(position) {
	    this.setPositionSilent(position);
	    return this.trigger("positionChanged", position);
	  };
	
	  Flycam2d.prototype.needsUpdate = function(planeID) {
	    var area, ind, res;
	    area = this.getArea(planeID);
	    ind = Dimensions.getIndices(planeID);
	    res = ((area[0] < 0) || (area[1] < 0) || (area[2] > this.TEXTURE_WIDTH) || (area[3] > this.TEXTURE_WIDTH) || (this.zoomStep - (this.integerZoomStep - 1)) < this.maxZoomStepDiff) || (this.zoomStep - this.integerZoomStep > this.maxZoomStepDiff);
	    return res;
	  };
	
	  Flycam2d.prototype.getOffsets = function(planeID) {
	    var ind;
	    ind = Dimensions.getIndices(planeID);
	    return [this.buffer[planeID][0] / 2 + (this.position[ind[0]] - this.getTexturePosition(planeID)[ind[0]]) / Math.pow(2, this.integerZoomStep), this.buffer[planeID][1] / 2 + (this.position[ind[1]] - this.getTexturePosition(planeID)[ind[1]]) / Math.pow(2, this.integerZoomStep)];
	  };
	
	  Flycam2d.prototype.getArea = function(planeID) {
	    var offsets, scaleArray, size;
	    scaleArray = Dimensions.transDim(app.scaleInfo.baseVoxelFactors, planeID);
	    offsets = this.getOffsets(planeID);
	    size = this.getTextureScalingFactor() * this.viewportWidth;
	    return [offsets[0], offsets[1], offsets[0] + size * scaleArray[0], offsets[1] + size * scaleArray[1]];
	  };
	
	  Flycam2d.prototype.getAreas = function() {
	    var i, j, result;
	    result = [];
	    for (i = j = 0; j <= 2; i = ++j) {
	      result.push(this.getArea(i));
	    }
	    return result;
	  };
	
	  Flycam2d.prototype.setRayThreshold = function(cameraRight, cameraLeft) {
	    return this.rayThreshold[constants.TDView] = 8 * (cameraRight - cameraLeft) / 384;
	  };
	
	  Flycam2d.prototype.getRayThreshold = function(planeID) {
	    if (planeID < 3) {
	      return this.rayThreshold[planeID] * Math.pow(2, this.zoomStep) * app.scaleInfo.baseVoxel;
	    } else {
	      return this.rayThreshold[planeID];
	    }
	  };
	
	  Flycam2d.prototype.update = function() {
	    return app.vent.trigger("rerender");
	  };
	
	  return Flycam2d;
	
	})();
	
	module.exports = Flycam2d;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var Flycam3d, M4x4, THREE, V3, _, ref, transformationWithDistanceMacro, updateMacro;
	
	_ = __webpack_require__(2);
	
	THREE = __webpack_require__(245);
	
	ref = __webpack_require__(189), M4x4 = ref.M4x4, V3 = ref.V3;
	
	updateMacro = function(_this) {
	  _this.trigger("changed", _this.currentMatrix, _this.zoomStep);
	  return _this.hasChanged = true;
	};
	
	transformationWithDistanceMacro = function(_this, transformationFn, transformationArg1, transformationArg2) {
	  var currentMatrix;
	  currentMatrix = _this.currentMatrix;
	  M4x4.translate(_this.distanceVecNegative, currentMatrix, currentMatrix);
	  transformationFn.call(_this, transformationArg1, transformationArg2);
	  M4x4.translate(_this.distanceVecPositive, currentMatrix, currentMatrix);
	  return updateMacro(_this);
	};
	
	Flycam3d = (function() {
	  Flycam3d.prototype.ZOOM_STEP_INTERVAL = 1.1;
	
	  Flycam3d.prototype.ZOOM_STEP_MIN = 0.5;
	
	  Flycam3d.prototype.ZOOM_STEP_MAX = 5;
	
	  Flycam3d.prototype.zoomStep = 1.3;
	
	  Flycam3d.prototype.hasChanged = true;
	
	  Flycam3d.prototype.scale = null;
	
	  Flycam3d.prototype.currentMatrix = null;
	
	  function Flycam3d(distance, scale) {
	    this.distance = distance;
	    _.extend(this, Backbone.Events);
	    this.scale = this.calculateScaleValues(scale);
	    this.reset();
	    this.distanceVecNegative = [0, 0, -this.distance];
	    this.distanceVecPositive = [0, 0, this.distance];
	  }
	
	  Flycam3d.prototype.calculateScaleValues = function(scale) {
	    var maxScale, multi;
	    scale = [1 / scale[0], 1 / scale[1], 1 / scale[2]];
	    maxScale = Math.max(scale[0], scale[1], scale[2]);
	    multi = 1 / maxScale;
	    scale = [multi * scale[0], multi * scale[1], multi * scale[2]];
	    return scale;
	  };
	
	  Flycam3d.prototype.reset = function(resetPosition) {
	    var m, position, scale;
	    if (resetPosition == null) {
	      resetPosition = true;
	    }
	    scale = this.scale;
	    if (this.currentMatrix != null) {
	      position = this.currentMatrix.slice(12, 15);
	    }
	    m = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    M4x4.scale(scale, m, m);
	    this.currentMatrix = m;
	    if ((position != null) && !resetPosition) {
	      this.setPosition(position);
	    }
	    this.roll(Math.PI);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.update = function() {
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.flush = function() {
	    if (this.hasChanged) {
	      this.hasChanged = false;
	      return true;
	    } else {
	      return false;
	    }
	  };
	
	  Flycam3d.prototype.zoomIn = function() {
	    this.zoomStep = Math.max(this.zoomStep / this.ZOOM_STEP_INTERVAL, this.ZOOM_STEP_MIN);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.zoomOut = function() {
	    this.zoomStep = Math.min(this.zoomStep * this.ZOOM_STEP_INTERVAL, this.ZOOM_STEP_MAX);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.getZoomStep = function() {
	    return this.zoomStep;
	  };
	
	  Flycam3d.prototype.setZoomStep = function(zoomStep) {
	    return this.zoomStep = Math.min(this.ZOOM_STEP_MAX, Math.max(this.ZOOM_STEP_MIN, zoomStep));
	  };
	
	  Flycam3d.prototype.getMatrix = function() {
	    return M4x4.clone(this.currentMatrix);
	  };
	
	  Flycam3d.prototype.getZoomedMatrix = function() {
	    var matrix;
	    matrix = this.getMatrix();
	    return M4x4.scale1(this.zoomStep, matrix, matrix);
	  };
	
	  Flycam3d.prototype.setMatrix = function(matrix) {
	    this.currentMatrix = M4x4.clone(matrix);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.move = function(vector) {
	    M4x4.translate(vector, this.currentMatrix, this.currentMatrix);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.yaw = function(angle, regardDistance) {
	    if (regardDistance == null) {
	      regardDistance = false;
	    }
	    if (regardDistance) {
	      transformationWithDistanceMacro(this, this.yawSilent, angle);
	    } else {
	      this.yawSilent(angle);
	    }
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.yawSilent = function(angle) {
	    return this.rotateOnAxisSilent(angle, [0, 1, 0]);
	  };
	
	  Flycam3d.prototype.roll = function(angle, regardDistance) {
	    if (regardDistance == null) {
	      regardDistance = false;
	    }
	    if (regardDistance) {
	      transformationWithDistanceMacro(this, this.rollSilent, angle);
	    } else {
	      this.rollSilent(angle);
	    }
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.rollSilent = function(angle) {
	    return this.rotateOnAxisSilent(angle, [0, 0, 1]);
	  };
	
	  Flycam3d.prototype.pitch = function(angle, regardDistance) {
	    if (regardDistance == null) {
	      regardDistance = false;
	    }
	    if (regardDistance) {
	      transformationWithDistanceMacro(this, this.pitchSilent, angle);
	    } else {
	      this.pitchSilent(angle);
	    }
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.pitchSilent = function(angle) {
	    return this.rotateOnAxisSilent(angle, [1, 0, 0]);
	  };
	
	  Flycam3d.prototype.rotateOnAxis = function(angle, axis) {
	    this.rotateOnAxisSilent(angle, axis);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.rotateOnAxisSilent = function(angle, axis) {
	    return M4x4.rotate(angle, axis, this.currentMatrix, this.currentMatrix);
	  };
	
	  Flycam3d.prototype.rotateOnAxisDistance = function(angle, axis) {
	    return transformationWithDistanceMacro(this, this.rotateOnAxisSilent, angle, axis);
	  };
	
	  Flycam3d.prototype.toString = function() {
	    var matrix;
	    matrix = this.currentMatrix;
	    return "[" + matrix[0] + ", " + matrix[1] + ", " + matrix[2] + ", " + matrix[3] + ", " + matrix[4] + ", " + matrix[5] + ", " + matrix[6] + ", " + matrix[7] + ", " + matrix[8] + ", " + matrix[9] + ", " + matrix[10] + ", " + matrix[11] + ", " + matrix[12] + ", " + matrix[13] + ", " + matrix[14] + ", " + matrix[15] + "]";
	  };
	
	  Flycam3d.prototype.getPosition = function() {
	    var matrix;
	    matrix = this.currentMatrix;
	    return [matrix[12], matrix[13], matrix[14]];
	  };
	
	  Flycam3d.prototype.getRotation = function() {
	    var matrix, mod, object;
	    object = new THREE.Object3D();
	    matrix = (new THREE.Matrix4()).fromArray(this.currentMatrix).transpose();
	    object.applyMatrix(matrix);
	    mod = function(x, n) {
	      return ((x % n) + n) % n;
	    };
	    return _.map([object.rotation.x, object.rotation.y, object.rotation.z - Math.PI], function(e) {
	      return mod(180 / Math.PI * e, 360);
	    });
	  };
	
	  Flycam3d.prototype.setPositionSilent = function(p) {
	    var matrix;
	    matrix = this.currentMatrix;
	    matrix[12] = p[0];
	    matrix[13] = p[1];
	    return matrix[14] = p[2];
	  };
	
	  Flycam3d.prototype.setPosition = function(p) {
	    this.setPositionSilent(p);
	    return updateMacro(this);
	  };
	
	  Flycam3d.prototype.setRotation = function(arg) {
	    var x, y, z;
	    x = arg[0], y = arg[1], z = arg[2];
	    this.reset(false);
	    this.roll(-z * Math.PI / 180);
	    this.yaw(-y * Math.PI / 180);
	    return this.pitch(-x * Math.PI / 180);
	  };
	
	  Flycam3d.prototype.getCurrentUpVector = function() {
	    var currentRotation, up;
	    currentRotation = new THREE.Matrix4();
	    currentRotation.extractRotation((function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Matrix4, this.currentMatrix, function(){}));
	    up = new THREE.Vector3(0, 1, 0);
	    up.applyMatrix4(currentRotation);
	    return up;
	  };
	
	  Flycam3d.prototype.convertToJsArray = function(floatXArray) {
	    return Array.prototype.slice.call(floatXArray);
	  };
	
	  Flycam3d.prototype.getUp = function() {
	    var matrix;
	    matrix = this.currentMatrix;
	    return [matrix[4], matrix[5], matrix[6]];
	  };
	
	  Flycam3d.prototype.getLeft = function() {
	    var matrix;
	    matrix = this.currentMatrix;
	    return [matrix[0], matrix[1], matrix[2]];
	  };
	
	  return Flycam3d;
	
	})();
	
	module.exports = Flycam3d;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var $, THREE, Toast, View, app, constants, modal;
	
	$ = __webpack_require__(1);
	
	app = __webpack_require__(48);
	
	Toast = __webpack_require__(18);
	
	THREE = __webpack_require__(245);
	
	constants = __webpack_require__(61);
	
	modal = __webpack_require__(307);
	
	View = (function() {
	  function View(model) {
	    this.model = model;
	    if (!this.isWebGlSupported()) {
	      Toast.error("Couldn't initialise WebGL, please make sure you are using Google Chrome and WebGL is enabled.<br>" + "<a href='http://get.webgl.org/'>http://get.webgl.org/</a>");
	    }
	    this.renderer = new THREE.WebGLRenderer({
	      clearColor: 0x000000,
	      clearAlpha: 1.0,
	      antialias: false
	    });
	    this.scene = new THREE.Scene();
	    this.setTheme(constants.THEME_BRIGHT);
	    $("#loader").addClass("hidden");
	  }
	
	  View.prototype.toggleTheme = function() {
	    if (this.theme === constants.THEME_BRIGHT) {
	      return this.setTheme(constants.THEME_DARK);
	    } else {
	      return this.setTheme(constants.THEME_BRIGHT);
	    }
	  };
	
	  View.prototype.setTheme = function(theme) {
	    this.theme = theme;
	    app.vent.trigger("view:setTheme", theme);
	    if (theme === constants.THEME_BRIGHT) {
	      return $("body").attr('class', 'bright');
	    } else {
	      return $("body").attr('class', 'dark');
	    }
	  };
	
	  View.prototype.isWebGlSupported = function() {
	    return window.WebGLRenderingContext && document.createElement('canvas').getContext('experimental-webgl');
	  };
	
	  return View;
	
	})();
	
	module.exports = View;


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var $, Modal;
	
	$ = __webpack_require__(1);
	
	Modal = {
	  callbacks: {},
	  show: function(text, title, buttons) {
	    var button, html, i, j, len, len1;
	    if (title == null) {
	      title = "Ups...";
	    }
	    if (buttons == null) {
	      buttons = [
	        {
	          id: "ok-button",
	          label: "OK"
	        }
	      ];
	    }
	    html = "<div class=\"modal-dialog\">\n  <div class=\"modal-content\">\n    <div class=\"modal-header\">\n      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n      <h4 class=\"modal-title\" id=\"myModalLabel\">" + title + "</h4>\n    </div>\n    <div class=\"modal-body\">\n      <p>" + text + "</p>\n    </div>";
	    html += "<div class=\"modal-footer\">";
	    for (i = 0, len = buttons.length; i < len; i++) {
	      button = buttons[i];
	      html += "<a href=\"#\" id=\"" + button.id + "\" class=\"btn btn-default\">" + button.label + "</a>";
	    }
	    html += "</div></div></div>";
	    $("#modal").html(html);
	    for (j = 0, len1 = buttons.length; j < len1; j++) {
	      button = buttons[j];
	      this.callbacks[button.id] = button.callback;
	      $("#" + button.id).on("click", (function(_this) {
	        return function(evt) {
	          var callback;
	          callback = _this.callbacks[evt.target.id];
	          if (callback != null) {
	            callback();
	          }
	          return $("#modal").modal("hide");
	        };
	      })(this));
	    }
	    return $("#modal").modal("show");
	  },
	  hide: function() {
	    return $("#modal").modal("hide");
	  }
	};
	
	module.exports = Modal;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var $, Backbone, Dimensions, PlaneView, THREE, TWEEN, Toast, app, constants, modal,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	$ = __webpack_require__(1);
	
	TWEEN = __webpack_require__(248);
	
	Dimensions = __webpack_require__(277);
	
	Toast = __webpack_require__(18);
	
	constants = __webpack_require__(61);
	
	modal = __webpack_require__(307);
	
	THREE = __webpack_require__(245);
	
	PlaneView = (function() {
	  function PlaneView(model1, view) {
	    var HEIGHT, WIDTH, cam, container, directionalLight, i, j, k, len, len1, ref, ref1, ref2;
	    this.model = model1;
	    this.view = view;
	    this.getCameras = bind(this.getCameras, this);
	    this.setActiveViewport = bind(this.setActiveViewport, this);
	    this.scaleTrianglesPlane = bind(this.scaleTrianglesPlane, this);
	    this.resize = bind(this.resize, this);
	    _.extend(this, Backbone.Events);
	    ref = this.view, this.renderer = ref.renderer, this.scene = ref.scene;
	    this.running = false;
	    container = $("#render");
	    this.curWidth = WIDTH = HEIGHT = constants.VIEWPORT_WIDTH;
	    this.scaleFactor = 1;
	    this.deviceScaleFactor = window.devicePixelRatio || 1;
	    this.camera = new Array(4);
	    this.lights = new Array(3);
	    ref1 = constants.ALL_VIEWPORTS;
	    for (j = 0, len = ref1.length; j < len; j++) {
	      i = ref1[j];
	      this.camera[i] = new THREE.OrthographicCamera(0, 0, 0, 0);
	      this.scene.add(this.camera[i]);
	    }
	    this.camera[constants.PLANE_XY].position.z = -1;
	    this.camera[constants.PLANE_YZ].position.x = 1;
	    this.camera[constants.PLANE_XZ].position.y = 1;
	    this.camera[constants.TDView].position = new THREE.Vector3(10, 10, -10);
	    this.camera[constants.PLANE_XY].up = new THREE.Vector3(0, -1, 0);
	    this.camera[constants.PLANE_YZ].up = new THREE.Vector3(0, -1, 0);
	    this.camera[constants.PLANE_XZ].up = new THREE.Vector3(0, 0, -1);
	    this.camera[constants.TDView].up = new THREE.Vector3(0, 0, -1);
	    ref2 = this.camera;
	    for (k = 0, len1 = ref2.length; k < len1; k++) {
	      cam = ref2[k];
	      cam.lookAt(new THREE.Vector3(0, 0, 0));
	    }
	    this.group = new THREE.Object3D;
	    this.group.scale = app.scaleInfo.getNmPerVoxelVector();
	    this.scene.add(this.group);
	    this.scene.add(new THREE.AmbientLight(0x333333));
	    directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
	    directionalLight.position.set(1, 1, -1).normalize();
	    this.scene.add(directionalLight);
	    directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
	    directionalLight.position.set(-1, -1, -1).normalize();
	    this.scene.add(directionalLight);
	    this.renderer.setSize(2 * WIDTH + 20, 2 * HEIGHT + 20);
	    $(this.renderer.domElement).attr({
	      "id": "render-canvas"
	    });
	    container.append(this.renderer.domElement);
	    this.setActiveViewport(constants.PLANE_XY);
	    this.first = true;
	    this.newTextures = [true, true, true, true];
	    this.needsRerender = true;
	    app.vent.on("rerender", (function(_this) {
	      return function() {
	        return _this.needsRerender = true;
	      };
	    })(this));
	  }
	
	  PlaneView.prototype.animate = function() {
	    if (!this.running) {
	      return;
	    }
	    this.renderFunction();
	    return window.requestAnimationFrame((function(_this) {
	      return function() {
	        return _this.animate();
	      };
	    })(this));
	  };
	
	  PlaneView.prototype.renderFunction = function() {
	    var binary, i, j, k, len, len1, modelChanged, name, plane, ref, ref1, ref2, setupRenderArea, viewport;
	    TWEEN.update();
	    modelChanged = false;
	    ref = this.model.binary;
	    for (name in ref) {
	      binary = ref[name];
	      ref1 = binary.planes;
	      for (j = 0, len = ref1.length; j < len; j++) {
	        plane = ref1[j];
	        modelChanged |= plane.hasChanged();
	      }
	    }
	    if (this.needsRerender || modelChanged) {
	      this.trigger("render");
	      viewport = [[0, this.curWidth + 20], [this.curWidth + 20, this.curWidth + 20], [0, 0], [this.curWidth + 20, 0]];
	      this.renderer.autoClear = true;
	      setupRenderArea = (function(_this) {
	        return function(x, y, width, color) {
	          _this.renderer.setViewport(x, y, width, width);
	          _this.renderer.setScissor(x, y, width, width);
	          _this.renderer.enableScissorTest(true);
	          return _this.renderer.setClearColor(color, 1);
	        };
	      })(this);
	      setupRenderArea(0, 0, this.renderer.domElement.width, 0xffffff);
	      this.renderer.clear();
	      ref2 = constants.ALL_VIEWPORTS;
	      for (k = 0, len1 = ref2.length; k < len1; k++) {
	        i = ref2[k];
	        this.trigger("renderCam", i);
	        setupRenderArea(viewport[i][0] * this.deviceScaleFactor, viewport[i][1] * this.deviceScaleFactor, this.curWidth * this.deviceScaleFactor, constants.PLANE_COLORS[i]);
	        this.renderer.render(this.scene, this.camera[i]);
	      }
	      return this.needsRerender = false;
	    }
	  };
	
	  PlaneView.prototype.addGeometry = function(geometry) {
	    return this.group.add(geometry);
	  };
	
	  PlaneView.prototype.removeGeometry = function(geometry) {
	    return this.group.remove(geometry);
	  };
	
	  PlaneView.prototype.draw = function() {
	    return app.vent.trigger("rerender");
	  };
	
	  PlaneView.prototype.resizeThrottled = function() {
	    this.resizeThrottled = _.throttle((function(_this) {
	      return function() {
	        _this.resize();
	        return app.vent.trigger("planes:resize");
	      };
	    })(this), constants.RESIZE_THROTTLE_TIME);
	    return this.resizeThrottled();
	  };
	
	  PlaneView.prototype.resize = function() {
	    var HEIGHT, TDView, WIDTH, canvas, i, j, len, ref;
	    canvas = $("#render-canvas");
	    WIDTH = (canvas.width() - 20) / 2;
	    HEIGHT = (canvas.height() - 20) / 2;
	    this.renderer.setSize(2 * WIDTH + 20, 2 * HEIGHT + 20);
	    ref = constants.ALL_VIEWPORTS;
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      this.camera[i].aspect = WIDTH / HEIGHT;
	      this.camera[i].updateProjectionMatrix();
	    }
	    this.draw();
	    TDView = $("#TDView");
	    return TDView.trigger($.Event('resizeCanvas'));
	  };
	
	  PlaneView.prototype.scaleTrianglesPlane = function(scale) {
	    var HEIGHT, WIDTH, canvas;
	    this.scaleFactor = scale;
	    this.curWidth = WIDTH = HEIGHT = Math.round(this.scaleFactor * constants.VIEWPORT_WIDTH);
	    canvas = $("#render-canvas");
	    canvas.width(2 * WIDTH + 20);
	    canvas.height(2 * HEIGHT + 20);
	    $('#TDViewControls button').outerWidth(this.curWidth / 4 - 0.5);
	    $(".inputcatcher").css({
	      width: WIDTH,
	      height: HEIGHT
	    });
	    return this.resizeThrottled();
	  };
	
	  PlaneView.prototype.setActiveViewport = function(viewportID) {
	    var i, j;
	    for (i = j = 0; j <= 3; i = ++j) {
	      if (i === viewportID) {
	        $(".inputcatcher").eq(i).removeClass("inactive").addClass("active");
	      } else {
	        $(".inputcatcher").eq(i).removeClass("active").addClass("inactive");
	      }
	    }
	    return this.draw();
	  };
	
	  PlaneView.prototype.getCameras = function() {
	    return this.camera;
	  };
	
	  PlaneView.prototype.showBranchModal = function(callback) {
	    return modal.show("You didn't add a node after jumping to this branchpoint, do you really want to jump again?", "Jump again?", [
	      {
	        id: "jump-button",
	        label: "Jump again",
	        callback: callback
	      }, {
	        id: "cancel-button",
	        label: "Cancel"
	      }
	    ]);
	  };
	
	  PlaneView.prototype.bindToEvents = function() {
	    if (this.model.skeletonTracing) {
	      this.listenTo(this.model.skeletonTracing, "doubleBranch", this.showBranchModal);
	      this.listenTo(this.model.skeletonTracing, "mergeDifferentTrees", function() {
	        return Toast.error("You can't merge nodes within the same tree", false);
	      });
	    }
	    return this.listenTo(this.model.user, "change:scale", function(model, scale) {
	      if (this.running) {
	        return this.scaleTrianglesPlane(scale);
	      }
	    });
	  };
	
	  PlaneView.prototype.stop = function() {
	    $(".inputcatcher").hide();
	    return this.running = false;
	  };
	
	  PlaneView.prototype.start = function() {
	    this.running = true;
	    $(".inputcatcher").show();
	    this.scaleTrianglesPlane(this.model.user.get("scale"));
	    return this.animate();
	  };
	
	  return PlaneView;
	
	})();
	
	module.exports = PlaneView;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Dimensions, SkeletonTracingController, app, backbone, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	app = __webpack_require__(48);
	
	backbone = __webpack_require__(3);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	SkeletonTracingController = (function() {
	  function SkeletonTracingController(model, skeletonTracingView, sceneController) {
	    this.model = model;
	    this.skeletonTracingView = skeletonTracingView;
	    this.sceneController = sceneController;
	    this.centerActiveNode = bind(this.centerActiveNode, this);
	    this.toggleSkeletonVisibility = bind(this.toggleSkeletonVisibility, this);
	    this.setParticleSize = bind(this.setParticleSize, this);
	    _.extend(this, Backbone.Events);
	  }
	
	  SkeletonTracingController.prototype.setParticleSize = function(delta) {
	    var particleSize;
	    particleSize = this.model.user.get("particleSize") + delta;
	    particleSize = Math.min(constants.MAX_PARTICLE_SIZE, particleSize);
	    particleSize = Math.max(constants.MIN_PARTICLE_SIZE, particleSize);
	    return this.model.user.set("particleSize", Number(particleSize));
	  };
	
	  SkeletonTracingController.prototype.setRadius = function(delta) {
	    return this.model.skeletonTracing.setActiveNodeRadius(this.model.skeletonTracing.getActiveNodeRadius() * Math.pow(1.05, delta));
	  };
	
	  SkeletonTracingController.prototype.toggleSkeletonVisibility = function() {
	    this.sceneController.skeleton.toggleVisibility();
	    if (this.model.user.get("firstVisToggle")) {
	      this.skeletonTracingView.showFirstVisToggle();
	      this.model.user.set("firstVisToggle", false);
	      return this.model.user.push();
	    }
	  };
	
	  SkeletonTracingController.prototype.setActiveNode = function(nodeId, merge, centered) {
	    if (merge == null) {
	      merge = false;
	    }
	    if (centered == null) {
	      centered = false;
	    }
	    this.model.skeletonTracing.setActiveNode(nodeId, merge);
	    if (centered) {
	      return this.model.skeletonTracing.centerActiveNode();
	    }
	  };
	
	  SkeletonTracingController.prototype.centerActiveNode = function() {
	    var position;
	    position = this.model.skeletonTracing.getActiveNodePos();
	    if (position) {
	      return this.model.flycam.setPosition(position);
	    }
	  };
	
	  return SkeletonTracingController;
	
	})();
	
	module.exports = SkeletonTracingController;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_, $) {var Backbone, Dimensions, Input, VolumeTracingController, app;
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	Dimensions = __webpack_require__(277);
	
	Input = __webpack_require__(233);
	
	VolumeTracingController = (function() {
	  VolumeTracingController.prototype.MERGE_MODE_NORMAL = 0;
	
	  VolumeTracingController.prototype.MERGE_MODE_CELL1 = 1;
	
	  VolumeTracingController.prototype.MERGE_MODE_CELL2 = 2;
	
	  function VolumeTracingController(model, volumeTracingView, sceneController) {
	    var fn, input, inputModeMapping, isMergeVisible;
	    this.model = model;
	    this.volumeTracingView = volumeTracingView;
	    this.sceneController = sceneController;
	    this.inDeleteMode = false;
	    _.extend(this, Backbone.Events);
	    $('#create-cell-button').on("click", (function(_this) {
	      return function() {
	        return _this.model.volumeTracing.createCell();
	      };
	    })(this));
	    new Input.KeyboardNoLoop({
	      "w": (function(_this) {
	        return function() {
	          return _this.model.volumeTracing.toggleMode();
	        };
	      })(this),
	      "1": (function(_this) {
	        return function() {
	          return _this.model.volumeTracing.toggleMode();
	        };
	      })(this)
	    });
	    $("#btn-merge").hide();
	    this.mergeMode = this.MERGE_MODE_NORMAL;
	    isMergeVisible = function() {
	      return $("#merge").css("visibility") === "visible";
	    };
	    $("#btn-merge").on("click", function() {
	      $("#merge").css({
	        visibility: isMergeVisible() ? "hidden" : "visible"
	      });
	      if (isMergeVisible()) {
	        return $("#merge-cell1").focus();
	      }
	    });
	    inputModeMapping = {
	      "#merge-cell1": this.MERGE_MODE_CELL1,
	      "#merge-cell2": this.MERGE_MODE_CELL2
	    };
	    fn = (function(_this) {
	      return function(input) {
	        $(input).on("focus", function() {
	          _this.mergeMode = inputModeMapping[input];
	          return console.log(_this.mergeMode);
	        });
	        return $(input).keypress(function(event) {
	          if (event.which === 13) {
	            return _this.merge();
	          }
	        });
	      };
	    })(this);
	    for (input in inputModeMapping) {
	      fn(input);
	    }
	  }
	
	  VolumeTracingController.prototype.merge = function() {
	    var i, input, inputs, len, results;
	    inputs = [$("#merge-cell1"), $("#merge-cell2")];
	    $("#merge").css({
	      visibility: "hidden"
	    });
	    console.log("Merge:", $("#merge-cell1").val(), $("#merge-cell2").val());
	    results = [];
	    for (i = 0, len = inputs.length; i < len; i++) {
	      input = inputs[i];
	      input.blur();
	      results.push(input.val(""));
	    }
	    return results;
	  };
	
	  VolumeTracingController.prototype.handleCellSelection = function(cellId) {
	    if (cellId > 0) {
	      if (this.mergeMode === this.MERGE_MODE_NORMAL) {
	        return this.model.volumeTracing.setActiveCell(cellId);
	      } else if (this.mergeMode === this.MERGE_MODE_CELL1) {
	        $("#merge-cell1").val(cellId);
	        return $("#merge-cell2").focus();
	      } else if (this.mergeMode === this.MERGE_MODE_CELL2) {
	        $("#merge-cell2").val(cellId);
	        return this.merge();
	      }
	    }
	  };
	
	  VolumeTracingController.prototype.enterDeleteMode = function() {
	    if (this.inDeleteMode) {
	      return;
	    }
	    this.inDeleteMode = true;
	    this.prevActiveCell = this.model.volumeTracing.getActiveCellId();
	    return this.model.volumeTracing.setActiveCell(0);
	  };
	
	  VolumeTracingController.prototype.restoreAfterDeleteMode = function() {
	    if (this.inDeleteMode) {
	      this.model.volumeTracing.setActiveCell(this.prevActiveCell);
	    }
	    return this.inDeleteMode = false;
	  };
	
	  VolumeTracingController.prototype.drawVolume = function(pos) {
	    return this.model.volumeTracing.addToLayer(pos);
	  };
	
	  return VolumeTracingController;
	
	})();
	
	module.exports = VolumeTracingController;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(1)))

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	var ArbitraryController, SkeletonTracingArbitraryController,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	ArbitraryController = __webpack_require__(247);
	
	SkeletonTracingArbitraryController = (function(superClass) {
	  extend(SkeletonTracingArbitraryController, superClass);
	
	  function SkeletonTracingArbitraryController() {
	    return SkeletonTracingArbitraryController.__super__.constructor.apply(this, arguments);
	  }
	
	  return SkeletonTracingArbitraryController;
	
	})(ArbitraryController);
	
	module.exports = SkeletonTracingArbitraryController;


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {var PlaneController, SkeletonTracingPlaneController, THREE, TWEEN, _, app, constants, dimensions,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	app = __webpack_require__(48);
	
	THREE = __webpack_require__(245);
	
	TWEEN = __webpack_require__(248);
	
	_ = __webpack_require__(2);
	
	PlaneController = __webpack_require__(263);
	
	constants = __webpack_require__(61);
	
	dimensions = __webpack_require__(277);
	
	SkeletonTracingPlaneController = (function(superClass) {
	  extend(SkeletonTracingPlaneController, superClass);
	
	  function SkeletonTracingPlaneController(model, view, sceneController, skeletonTracingController) {
	    this.model = model;
	    this.view = view;
	    this.sceneController = sceneController;
	    this.skeletonTracingController = skeletonTracingController;
	    this.addNode = bind(this.addNode, this);
	    this.setWaypoint = bind(this.setWaypoint, this);
	    this.onClick = bind(this.onClick, this);
	    this.scrollPlanes = bind(this.scrollPlanes, this);
	    this.popBranch = bind(this.popBranch, this);
	    SkeletonTracingPlaneController.__super__.constructor.call(this, this.model, this.view, this.sceneController);
	  }
	
	  SkeletonTracingPlaneController.prototype.start = function() {
	    SkeletonTracingPlaneController.__super__.start.call(this);
	    return $('.skeleton-plane-controls').show();
	  };
	
	  SkeletonTracingPlaneController.prototype.stop = function() {
	    SkeletonTracingPlaneController.__super__.stop.call(this);
	    return $('.skeleton-plane-controls').hide();
	  };
	
	  SkeletonTracingPlaneController.prototype.getPlaneMouseControls = function(planeId) {
	    return _.extend(SkeletonTracingPlaneController.__super__.getPlaneMouseControls.call(this, planeId), {
	      leftClick: (function(_this) {
	        return function(pos, plane, event) {
	          return _this.onClick(pos, event.shiftKey, event.altKey, plane);
	        };
	      })(this),
	      rightClick: (function(_this) {
	        return function(pos, plane, event) {
	          return _this.setWaypoint(_this.calculateGlobalPos(pos), event.ctrlKey);
	        };
	      })(this)
	    });
	  };
	
	  SkeletonTracingPlaneController.prototype.getTDViewMouseControls = function() {
	    return _.extend(SkeletonTracingPlaneController.__super__.getTDViewMouseControls.call(this), {
	      leftClick: (function(_this) {
	        return function(position, plane, event) {
	          return _this.onClick(position, event.shiftKey, event.altKey, constants.TDView);
	        };
	      })(this)
	    });
	  };
	
	  SkeletonTracingPlaneController.prototype.getKeyboardControls = function() {
	    return _.extend(SkeletonTracingPlaneController.__super__.getKeyboardControls.call(this), {
	      "1": (function(_this) {
	        return function() {
	          return _this.skeletonTracingController.toggleSkeletonVisibility();
	        };
	      })(this),
	      "2": (function(_this) {
	        return function() {
	          return _this.sceneController.skeleton.toggleInactiveTreeVisibility();
	        };
	      })(this),
	      "delete": (function(_this) {
	        return function() {
	          return _this.model.skeletonTracing.deleteActiveNode();
	        };
	      })(this),
	      "c": (function(_this) {
	        return function() {
	          return _this.model.skeletonTracing.createNewTree();
	        };
	      })(this),
	      "b": (function(_this) {
	        return function() {
	          return _this.model.skeletonTracing.pushBranch();
	        };
	      })(this),
	      "j": (function(_this) {
	        return function() {
	          return _this.popBranch();
	        };
	      })(this),
	      "s": (function(_this) {
	        return function() {
	          _this.skeletonTracingController.centerActiveNode();
	          return _this.cameraController.centerTDView();
	        };
	      })(this)
	    });
	  };
	
	  SkeletonTracingPlaneController.prototype.popBranch = function() {
	    return _.defer((function(_this) {
	      return function() {
	        return _this.model.skeletonTracing.popBranch().then(function(id) {
	          return _this.skeletonTracingController.setActiveNode(id, false, true);
	        });
	      };
	    })(this));
	  };
	
	  SkeletonTracingPlaneController.prototype.scrollPlanes = function(delta, type) {
	    SkeletonTracingPlaneController.__super__.scrollPlanes.call(this, delta, type);
	    if (type === "shift") {
	      return this.skeletonTracingController.setRadius(delta);
	    }
	  };
	
	  SkeletonTracingPlaneController.prototype.onClick = function(position, shiftPressed, altPressed, plane) {
	    var camera, centered, geometry, globalPos, i, ind, index, intersect, intersects, intersectsCoord, len, nodeID, posArray, projector, raycaster, results, scaleFactor, vector;
	    if (!shiftPressed) {
	      return;
	    }
	    scaleFactor = this.planeView.scaleFactor;
	    camera = this.planeView.getCameras()[plane];
	    vector = new THREE.Vector3((position.x / (384 * scaleFactor)) * 2 - 1, -(position.y / (384 * scaleFactor)) * 2 + 1, 0.5);
	    projector = new THREE.Projector();
	    raycaster = projector.pickingRay(vector, camera);
	    raycaster.ray.threshold = this.model.flycam.getRayThreshold(plane);
	    raycaster.ray.__scalingFactors = app.scaleInfo.nmPerVoxel;
	    intersects = raycaster.intersectObjects(this.sceneController.skeleton.getAllNodes());
	    results = [];
	    for (i = 0, len = intersects.length; i < len; i++) {
	      intersect = intersects[i];
	      index = intersect.index;
	      geometry = intersect.object.geometry;
	      if (geometry.nodeIDs.getLength() <= index) {
	        continue;
	      }
	      nodeID = geometry.nodeIDs.getAllElements()[index];
	      posArray = geometry.attributes.position.array;
	      intersectsCoord = [posArray[3 * index], posArray[3 * index + 1], posArray[3 * index + 2]];
	      globalPos = this.model.flycam.getPosition();
	      ind = dimensions.getIndices(plane);
	      if (intersect.object.visible && (plane === constants.TDView || (Math.abs(globalPos[ind[2]] - intersectsCoord[ind[2]]) < this.cameraController.getClippingDistance(ind[2]) + 1))) {
	        centered = plane === constants.TDView;
	        this.skeletonTracingController.setActiveNode(nodeID, shiftPressed && altPressed, centered);
	        break;
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  SkeletonTracingPlaneController.prototype.setWaypoint = function(position, ctrlPressed) {
	    var activeNode, rotation;
	    activeNode = this.model.skeletonTracing.getActiveNode();
	    if (activeNode) {
	      this.model.flycam.setDirection([position[0] - activeNode.pos[0], position[1] - activeNode.pos[1], position[2] - activeNode.pos[2]]);
	    }
	    rotation = this.model.flycam.getRotation(this.activeViewport);
	    this.addNode(position, rotation, !ctrlPressed);
	    if (ctrlPressed && this.model.user.get("newNodeNewTree") === false && this.model.skeletonTracing.getActiveNodeType() === constants.TYPE_USUAL) {
	      this.model.skeletonTracing.pushBranch();
	      return this.skeletonTracingController.setActiveNode(activeNode.id);
	    }
	  };
	
	  SkeletonTracingPlaneController.prototype.addNode = function(position, rotation, centered) {
	    var datasetConfig;
	    if (this.model.user.get("newNodeNewTree") === true) {
	      this.model.skeletonTracing.createNewTree();
	    }
	    if (this.model.skeletonTracing.getActiveNode() == null) {
	      centered = true;
	    }
	    datasetConfig = this.model.get("datasetConfiguration");
	    this.model.skeletonTracing.addNode(position, rotation, constants.TYPE_USUAL, this.activeViewport, this.model.flycam.getIntegerZoomStep(), datasetConfig.get("fourBit") ? 4 : 8, datasetConfig.get("interpolation"));
	    if (centered) {
	      return this.centerPositionAnimated(this.model.skeletonTracing.getActiveNodePos());
	    }
	  };
	
	  SkeletonTracingPlaneController.prototype.centerPositionAnimated = function(position) {
	    var curGlobalPos, dimensionToSkip;
	    dimensionToSkip = dimensions.thirdDimensionForPlane(this.activeViewport);
	    curGlobalPos = this.flycam.getPosition();
	    return (new TWEEN.Tween({
	      globalPosX: curGlobalPos[0],
	      globalPosY: curGlobalPos[1],
	      globalPosZ: curGlobalPos[2],
	      flycam: this.flycam,
	      dimensionToSkip: dimensionToSkip
	    })).to({
	      globalPosX: position[0],
	      globalPosY: position[1],
	      globalPosZ: position[2]
	    }, 200).onUpdate(function() {
	      position = [this.globalPosX, this.globalPosY, this.globalPosZ];
	      position[this.dimensionToSkip] = null;
	      return this.flycam.setPosition(position);
	    }).start();
	  };
	
	  return SkeletonTracingPlaneController;
	
	})(PlaneController);
	
	module.exports = SkeletonTracingPlaneController;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var Constants, PlaneController, VolumeTracingController, VolumeTracingPlaneController, _,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(2);
	
	Constants = __webpack_require__(61);
	
	PlaneController = __webpack_require__(263);
	
	VolumeTracingController = __webpack_require__(310);
	
	VolumeTracingPlaneController = (function(superClass) {
	  extend(VolumeTracingPlaneController, superClass);
	
	  function VolumeTracingPlaneController(model, view, sceneController, volumeTracingController) {
	    this.model = model;
	    this.view = view;
	    this.sceneController = sceneController;
	    this.volumeTracingController = volumeTracingController;
	    this.simulateTracing = bind(this.simulateTracing, this);
	    VolumeTracingPlaneController.__super__.constructor.call(this, this.model, this.view, this.sceneController);
	    this.listenTo(this.model.flycam, "positionChanged", (function(_this) {
	      return function() {
	        return _this.render3dCell(_this.model.volumeTracing.getActiveCellId());
	      };
	    })(this));
	    this.listenTo(this.model.flycam, "zoomStepChanged", (function(_this) {
	      return function() {
	        return _this.render3dCell(_this.model.volumeTracing.getActiveCellId());
	      };
	    })(this));
	    this.listenTo(this.model.user, "isosurfaceDisplayChanged", function() {
	      return this.render3dCell(this.model.volumeTracing.getActiveCellId());
	    });
	    this.listenTo(this.model.user, "isosurfaceBBsizeChanged", function() {
	      return this.render3dCell(this.model.volumeTracing.getActiveCellId());
	    });
	    this.listenTo(this.model.user, "isosurfaceResolutionChanged", function() {
	      return this.render3dCell(this.model.volumeTracing.getActiveCellId());
	    });
	    this.listenTo(this.model.volumeTracing, "newActiveCell", function(id) {
	      id = this.model.volumeTracing.getActiveCellId();
	      if (id > 0) {
	        return this.render3dCell(id);
	      }
	    });
	  }
	
	  VolumeTracingPlaneController.prototype.simulateTracing = function() {
	    var controls, pos;
	    this.model.volumeTracing.setMode(Constants.VOLUME_MODE_TRACE);
	    controls = this.getPlaneMouseControls();
	    pos = function(x, y) {
	      return {
	        x: x,
	        y: y
	      };
	    };
	    controls.leftMouseDown(pos(100, 100), 0, {});
	    return _.defer((function(_this) {
	      return function() {
	        controls.leftDownMove(null, pos(200, 100));
	        return _.defer(function() {
	          controls.leftDownMove(null, pos(200, 200));
	          return _.defer(function() {
	            controls.leftDownMove(null, pos(100, 200));
	            return _.defer(function() {
	              controls.leftDownMove(null, pos(100, 100));
	              controls.leftMouseUp();
	              return _.defer(function() {
	                pos = _this.model.flycam.getPosition();
	                pos[2]++;
	                _this.model.flycam.setPosition(pos);
	                return _.defer(_this.simulateTracing);
	              });
	            });
	          });
	        });
	      };
	    })(this));
	  };
	
	  VolumeTracingPlaneController.prototype.getPlaneMouseControls = function(planeId) {
	    return _.extend(VolumeTracingPlaneController.__super__.getPlaneMouseControls.call(this, planeId), {
	      leftDownMove: (function(_this) {
	        return function(delta, pos, plane, event) {
	          if (_this.model.volumeTracing.mode === Constants.VOLUME_MODE_MOVE) {
	            return _this.move([delta.x * _this.model.user.getMouseInversionX() / _this.planeView.scaleFactor, delta.y * _this.model.user.getMouseInversionY() / _this.planeView.scaleFactor, 0]);
	          } else {
	            return _this.model.volumeTracing.addToLayer(_this.calculateGlobalPos(pos));
	          }
	        };
	      })(this),
	      leftMouseDown: (function(_this) {
	        return function(pos, plane, event) {
	          if (event.shiftKey) {
	            _this.volumeTracingController.enterDeleteMode();
	          }
	          _this.model.volumeTracing.startEditing(plane);
	          return _this.adjustSegmentationOpacity();
	        };
	      })(this),
	      leftMouseUp: (function(_this) {
	        return function() {
	          _this.model.volumeTracing.finishLayer();
	          return _this.volumeTracingController.restoreAfterDeleteMode();
	        };
	      })(this),
	      rightDownMove: (function(_this) {
	        return function(delta, pos, plane, event) {
	          return _this.model.volumeTracing.addToLayer(_this.calculateGlobalPos(pos));
	        };
	      })(this),
	      rightMouseDown: (function(_this) {
	        return function(pos, plane, event) {
	          _this.volumeTracingController.enterDeleteMode();
	          _this.model.volumeTracing.startEditing(plane);
	          return _this.adjustSegmentationOpacity();
	        };
	      })(this),
	      rightMouseUp: (function(_this) {
	        return function() {
	          _this.model.volumeTracing.finishLayer();
	          return _this.volumeTracingController.restoreAfterDeleteMode();
	        };
	      })(this),
	      leftClick: (function(_this) {
	        return function(pos, plane, event) {
	          var cellId;
	          cellId = _this.model.getSegmentationBinary().cube.getDataValue(_this.calculateGlobalPos(pos));
	          return _this.volumeTracingController.handleCellSelection(cellId);
	        };
	      })(this)
	    });
	  };
	
	  VolumeTracingPlaneController.prototype.adjustSegmentationOpacity = function() {
	    if (this.model.user.get("segmentationOpacity") < 10) {
	      return this.model.user.set("segmentationOpacity", 50);
	    }
	  };
	
	  VolumeTracingPlaneController.prototype.getKeyboardControls = function() {
	    return _.extend(VolumeTracingPlaneController.__super__.getKeyboardControls.call(this), {
	      "c": (function(_this) {
	        return function() {
	          return _this.model.volumeTracing.createCell();
	        };
	      })(this)
	    });
	  };
	
	  VolumeTracingPlaneController.prototype.render3dCell = function(id) {
	    var bb, res;
	    if (!this.model.user.get("isosurfaceDisplay")) {
	      return this.sceneController.removeShapes();
	    } else {
	      bb = this.model.flycam.getViewportBoundingBox();
	      res = this.model.user.get("isosurfaceResolution");
	      return this.sceneController.showShapes(this.scaleIsosurfaceBB(bb), res, id);
	    }
	  };
	
	  VolumeTracingPlaneController.prototype.scaleIsosurfaceBB = function(bb) {
	    var diff, factor, i, j, width;
	    factor = this.model.user.get("isosurfaceBBsize");
	    for (i = j = 0; j <= 2; i = ++j) {
	      width = bb.max[i] - bb.min[i];
	      diff = (factor - 1) * width / 2;
	      bb.min[i] -= diff;
	      bb.max[i] += diff;
	    }
	    return bb;
	  };
	
	  return VolumeTracingPlaneController;
	
	})(PlaneController);
	
	module.exports = VolumeTracingPlaneController;


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var ArbitraryController, Constants, Input, MinimalSkeletonTracingArbitraryController, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;
	
	app = __webpack_require__(48);
	
	Input = __webpack_require__(233);
	
	ArbitraryController = __webpack_require__(247);
	
	Constants = __webpack_require__(61);
	
	MinimalSkeletonTracingArbitraryController = (function(superClass) {
	  extend(MinimalSkeletonTracingArbitraryController, superClass);
	
	  function MinimalSkeletonTracingArbitraryController() {
	    var args;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    MinimalSkeletonTracingArbitraryController.__super__.constructor.apply(this, args);
	    this.setRecord(true);
	  }
	
	  MinimalSkeletonTracingArbitraryController.prototype.initKeyboard = function() {
	    var getVoxelOffset;
	    getVoxelOffset = (function(_this) {
	      return function(timeFactor) {
	        return _this.model.user.get("moveValue3d") * timeFactor / app.scaleInfo.baseVoxel / Constants.FPS;
	      };
	    })(this);
	    this.input.keyboard = new Input.Keyboard({
	      "space": (function(_this) {
	        return function(timeFactor) {
	          _this.cam.move([0, 0, getVoxelOffset(timeFactor)]);
	          return _this.moved();
	        };
	      })(this),
	      "ctrl + space": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.move([0, 0, -getVoxelOffset(timeFactor)]);
	        };
	      })(this),
	      "i": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.zoomIn();
	        };
	      })(this),
	      "o": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.zoomOut();
	        };
	      })(this),
	      "h": (function(_this) {
	        return function(timeFactor) {
	          return _this.changeMoveValue(25);
	        };
	      })(this),
	      "g": (function(_this) {
	        return function(timeFactor) {
	          return _this.changeMoveValue(-25);
	        };
	      })(this),
	      "left": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.yaw(_this.model.user.get("rotateValue") * timeFactor, _this.mode === Constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "right": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.yaw(-_this.model.user.get("rotateValue") * timeFactor, _this.mode === Constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "up": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.pitch(-_this.model.user.get("rotateValue") * timeFactor, _this.mode === Constants.MODE_ARBITRARY);
	        };
	      })(this),
	      "down": (function(_this) {
	        return function(timeFactor) {
	          return _this.cam.pitch(_this.model.user.get("rotateValue") * timeFactor, _this.mode === Constants.MODE_ARBITRARY);
	        };
	      })(this)
	    });
	    this.input.keyboardNoLoop = new Input.KeyboardNoLoop({
	      "y": (function(_this) {
	        return function() {
	          return _this.centerActiveNode();
	        };
	      })(this)
	    });
	    return this.input.keyboardOnce = new Input.Keyboard({
	      "shift + space": (function(_this) {
	        return function() {
	          _this.model.skeletonTracing.deleteActiveNode();
	          return _this.centerActiveNode();
	        };
	      })(this)
	    }, -1);
	  };
	
	  return MinimalSkeletonTracingArbitraryController;
	
	})(ArbitraryController);
	
	module.exports = MinimalSkeletonTracingArbitraryController;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, ContourGeometry, Cube, Dimensions, Plane, PolygonFactory, SceneController, Skeleton, THREE, VolumeGeometry, app, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	Plane = __webpack_require__(316);
	
	Skeleton = __webpack_require__(318);
	
	Cube = __webpack_require__(322);
	
	ContourGeometry = __webpack_require__(323);
	
	VolumeGeometry = __webpack_require__(324);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	PolygonFactory = __webpack_require__(325);
	
	THREE = __webpack_require__(245);
	
	SceneController = (function() {
	  SceneController.prototype.CUBE_COLOR = 0x999999;
	
	  function SceneController(upperBoundary, flycam, model1) {
	    this.upperBoundary = upperBoundary;
	    this.flycam = flycam;
	    this.model = model1;
	    this.getMeshes = bind(this.getMeshes, this);
	    this.setDisplayPlanes = bind(this.setDisplayPlanes, this);
	    this.update = bind(this.update, this);
	    this.updateSceneForCam = bind(this.updateSceneForCam, this);
	    _.extend(this, Backbone.Events);
	    this.current = 0;
	    this.displayPlane = [true, true, true];
	    this.planeShift = [0, 0, 0];
	    this.pingBinary = true;
	    this.pingBinarySeg = true;
	    this.volumeMeshes = [];
	    this.createMeshes();
	    this.bindToEvents();
	  }
	
	  SceneController.prototype.createMeshes = function() {
	    var i, j, len, ref;
	    this.cube = new Cube(this.model, {
	      max: this.upperBoundary,
	      color: this.CUBE_COLOR,
	      showCrossSections: true
	    });
	    this.bb = new Cube(this.model, {
	      max: [0, 0, 0],
	      color: 0xffaa00,
	      showCrossSections: true
	    });
	    if (this.model.boundingBox != null) {
	      this.bb2 = new Cube(this.model, {
	        min: this.model.boundingBox.min,
	        max: _.map(this.model.boundingBox.max, function(e) {
	          return e + 1;
	        }),
	        color: 0x00ff00,
	        showCrossSections: true
	      });
	    }
	    if (this.model.volumeTracing != null) {
	      this.contour = new ContourGeometry(this.model.volumeTracing, this.model.flycam);
	    }
	    if (this.model.skeletonTracing != null) {
	      this.skeleton = new Skeleton(this.model);
	    }
	    this.planes = new Array(3);
	    ref = [constants.PLANE_XY, constants.PLANE_YZ, constants.PLANE_XZ];
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      this.planes[i] = new Plane(constants.PLANE_WIDTH, constants.TEXTURE_WIDTH, this.flycam, i, this.model);
	    }
	    this.planes[constants.PLANE_XY].setRotation(new THREE.Euler(Math.PI, 0, 0));
	    this.planes[constants.PLANE_YZ].setRotation(new THREE.Euler(Math.PI, 1 / 2 * Math.PI, 0));
	    return this.planes[constants.PLANE_XZ].setRotation(new THREE.Euler(-1 / 2 * Math.PI, 0, 0));
	  };
	
	  SceneController.prototype.removeShapes = function() {
	    return this.trigger("removeGeometries", this.volumeMeshes);
	  };
	
	  SceneController.prototype.showShapes = function(bb, resolution, id) {
	    if (this.model.getSegmentationBinary() == null) {
	      return;
	    }
	    if (this.polygonFactory != null) {
	      this.polygonFactory.cancel();
	    }
	    this.polygonFactory = new PolygonFactory(this.model.getSegmentationBinary().cube, resolution, bb.min, bb.max, id);
	    return this.polygonFactory.getTriangles().then((function(_this) {
	      return function(triangles) {
	        var mappedId, volume;
	        _this.removeShapes();
	        _this.volumeMeshes = [];
	        for (id in triangles) {
	          mappedId = _this.model.getSegmentationBinary().cube.mapId(parseInt(id));
	          volume = new VolumeGeometry(triangles[id], mappedId);
	          _this.volumeMeshes = _this.volumeMeshes.concat(volume.getMeshes());
	        }
	        _this.trigger("newGeometries", _this.volumeMeshes);
	        app.vent.trigger("rerender");
	        return _this.polygonFactory = null;
	      };
	    })(this));
	  };
	
	  SceneController.prototype.updateSceneForCam = function(id) {
	    var i, ind, j, k, l, len, len1, len2, len3, m, mesh, pos, ref, ref1, ref2, ref3, ref4, ref5, results, results1;
	    this.cube.updateForCam(id);
	    this.bb.updateForCam(id);
	    if ((ref = this.bb2) != null) {
	      ref.updateForCam(id);
	    }
	    if ((ref1 = this.skeleton) != null) {
	      ref1.updateForCam(id);
	    }
	    if (indexOf.call(constants.ALL_PLANES, id) >= 0) {
	      ref2 = this.volumeMeshes;
	      for (j = 0, len = ref2.length; j < len; j++) {
	        mesh = ref2[j];
	        mesh.visible = false;
	      }
	      ref3 = constants.ALL_PLANES;
	      results = [];
	      for (k = 0, len1 = ref3.length; k < len1; k++) {
	        i = ref3[k];
	        if (i === id) {
	          this.planes[i].setOriginalCrosshairColor();
	          this.planes[i].setVisible(true);
	          pos = this.flycam.getPosition().slice();
	          ind = Dimensions.getIndices(i);
	          pos[ind[2]] += i === constants.PLANE_XY ? this.planeShift[ind[2]] : -this.planeShift[ind[2]];
	          results.push(this.planes[i].setPosition((function(func, args, ctor) {
	            ctor.prototype = func.prototype;
	            var child = new ctor, result = func.apply(child, args);
	            return Object(result) === result ? result : child;
	          })(THREE.Vector3, pos, function(){})));
	        } else {
	          results.push(this.planes[i].setVisible(false));
	        }
	      }
	      return results;
	    } else {
	      ref4 = this.volumeMeshes;
	      for (l = 0, len2 = ref4.length; l < len2; l++) {
	        mesh = ref4[l];
	        mesh.visible = true;
	      }
	      ref5 = constants.ALL_PLANES;
	      results1 = [];
	      for (m = 0, len3 = ref5.length; m < len3; m++) {
	        i = ref5[m];
	        pos = this.flycam.getPosition();
	        this.planes[i].setPosition(new THREE.Vector3(pos[0], pos[1], pos[2]));
	        this.planes[i].setGrayCrosshairColor();
	        this.planes[i].setVisible(true);
	        results1.push(this.planes[i].plane.visible = this.displayPlane[i]);
	      }
	      return results1;
	    }
	  };
	
	  SceneController.prototype.update = function() {
	    var gPos, globalPosVec, i, j, len, planeScale, ref, results;
	    gPos = this.flycam.getPosition();
	    globalPosVec = (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Vector3, gPos, function(){});
	    planeScale = this.flycam.getPlaneScalingFactor();
	    ref = constants.ALL_PLANES;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      this.planes[i].updateTexture();
	      this.planes[i].setPosition(globalPosVec);
	      results.push(this.planes[i].setScale(planeScale));
	    }
	    return results;
	  };
	
	  SceneController.prototype.setTextRotation = function(rotVec) {};
	
	  SceneController.prototype.setDisplayCrosshair = function(value) {
	    var j, len, plane, ref;
	    ref = this.planes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      plane = ref[j];
	      plane.setDisplayCrosshair(value);
	    }
	    return app.vent.trigger("rerender");
	  };
	
	  SceneController.prototype.setClippingDistance = function(value) {
	    var i, j, len, ref;
	    ref = constants.ALL_PLANES;
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      this.planeShift[i] = value * app.scaleInfo.voxelPerNM[i];
	    }
	    return app.vent.trigger("rerender");
	  };
	
	  SceneController.prototype.setInterpolation = function(value) {
	    var j, len, plane, ref;
	    ref = this.planes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      plane = ref[j];
	      plane.setLinearInterpolationEnabled(value);
	    }
	    return app.vent.trigger("rerender");
	  };
	
	  SceneController.prototype.setDisplayPlanes = function(value) {
	    var i, j;
	    for (i = j = 0; j <= 2; i = ++j) {
	      this.displayPlane[i] = value;
	    }
	    return app.vent.trigger("rerender");
	  };
	
	  SceneController.prototype.getMeshes = function() {
	    var geometry, j, k, len, len1, plane, ref, ref1, result;
	    result = [];
	    ref = this.planes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      plane = ref[j];
	      result = result.concat(plane.getMeshes());
	    }
	    ref1 = [this.skeleton, this.contour, this.cube, this.bb, this.bb2];
	    for (k = 0, len1 = ref1.length; k < len1; k++) {
	      geometry = ref1[k];
	      if (geometry != null) {
	        result = result.concat(geometry.getMeshes());
	      }
	    }
	    return result;
	  };
	
	  SceneController.prototype.setBoundingBox = function(bbArray) {
	    return this.bb.setCorners([bbArray[0], bbArray[1], bbArray[2]], [bbArray[3], bbArray[4], bbArray[5]]);
	  };
	
	  SceneController.prototype.setSegmentationAlpha = function(alpha) {
	    var j, len, plane, ref;
	    ref = this.planes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      plane = ref[j];
	      plane.setSegmentationAlpha(alpha);
	    }
	    return this.pingBinarySeg = alpha !== 0;
	  };
	
	  SceneController.prototype.pingDataLayer = function(dataLayerName) {
	    if (this.model.binary[dataLayerName].category === "color") {
	      return this.pingBinary;
	    }
	    if (this.model.binary[dataLayerName].category === "segmentation") {
	      return this.pingBinarySeg;
	    }
	    return false;
	  };
	
	  SceneController.prototype.stop = function() {
	    var j, len, plane, ref, ref1, ref2, ref3;
	    ref = this.planes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      plane = ref[j];
	      plane.setVisible(false);
	    }
	    this.cube.setVisibility(false);
	    this.bb.setVisibility(false);
	    if ((ref1 = this.bb2) != null) {
	      ref1.setVisibility(false);
	    }
	    if ((ref2 = this.skeleton) != null) {
	      ref2.restoreVisibility();
	    }
	    return (ref3 = this.skeleton) != null ? ref3.setSizeAttenuation(true) : void 0;
	  };
	
	  SceneController.prototype.start = function() {
	    var j, len, plane, ref, ref1, ref2;
	    ref = this.planes;
	    for (j = 0, len = ref.length; j < len; j++) {
	      plane = ref[j];
	      plane.setVisible(true);
	    }
	    this.cube.setVisibility(true);
	    this.bb.setVisibility(true);
	    if ((ref1 = this.bb2) != null) {
	      ref1.setVisibility(true);
	    }
	    return (ref2 = this.skeleton) != null ? ref2.setSizeAttenuation(false) : void 0;
	  };
	
	  SceneController.prototype.bindToEvents = function() {
	    var user;
	    user = this.model.user;
	    this.listenTo(this.model, "newBoundingBox", function(bb) {
	      return this.setBoundingBox(bb);
	    });
	    this.listenTo(user, "change:segmentationOpacity", function(model, opacity) {
	      return this.setSegmentationAlpha(opacity);
	    });
	    this.listenTo(user, "change:clippingDistance", function(model, value) {
	      return this.setClippingDistance(value);
	    });
	    this.listenTo(user, "change:displayCrosshair", function(model, value) {
	      return this.setDisplayCrosshair(value);
	    });
	    this.listenTo(this.model.datasetConfiguration, "change:interpolation", function(model, value) {
	      return this.setInterpolation(value);
	    });
	    return this.listenTo(user, "change:tdViewDisplayPlanes", function(model, value) {
	      return this.setDisplayPlanes(value);
	    });
	  };
	
	  return SceneController;
	
	})();
	
	module.exports = SceneController;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var Dimensions, Model, Plane, PlaneMaterialFactory, THREE, View, app, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	app = __webpack_require__(48);
	
	Model = __webpack_require__(266);
	
	View = __webpack_require__(306);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	THREE = __webpack_require__(245);
	
	PlaneMaterialFactory = __webpack_require__(317);
	
	Plane = (function() {
	  Plane.prototype.CROSSHAIR_COLORS = [[0x0000ff, 0x00ff00], [0xff0000, 0x00ff00], [0x0000ff, 0xff0000]];
	
	  Plane.prototype.GRAY_CH_COLOR = 0x222222;
	
	  function Plane(planeWidth, textureWidth, flycam, planeID, model) {
	    this.setLinearInterpolationEnabled = bind(this.setLinearInterpolationEnabled, this);
	    this.getMeshes = bind(this.getMeshes, this);
	    this.setVisible = bind(this.setVisible, this);
	    this.setPosition = bind(this.setPosition, this);
	    this.setRotation = bind(this.setRotation, this);
	    this.setScale = bind(this.setScale, this);
	    this.updateTexture = bind(this.updateTexture, this);
	    this.setGrayCrosshairColor = bind(this.setGrayCrosshairColor, this);
	    this.setOriginalCrosshairColor = bind(this.setOriginalCrosshairColor, this);
	    this.setDisplayCrosshair = bind(this.setDisplayCrosshair, this);
	    var scaleArray;
	    this.flycam = flycam;
	    this.planeID = planeID;
	    this.model = model;
	    this.planeWidth = planeWidth;
	    this.textureWidth = textureWidth;
	    this.displayCosshair = true;
	    scaleArray = Dimensions.transDim(app.scaleInfo.baseVoxelFactors, this.planeID);
	    this.scaleVector = (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(THREE.Vector3, scaleArray, function(){});
	    this.createMeshes(planeWidth, textureWidth);
	  }
	
	  Plane.prototype.createMeshes = function(pWidth, tWidth) {
	    var TDViewBordersGeo, crosshairGeometries, i, j, planeGeo, textureMaterial;
	    planeGeo = new THREE.PlaneGeometry(pWidth, pWidth, 1, 1);
	    textureMaterial = new PlaneMaterialFactory(this.model, tWidth).getMaterial();
	    this.plane = new THREE.Mesh(planeGeo, textureMaterial);
	    crosshairGeometries = new Array(2);
	    this.crosshair = new Array(2);
	    for (i = j = 0; j <= 1; i = ++j) {
	      crosshairGeometries[i] = new THREE.Geometry();
	      crosshairGeometries[i].vertices.push(new THREE.Vector3(-pWidth / 2 * i, -pWidth / 2 * (1 - i), 0));
	      crosshairGeometries[i].vertices.push(new THREE.Vector3(-25 * i, -25 * (1 - i), 0));
	      crosshairGeometries[i].vertices.push(new THREE.Vector3(25 * i, 25 * (1 - i), 0));
	      crosshairGeometries[i].vertices.push(new THREE.Vector3(pWidth / 2 * i, pWidth / 2 * (1 - i), 0));
	      this.crosshair[i] = new THREE.Line(crosshairGeometries[i], new THREE.LineBasicMaterial({
	        color: this.CROSSHAIR_COLORS[this.planeID][i],
	        linewidth: 1
	      }), THREE.LinePieces);
	    }
	    TDViewBordersGeo = new THREE.Geometry();
	    TDViewBordersGeo.vertices.push(new THREE.Vector3(-pWidth / 2, -pWidth / 2, 0));
	    TDViewBordersGeo.vertices.push(new THREE.Vector3(-pWidth / 2, pWidth / 2, 0));
	    TDViewBordersGeo.vertices.push(new THREE.Vector3(pWidth / 2, pWidth / 2, 0));
	    TDViewBordersGeo.vertices.push(new THREE.Vector3(pWidth / 2, -pWidth / 2, 0));
	    TDViewBordersGeo.vertices.push(new THREE.Vector3(-pWidth / 2, -pWidth / 2, 0));
	    return this.TDViewBorders = new THREE.Line(TDViewBordersGeo, new THREE.LineBasicMaterial({
	      color: constants.PLANE_COLORS[this.planeID],
	      linewidth: 1
	    }));
	  };
	
	  Plane.prototype.setDisplayCrosshair = function(value) {
	    return this.displayCosshair = value;
	  };
	
	  Plane.prototype.setOriginalCrosshairColor = function() {
	    var i, j, results;
	    results = [];
	    for (i = j = 0; j <= 1; i = ++j) {
	      results.push(this.crosshair[i].material = new THREE.LineBasicMaterial({
	        color: this.CROSSHAIR_COLORS[this.planeID][i],
	        linewidth: 1
	      }));
	    }
	    return results;
	  };
	
	  Plane.prototype.setGrayCrosshairColor = function() {
	    var i, j, results;
	    results = [];
	    for (i = j = 0; j <= 1; i = ++j) {
	      results.push(this.crosshair[i].material = new THREE.LineBasicMaterial({
	        color: this.GRAY_CH_COLOR,
	        linewidth: 1
	      }));
	    }
	    return results;
	  };
	
	  Plane.prototype.updateTexture = function() {
	    var area, binary, dataBuffer, globalPos, name, ref, tPos;
	    globalPos = this.flycam.getPosition();
	    area = this.flycam.getArea(this.planeID);
	    tPos = this.flycam.getTexturePosition(this.planeID).slice();
	    if (this.model != null) {
	      ref = this.model.binary;
	      for (name in ref) {
	        binary = ref[name];
	        dataBuffer = binary.planes[this.planeID].get({
	          position: this.flycam.getTexturePosition(this.planeID),
	          zoomStep: this.flycam.getIntegerZoomStep(),
	          area: this.flycam.getArea(this.planeID)
	        });
	        if (dataBuffer) {
	          this.plane.material.setData(name, dataBuffer);
	          app.vent.trigger("rerender");
	        }
	      }
	    }
	    return this.plane.material.setScaleParams({
	      repeat: {
	        x: (area[2] - area[0]) / this.textureWidth,
	        y: (area[3] - area[1]) / this.textureWidth
	      },
	      offset: {
	        x: area[0] / this.textureWidth,
	        y: 1 - area[3] / this.textureWidth
	      }
	    });
	  };
	
	  Plane.prototype.setScale = function(factor) {
	    var scaleVec;
	    scaleVec = new THREE.Vector3().multiplyVectors(new THREE.Vector3(factor, factor, factor), this.scaleVector);
	    return this.plane.scale = this.TDViewBorders.scale = this.crosshair[0].scale = this.crosshair[1].scale = scaleVec;
	  };
	
	  Plane.prototype.setRotation = function(rotVec) {
	    var j, len, mesh, ref, results;
	    ref = [this.plane, this.TDViewBorders, this.crosshair[0], this.crosshair[1]];
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      mesh = ref[j];
	      results.push(mesh.setRotationFromEuler(rotVec));
	    }
	    return results;
	  };
	
	  Plane.prototype.setPosition = function(posVec) {
	    var offset;
	    this.TDViewBorders.position = this.crosshair[0].position = this.crosshair[1].position = posVec;
	    offset = new THREE.Vector3(0, 0, 0);
	    if (this.planeID === constants.PLANE_XY) {
	      offset.z = 1;
	    } else if (this.planeID === constants.PLANE_YZ) {
	      offset.x = -1;
	    } else if (this.planeID === constants.PLANE_XZ) {
	      offset.y = -1;
	    }
	    return this.plane.position = offset.addVectors(posVec, offset);
	  };
	
	  Plane.prototype.setVisible = function(visible) {
	    this.plane.visible = this.TDViewBorders.visible = visible;
	    return this.crosshair[0].visible = this.crosshair[1].visible = visible && this.displayCosshair;
	  };
	
	  Plane.prototype.setSegmentationAlpha = function(alpha) {
	    this.plane.material.setSegmentationAlpha(alpha);
	    return app.vent.trigger("rerender");
	  };
	
	  Plane.prototype.getMeshes = function() {
	    return [this.plane, this.TDViewBorders, this.crosshair[0], this.crosshair[1]];
	  };
	
	  Plane.prototype.setLinearInterpolationEnabled = function(enabled) {
	    return this.plane.material.setColorInterpolation(enabled ? THREE.LinearFilter : THREE.NearestFilter);
	  };
	
	  return Plane;
	
	})();
	
	module.exports = Plane;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var AbstractPlaneMaterialFactory, PlaneMaterialFactory, THREE,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(245);
	
	AbstractPlaneMaterialFactory = __webpack_require__(251);
	
	PlaneMaterialFactory = (function(superClass) {
	  extend(PlaneMaterialFactory, superClass);
	
	  function PlaneMaterialFactory() {
	    return PlaneMaterialFactory.__super__.constructor.apply(this, arguments);
	  }
	
	  PlaneMaterialFactory.prototype.setupAttributesAndUniforms = function() {
	    PlaneMaterialFactory.__super__.setupAttributesAndUniforms.call(this);
	    return this.uniforms = _.extend(this.uniforms, {
	      offset: {
	        type: "v2",
	        value: new THREE.Vector2(0, 0)
	      },
	      repeat: {
	        type: "v2",
	        value: new THREE.Vector2(1, 1)
	      },
	      alpha: {
	        type: "f",
	        value: 0
	      }
	    });
	  };
	
	  PlaneMaterialFactory.prototype.convertColor = function(color) {
	    return _.map(color, function(e) {
	      return e / 255;
	    });
	  };
	
	  PlaneMaterialFactory.prototype.createTextures = function() {
	    var binary, bytes, color, name, ref, ref1, results, shaderName, texture;
	    this.textures = {};
	    ref = this.model.binary;
	    for (name in ref) {
	      binary = ref[name];
	      bytes = binary.targetBitDepth >> 3;
	      shaderName = this.sanitizeName(name);
	      this.textures[shaderName] = this.createDataTexture(this.tWidth, bytes);
	      this.textures[shaderName].binaryCategory = binary.category;
	      this.textures[shaderName].binaryName = binary.name;
	    }
	    ref1 = this.textures;
	    results = [];
	    for (shaderName in ref1) {
	      texture = ref1[shaderName];
	      this.uniforms[shaderName + "_texture"] = {
	        type: "t",
	        value: texture
	      };
	      if (texture.binaryCategory !== "segmentation") {
	        color = this.convertColor(this.model.datasetConfiguration.get("layers." + texture.binaryName + ".color"));
	        this.uniforms[shaderName + "_weight"] = {
	          type: "f",
	          value: 1
	        };
	        results.push(this.uniforms[shaderName + "_color"] = {
	          type: "v3",
	          value: (function(func, args, ctor) {
	            ctor.prototype = func.prototype;
	            var child = new ctor, result = func.apply(child, args);
	            return Object(result) === result ? result : child;
	          })(THREE.Vector3, color, function(){})
	        });
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  PlaneMaterialFactory.prototype.makeMaterial = function(options) {
	    PlaneMaterialFactory.__super__.makeMaterial.call(this, options);
	    this.material.setColorInterpolation = (function(_this) {
	      return function(interpolation) {
	        var name, ref, results, texture;
	        ref = _this.textures;
	        results = [];
	        for (name in ref) {
	          texture = ref[name];
	          if (texture.binaryCategory === "color") {
	            texture.magFilter = interpolation;
	            results.push(texture.needsUpdate = true);
	          } else {
	            results.push(void 0);
	          }
	        }
	        return results;
	      };
	    })(this);
	    this.material.setScaleParams = (function(_this) {
	      return function(arg) {
	        var offset, repeat;
	        offset = arg.offset, repeat = arg.repeat;
	        _this.uniforms.offset.value.set(offset.x, offset.y);
	        return _this.uniforms.repeat.value.set(repeat.x, repeat.y);
	      };
	    })(this);
	    this.material.setSegmentationAlpha = (function(_this) {
	      return function(alpha) {
	        return _this.uniforms.alpha.value = alpha / 100;
	      };
	    })(this);
	    return this.material.side = THREE.DoubleSide;
	  };
	
	  PlaneMaterialFactory.prototype.setupChangeListeners = function() {
	    PlaneMaterialFactory.__super__.setupChangeListeners.call(this);
	    return this.listenTo(this.model.datasetConfiguration, "change", function(model) {
	      var binaryName, changes, color, name, ref;
	      ref = model.changed.layers || {};
	      for (binaryName in ref) {
	        changes = ref[binaryName];
	        name = this.sanitizeName(binaryName);
	        if (changes.color != null) {
	          color = this.convertColor(changes.color);
	          this.uniforms[name + "_color"].value = (function(func, args, ctor) {
	            ctor.prototype = func.prototype;
	            var child = new ctor, result = func.apply(child, args);
	            return Object(result) === result ? result : child;
	          })(THREE.Vector3, color, function(){});
	        }
	      }
	      return app.vent.trigger("rerender");
	    });
	  };
	
	  PlaneMaterialFactory.prototype.getFragmentShader = function() {
	    var colorLayerNames, ref, segmentationBinary;
	    colorLayerNames = _.map(this.model.getColorBinaries(), (function(_this) {
	      return function(b) {
	        return _this.sanitizeName(b.name);
	      };
	    })(this));
	    segmentationBinary = this.model.getSegmentationBinary();
	    return _.template("<% _.each(layers, function(name) { %>\n  uniform sampler2D <%= name %>_texture;\n  uniform float <%= name %>_brightness;\n  uniform float <%= name %>_contrast;\n  uniform vec3 <%= name %>_color;\n  uniform float <%= name %>_weight;\n<% }) %>\n<% if (hasSegmentation) { %>\n  uniform sampler2D <%= segmentationName %>_texture;\n<% } %>\nuniform vec2 offset, repeat;\nuniform float alpha;\nvarying vec2 vUv;\n/* Inspired from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl */\nvec3 hsv_to_rgb(vec4 HSV)\n{\n  vec4 K;\n  vec3 p;\n  K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  p = abs(fract(HSV.xxx + K.xyz) * 6.0 - K.www);\n  return HSV.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), HSV.y);\n}\nvoid main() {\n  float golden_ratio = 0.618033988749895;\n  float color_value  = 0.0;\n  <% if (hasSegmentation) { %>\n    vec4 volume_color = texture2D(<%= segmentationName %>_texture, vUv * repeat + offset);\n    float id = (volume_color.r * 255.0);\n  <% } else { %>\n    float id = 0.0;\n  <% } %>\n  /* Get Color Value(s) */\n  <% if (isRgb) { %>\n    vec3 data_color = texture2D( <%= layers[0] %>_texture, vUv * repeat + offset).xyz;\n    data_color = (data_color + <%= layers[0] %>_brightness - 0.5) * <%= layers[0] %>_contrast + 0.5;\n  <% } else { %>\n    vec3 data_color = vec3(0.0, 0.0, 0.0);\n    <% _.each(layers, function(name){ %>\n      /* Get grayscale value */\n      color_value = texture2D( <%= name %>_texture, vUv * repeat + offset).r;\n      /* Brightness / Contrast Transformation */\n      color_value = (color_value + <%= name %>_brightness - 0.5) * <%= name %>_contrast + 0.5;\n\n      /* Multiply with color and weight */\n      data_color += color_value * <%= name %>_weight * <%= name %>_color;\n    <% }) %> ;\n    data_color = clamp(data_color, 0.0, 1.0);\n  <% } %>\n  /* Color map (<= to fight rounding mistakes) */\n  if ( id > 0.1 ) {\n    vec4 HSV = vec4( mod( id * golden_ratio, 1.0), 1.0, 1.0, 1.0 );\n    gl_FragColor = vec4(mix( data_color, hsv_to_rgb(HSV), alpha ), 1.0);\n  } else {\n    gl_FragColor = vec4(data_color, 1.0);\n  }\n}")({
	      layers: colorLayerNames,
	      hasSegmentation: segmentationBinary != null,
	      segmentationName: this.sanitizeName(segmentationBinary != null ? segmentationBinary.name : void 0),
	      isRgb: ((ref = this.model.binary["color"]) != null ? ref.targetBitDepth : void 0) === 24
	    });
	  };
	
	  return PlaneMaterialFactory;
	
	})(AbstractPlaneMaterialFactory);
	
	module.exports = PlaneMaterialFactory;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, Dimensions, ErrorHandling, Model, Skeleton, Tree, app, constants,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	ErrorHandling = __webpack_require__(5);
	
	Model = __webpack_require__(266);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	Tree = __webpack_require__(319);
	
	Skeleton = (function() {
	  Skeleton.prototype.COLOR_ACTIVE = 0xff0000;
	
	  function Skeleton(model) {
	    this.model = model;
	    this.setWaypoint = bind(this.setWaypoint, this);
	    this.getMeshes = bind(this.getMeshes, this);
	    _.extend(this, Backbone.Events);
	    this.skeletonTracing = this.model.skeletonTracing;
	    this.treeGeometries = [];
	    this.isVisible = true;
	    this.showInactiveTrees = true;
	    this.reset();
	    this.listenTo(this.skeletonTracing, "newActiveNode", function(nodeId) {
	      this.setActiveNode();
	      return this.setInactiveTreeVisibility(this.showInactiveTrees);
	    });
	    this.listenTo(this.skeletonTracing, "newActiveNodeRadius", this.setActiveNodeRadius);
	    this.listenTo(this.skeletonTracing, "newTree", function(treeId, treeColor) {
	      this.createNewTree(treeId, treeColor);
	      return this.setInactiveTreeVisibility(this.showInactiveTrees);
	    });
	    this.listenTo(this.skeletonTracing, "deleteTree", this.deleteTree);
	    this.listenTo(this.skeletonTracing, "deleteActiveNode", this.deleteNode);
	    this.listenTo(this.skeletonTracing, "mergeTree", this.mergeTree);
	    this.listenTo(this.skeletonTracing, "newNode", this.setWaypoint);
	    this.listenTo(this.skeletonTracing, "setBranch", this.setBranch);
	    this.listenTo(this.skeletonTracing, "newTreeColor", this.updateTreeColor);
	    this.listenTo(this.skeletonTracing, "reloadTrees", this.loadSkeletonFromModel);
	    this.listenTo(this.model.user, "particleSizeChanged", this.setParticleSize);
	    this.listenTo(this.model.user, "overrideNodeRadiusChanged", (function(_this) {
	      return function(overrideNodeRadius) {
	        var i, len, ref, results, tree;
	        ref = _this.treeGeometries;
	        results = [];
	        for (i = 0, len = ref.length; i < len; i++) {
	          tree = ref[i];
	          results.push(tree.showRadius(!_this.model.user.get("overrideNodeRadius")));
	        }
	        return results;
	      };
	    })(this));
	  }
	
	  Skeleton.prototype.createNewTree = function(treeId, treeColor) {
	    var tree;
	    this.treeGeometries.push(tree = new Tree(treeId, treeColor, this.model));
	    this.setActiveNode();
	    return this.trigger("newGeometries", tree.getMeshes());
	  };
	
	  Skeleton.prototype.reset = function() {
	    var i, j, len, len1, ref, ref1, tree;
	    ref = this.treeGeometries;
	    for (i = 0, len = ref.length; i < len; i++) {
	      tree = ref[i];
	      this.trigger("removeGeometries", tree.getMeshes());
	      tree.dispose();
	    }
	    this.treeGeometries = [];
	    ref1 = this.skeletonTracing.getTrees();
	    for (j = 0, len1 = ref1.length; j < len1; j++) {
	      tree = ref1[j];
	      this.createNewTree(tree.treeId, tree.color);
	    }
	    return this.loadSkeletonFromModel();
	  };
	
	  Skeleton.prototype.loadSkeletonFromModel = function(trees) {
	    var branchpoint, i, j, len, len1, ref, tree, treeGeometry;
	    if (trees == null) {
	      trees = this.model.skeletonTracing.getTrees();
	    }
	    for (i = 0, len = trees.length; i < len; i++) {
	      tree = trees[i];
	      treeGeometry = this.getTreeGeometry(tree.treeId);
	      treeGeometry.clear();
	      treeGeometry.addNodes(tree.nodes);
	    }
	    ref = this.skeletonTracing.branchStack;
	    for (j = 0, len1 = ref.length; j < len1; j++) {
	      branchpoint = ref[j];
	      treeGeometry = this.getTreeGeometry(branchpoint.treeId);
	      treeGeometry.updateNodeColor(branchpoint.id, null, true);
	    }
	    this.setActiveNode();
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.setBranch = function(isBranchPoint, node) {
	    var treeGeometry;
	    treeGeometry = this.getTreeGeometry(node.treeId);
	    treeGeometry.updateNodeColor(node.id, null, isBranchPoint);
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.updateTreeColor = function(treeId) {
	    this.getTreeGeometry(treeId).updateTreeColor();
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.getMeshes = function() {
	    var i, len, meshes, ref, tree;
	    meshes = [];
	    ref = this.treeGeometries;
	    for (i = 0, len = ref.length; i < len; i++) {
	      tree = ref[i];
	      meshes = meshes.concat(tree.getMeshes());
	    }
	    return meshes;
	  };
	
	  Skeleton.prototype.setWaypoint = function(centered) {
	    var treeGeometry;
	    treeGeometry = this.getTreeGeometry(this.skeletonTracing.getTree().treeId);
	    treeGeometry.addNode(this.skeletonTracing.getActiveNode());
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.deleteNode = function(node, treeId) {
	    var treeGeometry;
	    ErrorHandling.assertEquals(node.neighbors.length, 1, "Node needs to have exactly 1 neighbor.");
	    treeGeometry = this.getTreeGeometry(treeId);
	    treeGeometry.deleteNode(node);
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.mergeTree = function(lastTreeID, lastNode, activeNode) {
	    var activeTree, lastTree;
	    lastTree = this.getTreeGeometry(lastTreeID);
	    activeTree = this.getTreeGeometry(this.skeletonTracing.getTree().treeId);
	    return activeTree.mergeTree(lastTree, lastNode, activeNode);
	  };
	
	  Skeleton.prototype.deleteTree = function(index) {
	    var treeGeometry;
	    treeGeometry = this.treeGeometries[index];
	    this.trigger("removeGeometries", treeGeometry.getMeshes());
	    treeGeometry.dispose();
	    this.treeGeometries.splice(index, 1);
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.setActiveNode = function() {
	    var activeNode, treeGeometry;
	    if (this.lastActiveNode != null) {
	      treeGeometry = this.getTreeGeometry(this.lastActiveNode.treeId);
	      if (treeGeometry != null) {
	        treeGeometry.updateNodeColor(this.lastActiveNode.id, false);
	      }
	    }
	    if ((activeNode = this.model.skeletonTracing.getActiveNode()) != null) {
	      treeGeometry = this.getTreeGeometry(activeNode.treeId);
	      if (treeGeometry != null) {
	        treeGeometry.updateNodeColor(activeNode.id, true);
	      }
	      if (treeGeometry != null) {
	        treeGeometry.startNodeHighlightAnimation(activeNode.id);
	      }
	    }
	    return this.lastActiveNode = activeNode;
	  };
	
	  Skeleton.prototype.setActiveNodeRadius = function() {
	    var activeNode, treeGeometry;
	    if ((activeNode = this.model.skeletonTracing.getActiveNode()) != null) {
	      treeGeometry = this.getTreeGeometry(activeNode.treeId);
	      if (treeGeometry != null) {
	        treeGeometry.updateNodeRadius(activeNode.id, activeNode.radius);
	      }
	      return app.vent.trigger("rerender");
	    }
	  };
	
	  Skeleton.prototype.getAllNodes = function() {
	    var tree;
	    return (function() {
	      var i, len, ref, results;
	      ref = this.treeGeometries;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        tree = ref[i];
	        results.push(tree.nodes);
	      }
	      return results;
	    }).call(this);
	  };
	
	  Skeleton.prototype.getTreeGeometry = function(treeId) {
	    var i, len, ref, tree;
	    if (!treeId) {
	      treeId = this.skeletonTracing.getTree().treeId;
	    }
	    ref = this.treeGeometries;
	    for (i = 0, len = ref.length; i < len; i++) {
	      tree = ref[i];
	      if (tree.id === treeId) {
	        return tree;
	      }
	    }
	    return null;
	  };
	
	  Skeleton.prototype.setVisibilityTemporary = function(isVisible) {
	    var i, len, mesh, ref;
	    ref = this.getMeshes();
	    for (i = 0, len = ref.length; i < len; i++) {
	      mesh = ref[i];
	      mesh.visible = isVisible && (mesh.isVisible != null ? mesh.isVisible : true);
	    }
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.setVisibility = function(isVisible1) {
	    this.isVisible = isVisible1;
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.restoreVisibility = function() {
	    return this.setVisibilityTemporary(this.isVisible);
	  };
	
	  Skeleton.prototype.toggleVisibility = function() {
	    return this.setVisibility(!this.isVisible);
	  };
	
	  Skeleton.prototype.updateForCam = function(id) {
	    var i, len, ref, tree;
	    ref = this.treeGeometries;
	    for (i = 0, len = ref.length; i < len; i++) {
	      tree = ref[i];
	      tree.showRadius(id !== constants.TDView && !this.model.user.get("overrideNodeRadius"));
	    }
	    if (indexOf.call(constants.ALL_PLANES, id) >= 0) {
	      return this.setVisibilityTemporary(this.isVisible);
	    } else {
	      return this.setVisibilityTemporary(true);
	    }
	  };
	
	  Skeleton.prototype.toggleInactiveTreeVisibility = function() {
	    this.showInactiveTrees = !this.showInactiveTrees;
	    return this.setInactiveTreeVisibility(this.showInactiveTrees);
	  };
	
	  Skeleton.prototype.setInactiveTreeVisibility = function(visible) {
	    var i, len, mesh, ref, treeGeometry;
	    ref = this.getMeshes();
	    for (i = 0, len = ref.length; i < len; i++) {
	      mesh = ref[i];
	      mesh.isVisible = visible;
	    }
	    treeGeometry = this.getTreeGeometry(this.skeletonTracing.getTree().treeId);
	    treeGeometry.edges.isVisible = true;
	    treeGeometry.nodes.isVisible = true;
	    return app.vent.trigger("rerender");
	  };
	
	  Skeleton.prototype.setSizeAttenuation = function(sizeAttenuation) {
	    var i, len, ref, results, tree;
	    ref = this.treeGeometries;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      tree = ref[i];
	      results.push(tree.setSizeAttenuation(sizeAttenuation));
	    }
	    return results;
	  };
	
	  return Skeleton;
	
	})();
	
	module.exports = Skeleton;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	var ColorConverter, ErrorHandling, ParticleMaterialFactory, ResizableBuffer, THREE, TWEEN, Tree, app;
	
	app = __webpack_require__(48);
	
	ResizableBuffer = __webpack_require__(320);
	
	ErrorHandling = __webpack_require__(5);
	
	THREE = __webpack_require__(245);
	
	TWEEN = __webpack_require__(248);
	
	ColorConverter = __webpack_require__(244);
	
	ParticleMaterialFactory = __webpack_require__(321);
	
	Tree = (function() {
	  function Tree(treeId, treeColor, model) {
	    var edgeGeometry, nodeGeometry;
	    this.model = model;
	    edgeGeometry = new THREE.BufferGeometry();
	    nodeGeometry = new THREE.BufferGeometry();
	    edgeGeometry.addAttribute('position', Float32Array, 0, 3);
	    nodeGeometry.addAttribute('position', Float32Array, 0, 3);
	    nodeGeometry.addAttribute('sizeNm', Float32Array, 0, 1);
	    nodeGeometry.addAttribute('nodeScaleFactor', Float32Array, 0, 1);
	    nodeGeometry.addAttribute('color', Float32Array, 0, 3);
	    this.nodeIDs = nodeGeometry.nodeIDs = new ResizableBuffer(1, 100, Int32Array);
	    edgeGeometry.dynamic = true;
	    nodeGeometry.dynamic = true;
	    this.edgesBuffer = edgeGeometry.attributes.position._rBuffer = new ResizableBuffer(6);
	    this.nodesBuffer = nodeGeometry.attributes.position._rBuffer = new ResizableBuffer(3);
	    this.sizesBuffer = nodeGeometry.attributes.sizeNm._rBuffer = new ResizableBuffer(1);
	    this.scalesBuffer = nodeGeometry.attributes.nodeScaleFactor._rBuffer = new ResizableBuffer(1);
	    this.nodesColorBuffer = nodeGeometry.attributes.color._rBuffer = new ResizableBuffer(3);
	    this.edges = new THREE.Line(edgeGeometry, new THREE.LineBasicMaterial({
	      color: this.darkenHex(treeColor),
	      linewidth: this.getLineWidth()
	    }), THREE.LinePieces);
	    this.particleMaterial = new ParticleMaterialFactory(this.model).getMaterial();
	    this.nodes = new THREE.ParticleSystem(nodeGeometry, this.particleMaterial);
	    this.id = treeId;
	  }
	
	  Tree.prototype.clear = function() {
	    this.nodesBuffer.clear();
	    this.edgesBuffer.clear();
	    this.sizesBuffer.clear();
	    this.scalesBuffer.clear();
	    this.nodeIDs.clear();
	    return this.updateNodesColors();
	  };
	
	  Tree.prototype.isEmpty = function() {
	    return this.nodesBuffer.getLength() === 0;
	  };
	
	  Tree.prototype.addNode = function(node) {
	    var k, len, neighbor, ref;
	    this.nodesBuffer.push(node.pos);
	    this.sizesBuffer.push([node.radius * 2]);
	    this.scalesBuffer.push([1.0]);
	    this.nodeIDs.push([node.id]);
	    this.nodesColorBuffer.push(this.getColor(node.id));
	    ref = node.neighbors;
	    for (k = 0, len = ref.length; k < len; k++) {
	      neighbor = ref[k];
	      if (neighbor.id < node.id) {
	        this.edgesBuffer.push(neighbor.pos.concat(node.pos));
	      }
	    }
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.addNodes = function(nodeList) {
	    var k, len, node, results;
	    results = [];
	    for (k = 0, len = nodeList.length; k < len; k++) {
	      node = nodeList[k];
	      results.push(this.addNode(node));
	    }
	    return results;
	  };
	
	  Tree.prototype.deleteNode = function(node) {
	    var edgeArray, edgesIndex, found, i, j, k, l, nodesIndex, ref, swapLast;
	    swapLast = (function(_this) {
	      return function(array, index) {
	        var i, k, lastElement, ref, results;
	        lastElement = array.pop();
	        results = [];
	        for (i = k = 0, ref = array.elementLength; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
	          results.push(array.getAllElements()[index * array.elementLength + i] = lastElement[i]);
	        }
	        return results;
	      };
	    })(this);
	    nodesIndex = this.getNodeIndex(node.id);
	    ErrorHandling.assert(nodesIndex != null, "No node found.", {
	      id: node.id,
	      nodeIDs: this.nodeIDs
	    });
	    swapLast(this.nodeIDs, nodesIndex);
	    swapLast(this.nodesBuffer, nodesIndex);
	    swapLast(this.sizesBuffer, nodesIndex);
	    swapLast(this.scalesBuffer, nodesIndex);
	    swapLast(this.nodesColorBuffer, nodesIndex);
	    edgeArray = this.getEdgeArray(node, node.neighbors[0]);
	    for (i = k = 0, ref = this.edgesBuffer.getLength(); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
	      found = true;
	      for (j = l = 0; l <= 5; j = ++l) {
	        found &= Math.abs(this.edges.geometry.attributes.position.array[6 * i + j] - edgeArray[j]) < 0.5;
	      }
	      if (found) {
	        edgesIndex = i;
	        break;
	      }
	    }
	    ErrorHandling.assert(found, "No edge found.", {
	      found: found,
	      edgeArray: edgeArray,
	      nodesIndex: nodesIndex
	    });
	    swapLast(this.edgesBuffer, edgesIndex);
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.mergeTree = function(otherTree, lastNode, activeNode) {
	    var merge;
	    merge = (function(_this) {
	      return function(property) {
	        return _this[property].pushSubarray(otherTree[property].getAllElements());
	      };
	    })(this);
	    merge("nodeIDs");
	    merge("nodesBuffer");
	    merge("edgesBuffer");
	    merge("sizesBuffer");
	    merge("scalesBuffer");
	    this.edgesBuffer.push(this.getEdgeArray(lastNode, activeNode));
	    this.updateNodesColors();
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.getEdgeArray = function(node1, node2) {
	    if (node1.id < node2.id) {
	      return node1.pos.concat(node2.pos);
	    } else {
	      return node2.pos.concat(node1.pos);
	    }
	  };
	
	  Tree.prototype.setSizeAttenuation = function(sizeAttenuation) {
	    this.nodes.material.sizeAttenuation = sizeAttenuation;
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.updateTreeColor = function() {
	    var newColor;
	    newColor = this.model.skeletonTracing.getTree(this.id).color;
	    this.edges.material.color = new THREE.Color(this.darkenHex(newColor));
	    this.updateNodesColors();
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.getMeshes = function() {
	    return [this.edges, this.nodes];
	  };
	
	  Tree.prototype.dispose = function() {
	    var geometry, k, len, ref, results;
	    ref = this.getMeshes();
	    results = [];
	    for (k = 0, len = ref.length; k < len; k++) {
	      geometry = ref[k];
	      geometry.geometry.dispose();
	      results.push(geometry.material.dispose());
	    }
	    return results;
	  };
	
	  Tree.prototype.updateNodesColors = function() {
	    var i, k, ref;
	    this.nodesColorBuffer.clear();
	    for (i = k = 0, ref = this.nodeIDs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
	      this.nodesColorBuffer.push(this.getColor(this.nodeIDs.get(i)));
	    }
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.updateNodeColor = function(id, isActiveNode, isBranchPoint) {
	    this.doWithNodeIndex(id, (function(_this) {
	      return function(index) {
	        return _this.nodesColorBuffer.set(_this.getColor(id, isActiveNode, isBranchPoint), index);
	      };
	    })(this));
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.updateNodeRadius = function(id, radius) {
	    this.doWithNodeIndex(id, (function(_this) {
	      return function(index) {
	        return _this.sizesBuffer.set([radius * 2], index);
	      };
	    })(this));
	    return this.updateGeometries();
	  };
	
	  Tree.prototype.startNodeHighlightAnimation = function(nodeId) {
	    var highlighted, normal;
	    normal = 1.0;
	    highlighted = 2.0;
	    return this.doWithNodeIndex(nodeId, (function(_this) {
	      return function(index) {
	        return _this.animateNodeScale(normal, highlighted, index, function() {
	          return _this.animateNodeScale(highlighted, normal, index);
	        });
	      };
	    })(this));
	  };
	
	  Tree.prototype.animateNodeScale = function(from, to, index, onComplete) {
	    var onUpdate, redraw, setScaleFactor;
	    if (onComplete == null) {
	      onComplete = function() {};
	    }
	    setScaleFactor = (function(_this) {
	      return function(factor) {
	        return _this.scalesBuffer.set([factor], index);
	      };
	    })(this);
	    redraw = (function(_this) {
	      return function() {
	        _this.updateGeometries();
	        return app.vent.trigger("rerender");
	      };
	    })(this);
	    onUpdate = function() {
	      setScaleFactor(this.scaleFactor);
	      return redraw();
	    };
	    return (new TWEEN.Tween({
	      scaleFactor: from
	    })).to({
	      scaleFactor: to
	    }, 100).onUpdate(onUpdate).onComplete(onComplete).start();
	  };
	
	  Tree.prototype.getColor = function(id, isActiveNode, isBranchPoint) {
	    var color;
	    color = this.model.skeletonTracing.getTree(this.id).color;
	    if (id != null) {
	      isActiveNode = isActiveNode || this.model.skeletonTracing.getActiveNodeId() === id;
	      isBranchPoint = isBranchPoint || this.model.skeletonTracing.isBranchPoint(id);
	      if (isActiveNode) {
	        color = this.shiftHex(color, 1 / 4);
	      } else {
	        color = this.darkenHex(color);
	      }
	      if (isBranchPoint) {
	        color = this.invertHex(color);
	      }
	    }
	    return this.hexToRGB(color);
	  };
	
	  Tree.prototype.showRadius = function(show) {
	    this.edges.material.linewidth = this.getLineWidth();
	    return this.particleMaterial.setShowRadius(show);
	  };
	
	  Tree.prototype.updateGeometries = function() {
	    var a, attr, k, len, mesh, ref, results;
	    ref = [this.edges, this.nodes];
	    results = [];
	    for (k = 0, len = ref.length; k < len; k++) {
	      mesh = ref[k];
	      results.push((function() {
	        var results1;
	        results1 = [];
	        for (attr in mesh.geometry.attributes) {
	          a = mesh.geometry.attributes[attr];
	          a.array = a._rBuffer.getBuffer();
	          a.numItems = a._rBuffer.getBufferLength();
	          results1.push(a.needsUpdate = true);
	        }
	        return results1;
	      })());
	    }
	    return results;
	  };
	
	  Tree.prototype.logState = function(title) {
	    console.log(" +++ " + title + " +++ ");
	    console.log("nodeIDs", this.nodeIDs.toString());
	    console.log("nodesBuffer", this.nodesBuffer.toString());
	    console.log("edgesBuffer", this.edgesBuffer.toString());
	    return console.log("sizesBuffer", this.sizesBuffer.toString());
	  };
	
	  Tree.prototype.getNodeIndex = function(nodeId) {
	    var i, k, ref;
	    for (i = k = 0, ref = this.nodeIDs.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
	      if (this.nodeIDs.get(i) === nodeId) {
	        return i;
	      }
	    }
	  };
	
	  Tree.prototype.doWithNodeIndex = function(nodeId, f) {
	    var index;
	    index = this.getNodeIndex(nodeId);
	    if (index == null) {
	      return;
	    }
	    return f(index);
	  };
	
	  Tree.prototype.getLineWidth = function() {
	    return this.model.user.get("particleSize") / 4;
	  };
	
	  Tree.prototype.hexToRGB = function(hexColor) {
	    var rgbColor;
	    rgbColor = new THREE.Color().setHex(hexColor);
	    return [rgbColor.r, rgbColor.g, rgbColor.b];
	  };
	
	  Tree.prototype.darkenHex = function(hexColor) {
	    var hsvColor;
	    hsvColor = ColorConverter.getHSV(new THREE.Color().setHex(hexColor));
	    hsvColor.v = 0.6;
	    return ColorConverter.setHSV(new THREE.Color(), hsvColor.h, hsvColor.s, hsvColor.v).getHex();
	  };
	
	  Tree.prototype.shiftHex = function(hexColor, shiftValue) {
	    var hsvColor;
	    hsvColor = ColorConverter.getHSV(new THREE.Color().setHex(hexColor));
	    hsvColor.h = (hsvColor.h + shiftValue) % 1;
	    return ColorConverter.setHSV(new THREE.Color(), hsvColor.h, hsvColor.s, hsvColor.v).getHex();
	  };
	
	  Tree.prototype.invertHex = function(hexColor) {
	    return this.shiftHex(hexColor, 0.5);
	  };
	
	  return Tree;
	
	})();
	
	module.exports = Tree;


/***/ },
/* 320 */
/***/ function(module, exports) {

	var ResizableBuffer;
	
	ResizableBuffer = (function() {
	  ResizableBuffer.prototype.GROW_MULTIPLIER = 1.3;
	
	  function ResizableBuffer(elementLength1, initialCapacity, bufferType) {
	    this.elementLength = elementLength1;
	    if (initialCapacity == null) {
	      initialCapacity = 100;
	    }
	    this.bufferType = bufferType != null ? bufferType : Float32Array;
	    this.capacity = initialCapacity * this.elementLength;
	    this.buffer = new this.bufferType(this.capacity);
	    this.length = 0;
	  }
	
	  ResizableBuffer.prototype.clear = function() {
	    return this.length = 0;
	  };
	
	  ResizableBuffer.prototype.isEmpty = function() {
	    return this.length === 0;
	  };
	
	  ResizableBuffer.prototype.isFull = function() {
	    return this.length === this.capacity;
	  };
	
	  ResizableBuffer.prototype.getLength = function() {
	    return this.length / this.elementLength;
	  };
	
	  ResizableBuffer.prototype.getBufferLength = function() {
	    return this.length;
	  };
	
	  ResizableBuffer.prototype.getBuffer = function() {
	    return this.buffer;
	  };
	
	  ResizableBuffer.prototype.getAllElements = function() {
	    return this.buffer.subarray(0, this.length);
	  };
	
	  ResizableBuffer.prototype.get = function(i) {
	    return this.buffer[i];
	  };
	
	  ResizableBuffer.prototype.set = function(element, i) {
	    return this.buffer.set(element, i * this.elementLength);
	  };
	
	  ResizableBuffer.prototype.push = function(element) {
	    var buffer, elementLength, length;
	    this.ensureCapacity();
	    buffer = this.buffer, elementLength = this.elementLength, length = this.length;
	    buffer.set(element, length);
	    return this.length += elementLength;
	  };
	
	  ResizableBuffer.prototype.pushMany = function(elements) {
	    var buffer, element, elementLength, k, len, length;
	    this.ensureCapacity(this.length + elements.length * this.elementLength);
	    buffer = this.buffer, elementLength = this.elementLength, length = this.length;
	    for (k = 0, len = elements.length; k < len; k++) {
	      element = elements[k];
	      buffer.set(element, length);
	      length += elementLength;
	    }
	    return this.length += elements.length * elementLength;
	  };
	
	  ResizableBuffer.prototype.pushSubarray = function(subarray) {
	    var buffer, elementLength, length;
	    this.ensureCapacity(this.length + subarray.length);
	    buffer = this.buffer, elementLength = this.elementLength, length = this.length;
	    buffer.set(subarray, length);
	    return this.length += subarray.length;
	  };
	
	  ResizableBuffer.prototype.pop = function(r) {
	    var buffer, elementLength, i, k, length, ref;
	    if (r == null) {
	      r = new Array(this.elementLength);
	    }
	    if (!this.length) {
	      return;
	    }
	    buffer = this.buffer, elementLength = this.elementLength, length = this.length;
	    for (i = k = ref = elementLength - 1; k >= 0; i = k += -1) {
	      r[i] = buffer[--length];
	    }
	    this.length -= elementLength;
	    return r;
	  };
	
	  ResizableBuffer.prototype.top = function(r) {
	    var buffer, elementLength, i, k, length, ref;
	    if (r == null) {
	      r = new Array(this.elementLength);
	    }
	    if (!this.length) {
	      return;
	    }
	    buffer = this.buffer, elementLength = this.elementLength, length = this.length;
	    for (i = k = ref = elementLength - 1; k >= 0; i = k += -1) {
	      r[i] = buffer[--length];
	    }
	    return r;
	  };
	
	  ResizableBuffer.prototype.ensureCapacity = function(newCapacity) {
	    var buffer, newBuffer;
	    if (newCapacity == null) {
	      newCapacity = this.length + this.elementLength;
	    }
	    if (this.capacity < newCapacity) {
	      buffer = this.buffer;
	      while (this.capacity < newCapacity) {
	        this.capacity = Math.floor(this.capacity * this.GROW_MULTIPLIER);
	        this.capacity -= this.capacity % this.elementLength;
	      }
	      newBuffer = new this.bufferType(this.capacity);
	      newBuffer.set(buffer);
	      return this.buffer = newBuffer;
	    }
	  };
	
	  ResizableBuffer.prototype.toString = function() {
	    var element, i, j, k, l, length, ref, ref1, result;
	    length = this.getLength();
	    result = [];
	    for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
	      element = [];
	      for (j = l = 0, ref1 = this.elementLength; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
	        element.push(this.buffer[i * this.elementLength + j]);
	      }
	      result.push("[ " + element.join(", ") + " ]");
	    }
	    return "(" + length + ") { " + result.join(", ") + " }";
	  };
	
	  return ResizableBuffer;
	
	})();
	
	module.exports = ResizableBuffer;


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var AbstractMaterialFactory, ParticleMaterialFactory, THREE, app,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	app = __webpack_require__(48);
	
	THREE = __webpack_require__(245);
	
	AbstractMaterialFactory = __webpack_require__(252);
	
	ParticleMaterialFactory = (function(superClass) {
	  extend(ParticleMaterialFactory, superClass);
	
	  function ParticleMaterialFactory() {
	    return ParticleMaterialFactory.__super__.constructor.apply(this, arguments);
	  }
	
	  ParticleMaterialFactory.prototype.setupAttributesAndUniforms = function() {
	    ParticleMaterialFactory.__super__.setupAttributesAndUniforms.call(this);
	    this.uniforms = _.extend(this.uniforms, {
	      zoomFactor: {
	        type: "f",
	        value: this.model.flycam.getPlaneScalingFactor()
	      },
	      baseVoxel: {
	        type: "f",
	        value: app.scaleInfo.baseVoxel
	      },
	      particleSize: {
	        type: "f",
	        value: this.model.user.get("particleSize")
	      },
	      scale: {
	        type: "f",
	        value: this.model.user.get("scale")
	      },
	      showRadius: {
	        type: "i",
	        value: 1
	      },
	      devicePixelRatio: {
	        type: "f",
	        value: window.devicePixelRatio || 1
	      }
	    });
	    return this.attributes = _.extend(this.attributes, {
	      sizeNm: {
	        type: "f"
	      },
	      nodeScaleFactor: {
	        type: "f"
	      }
	    });
	  };
	
	  ParticleMaterialFactory.prototype.makeMaterial = function() {
	    ParticleMaterialFactory.__super__.makeMaterial.call(this, {
	      vertexColors: true
	    });
	    return this.material.setShowRadius = (function(_this) {
	      return function(showRadius) {
	        return _this.uniforms.showRadius.value = showRadius ? 1 : 0;
	      };
	    })(this);
	  };
	
	  ParticleMaterialFactory.prototype.setupChangeListeners = function() {
	    ParticleMaterialFactory.__super__.setupChangeListeners.call(this);
	    this.listenTo(this.model.user, "change:particleSize", function(model, size) {
	      this.uniforms.particleSize.value = size;
	      return app.vent.trigger("rerender");
	    });
	    this.listenTo(this.model.user, "change:scale", function(model, scale) {
	      this.uniforms.scale.value = scale;
	      return app.vent.trigger("rerender");
	    });
	    this.listenTo(this.model.user, "change:overrideNodeRadius", function() {
	      return app.vent.trigger("rerender");
	    });
	    return this.listenTo(this.model.flycam, "zoomStepChanged", function() {
	      this.uniforms.zoomFactor.value = this.model.flycam.getPlaneScalingFactor();
	      return app.vent.trigger("rerender");
	    });
	  };
	
	  ParticleMaterialFactory.prototype.getVertexShader = function() {
	    return "uniform float zoomFactor;\nuniform float baseVoxel;\nuniform float particleSize;\nuniform float scale;\nuniform int   showRadius;\nuniform float devicePixelRatio;\nvarying vec3 vColor;\nattribute float sizeNm;\nattribute float nodeScaleFactor;\n\nvoid main()\n{\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vColor = color;\n    if (showRadius == 1)\n      gl_PointSize = max(\n          sizeNm / zoomFactor / baseVoxel,\n          particleSize\n        ) * devicePixelRatio * scale * nodeScaleFactor;\n    else\n      gl_PointSize = particleSize * nodeScaleFactor;\n    gl_Position = projectionMatrix * mvPosition;\n}";
	  };
	
	  ParticleMaterialFactory.prototype.getFragmentShader = function() {
	    return "varying vec3 vColor;\n\nvoid main()\n{\n    gl_FragColor = vec4( vColor, 1.0 );\n}";
	  };
	
	  return ParticleMaterialFactory;
	
	})(AbstractMaterialFactory);
	
	module.exports = ParticleMaterialFactory;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Cube, THREE, app, backbone, constants, dimensions;
	
	app = __webpack_require__(48);
	
	backbone = __webpack_require__(3);
	
	constants = __webpack_require__(61);
	
	dimensions = __webpack_require__(277);
	
	THREE = __webpack_require__(245);
	
	Cube = (function() {
	  function Cube(model, properties) {
	    var color, i, k, len, lineProperties, lineWidth, ref;
	    this.model = model;
	    this.min = properties.min || [0, 0, 0];
	    this.max = properties.max;
	    lineWidth = properties.lineWidth || 1;
	    color = properties.color || 0x000000;
	    this.showCrossSections = properties.showCrossSections || false;
	    _.extend(this, Backbone.Events);
	    this.initialized = false;
	    this.visible = true;
	    this.listenTo(this.model.flycam, "positionChanged", (function(_this) {
	      return function(pos) {
	        return _this.updatePosition(pos);
	      };
	    })(this));
	    lineProperties = {
	      color: color,
	      linewidth: lineWidth
	    };
	    this.cube = new THREE.Line(new THREE.Geometry(), new THREE.LineBasicMaterial(lineProperties));
	    this.crossSections = [];
	    ref = constants.ALL_PLANES;
	    for (k = 0, len = ref.length; k < len; k++) {
	      i = ref[k];
	      this.crossSections.push(new THREE.Line(new THREE.Geometry(), new THREE.LineBasicMaterial(lineProperties)));
	    }
	    if ((this.min != null) && (this.max != null)) {
	      this.setCorners(this.min, this.max);
	    }
	  }
	
	  Cube.prototype.setCorners = function(min1, max1) {
	    var k, len, max, mesh, min, ref, v, vec;
	    this.min = min1;
	    this.max = max1;
	    min = this.min, max = this.max;
	    vec = function(x, y, z) {
	      return new THREE.Vector3(x, y, z);
	    };
	    v = (this.cube.geometry.vertices = []);
	    v.push(vec(min[0], min[1], min[2]));
	    v.push(vec(min[0], max[1], min[2]));
	    v.push(vec(max[0], max[1], min[2]));
	    v.push(vec(max[0], min[1], min[2]));
	    v.push(vec(max[0], min[1], max[2]));
	    v.push(vec(max[0], max[1], max[2]));
	    v.push(vec(min[0], max[1], max[2]));
	    v.push(vec(min[0], min[1], max[2]));
	    v.push(vec(min[0], min[1], min[2]));
	    v.push(vec(max[0], min[1], min[2]));
	    v.push(vec(max[0], max[1], min[2]));
	    v.push(vec(max[0], max[1], max[2]));
	    v.push(vec(max[0], min[1], max[2]));
	    v.push(vec(min[0], min[1], max[2]));
	    v.push(vec(min[0], max[1], max[2]));
	    v.push(vec(min[0], max[1], min[2]));
	    v = (this.crossSections[constants.PLANE_XY].geometry.vertices = []);
	    v.push(vec(min[0], min[1], 0));
	    v.push(vec(min[0], max[1], 0));
	    v.push(vec(max[0], max[1], 0));
	    v.push(vec(max[0], min[1], 0));
	    v.push(vec(min[0], min[1], 0));
	    v = (this.crossSections[constants.PLANE_YZ].geometry.vertices = []);
	    v.push(vec(0, min[1], min[2]));
	    v.push(vec(0, min[1], max[2]));
	    v.push(vec(0, max[1], max[2]));
	    v.push(vec(0, max[1], min[2]));
	    v.push(vec(0, min[1], min[2]));
	    v = (this.crossSections[constants.PLANE_XZ].geometry.vertices = []);
	    v.push(vec(min[0], 0, min[2]));
	    v.push(vec(min[0], 0, max[2]));
	    v.push(vec(max[0], 0, max[2]));
	    v.push(vec(max[0], 0, min[2]));
	    v.push(vec(min[0], 0, min[2]));
	    ref = this.crossSections.concat([this.cube]);
	    for (k = 0, len = ref.length; k < len; k++) {
	      mesh = ref[k];
	      mesh.geometry.verticesNeedUpdate = true;
	    }
	    this.initialized = true;
	    this.updatePosition(this.model.flycam.getPosition());
	    return app.vent.trigger("rerender");
	  };
	
	  Cube.prototype.updatePosition = function(position) {
	    var array, geo, i, j, k, l, len, ref, ref1, results, thirdDim;
	    if (!this.initialized) {
	      return;
	    }
	    ref = constants.ALL_PLANES;
	    results = [];
	    for (k = 0, len = ref.length; k < len; k++) {
	      i = ref[k];
	      thirdDim = dimensions.thirdDimensionForPlane(i);
	      geo = this.crossSections[i].geometry;
	      for (j = l = 0, ref1 = geo.vertices.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
	        array = geo.vertices[j].toArray();
	        array[thirdDim] = position[thirdDim];
	        geo.vertices[j] = (function(func, args, ctor) {
	          ctor.prototype = func.prototype;
	          var child = new ctor, result = func.apply(child, args);
	          return Object(result) === result ? result : child;
	        })(THREE.Vector3, array, function(){});
	      }
	      results.push(geo.verticesNeedUpdate = true);
	    }
	    return results;
	  };
	
	  Cube.prototype.getMeshes = function() {
	    return [this.cube].concat(this.crossSections);
	  };
	
	  Cube.prototype.updateForCam = function(id) {
	    var i, k, position, thirdDim;
	    if (!this.initialized) {
	      return;
	    }
	    for (i = k = 0; k <= 2; i = ++k) {
	      thirdDim = dimensions.thirdDimensionForPlane(i);
	      position = this.model.flycam.getPosition();
	      if (position[thirdDim] >= this.min[thirdDim] && position[thirdDim] <= this.max[thirdDim]) {
	        this.crossSections[i].visible = this.visible && (i === id) && this.showCrossSections;
	      } else {
	        this.crossSections[i].visible = false;
	      }
	    }
	    return this.cube.visible = this.visible && (id === constants.TDView);
	  };
	
	  Cube.prototype.setVisibility = function(visible) {
	    return this.visible = visible;
	  };
	
	  return Cube;
	
	})();
	
	module.exports = Cube;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var Backbone, ContourGeometry, Dimensions, ResizableBuffer, THREE, app, constants;
	
	app = __webpack_require__(48);
	
	Backbone = __webpack_require__(3);
	
	ResizableBuffer = __webpack_require__(320);
	
	THREE = __webpack_require__(245);
	
	Dimensions = __webpack_require__(277);
	
	constants = __webpack_require__(61);
	
	ContourGeometry = (function() {
	  ContourGeometry.prototype.COLOR_NORMAL = new THREE.Color(0x000000);
	
	  ContourGeometry.prototype.COLOR_DELETE = new THREE.Color(0xff0000);
	
	  function ContourGeometry(volumeTracing, flycam) {
	    this.volumeTracing = volumeTracing;
	    this.flycam = flycam;
	    _.extend(this, Backbone.Events);
	    this.color = this.COLOR_NORMAL;
	    this.listenTo(this.volumeTracing, "volumeAnnotated", this.reset);
	    this.listenTo(this.volumeTracing, "updateLayer", function(cellId, contourList) {
	      var i, len, p, results;
	      this.color = cellId === 0 ? this.COLOR_DELETE : this.COLOR_NORMAL;
	      this.reset();
	      results = [];
	      for (i = 0, len = contourList.length; i < len; i++) {
	        p = contourList[i];
	        results.push(this.addEdgePoint(p));
	      }
	      return results;
	    });
	    this.createMeshes();
	  }
	
	  ContourGeometry.prototype.createMeshes = function() {
	    var edgeGeometry;
	    edgeGeometry = new THREE.BufferGeometry();
	    edgeGeometry.addAttribute('position', Float32Array, 0, 3);
	    edgeGeometry.dynamic = true;
	    this.edge = new THREE.Line(edgeGeometry, new THREE.LineBasicMaterial({
	      linewidth: 2
	    }), THREE.LineStrip);
	    this.edge.vertexBuffer = new ResizableBuffer(3);
	    return this.reset();
	  };
	
	  ContourGeometry.prototype.reset = function() {
	    this.edge.material.color = this.color;
	    this.edge.vertexBuffer.clear();
	    return this.finalizeMesh(this.edge);
	  };
	
	  ContourGeometry.prototype.getMeshes = function() {
	    return [this.edge];
	  };
	
	  ContourGeometry.prototype.addEdgePoint = function(pos) {
	    var edgePoint, globalPos;
	    globalPos = this.flycam.getPosition();
	    edgePoint = pos.slice();
	    edgePoint[this.thirdDimension] = globalPos[this.thirdDimension];
	    this.edge.vertexBuffer.push(edgePoint);
	    this.finalizeMesh(this.edge);
	    return app.vent.trigger("rerender");
	  };
	
	  ContourGeometry.prototype.finalizeMesh = function(mesh) {
	    var positionAttribute;
	    positionAttribute = mesh.geometry.attributes.position;
	    positionAttribute.array = mesh.vertexBuffer.getBuffer();
	    positionAttribute.numItems = mesh.vertexBuffer.getLength() * 3;
	    return positionAttribute.needsUpdate = true;
	  };
	
	  return ContourGeometry;
	
	})();
	
	module.exports = ContourGeometry;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var ColorGenerator, THREE, VolumeGeometry;
	
	THREE = __webpack_require__(245);
	
	ColorGenerator = __webpack_require__(286);
	
	VolumeGeometry = (function() {
	  function VolumeGeometry(triangles, id) {
	    var color, geo, i, j, k, len, len1, normal, triangle, vertex;
	    this.id = id;
	    geo = new THREE.Geometry();
	    color = ColorGenerator.distinctColorForId(this.id % 256);
	    i = 0;
	    for (j = 0, len = triangles.length; j < len; j++) {
	      triangle = triangles[j];
	      for (k = 0, len1 = triangle.length; k < len1; k++) {
	        vertex = triangle[k];
	        geo.vertices.push((function(func, args, ctor) {
	          ctor.prototype = func.prototype;
	          var child = new ctor, result = func.apply(child, args);
	          return Object(result) === result ? result : child;
	        })(THREE.Vector3, vertex, function(){}));
	      }
	      normal = this.getTriangleNormal(triangle);
	      geo.faces.push(new THREE.Face3(i++, i++, i++, normal));
	    }
	    this.mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({
	      color: color
	    }));
	    this.mesh.oberdraw = true;
	  }
	
	  VolumeGeometry.prototype.getTriangleNormal = function(triangle) {
	    var v1, v2;
	    v1 = new THREE.Vector3(triangle[1][0] - triangle[0][0], triangle[1][1] - triangle[0][1], triangle[1][2] - triangle[0][2]);
	    v2 = new THREE.Vector3(triangle[2][0] - triangle[0][0], triangle[2][1] - triangle[0][1], triangle[2][2] - triangle[0][2]);
	    v1.cross(v2);
	    v1.normalize();
	    return v1;
	  };
	
	  VolumeGeometry.prototype.getMeshes = function() {
	    return [this.mesh];
	  };
	
	  return VolumeGeometry;
	
	})();
	
	module.exports = VolumeGeometry;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var Deferred, PolygonFactory, _, tlt,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	tlt = __webpack_require__(326);
	
	_ = __webpack_require__(2);
	
	Deferred = __webpack_require__(284);
	
	PolygonFactory = (function() {
	  function PolygonFactory(modelCube, resolution, min, max, id) {
	    var ref, ref1, ref2, round;
	    this.modelCube = modelCube;
	    this.id = id;
	    this.calculateTrianglesAsync = bind(this.calculateTrianglesAsync, this);
	    this.voxelsToSkip = Math.ceil((max[0] - min[0]) / resolution) || 1;
	    this.chunkSize = 10000;
	    round = (function(_this) {
	      return function(number) {
	        return Math.floor(number / _this.voxelsToSkip) * _this.voxelsToSkip;
	      };
	    })(this);
	    ref = [round(min[0]), round(max[0]) + this.voxelsToSkip], this.startX = ref[0], this.endX = ref[1];
	    ref1 = [round(min[1]), round(max[1]) + this.voxelsToSkip], this.startY = ref1[0], this.endY = ref1[1];
	    ref2 = [round(min[2]), round(max[2]) + this.voxelsToSkip], this.startZ = ref2[0], this.endZ = ref2[1];
	  }
	
	  PolygonFactory.prototype.getTriangles = function() {
	    var result;
	    result = {};
	    this.deferred = new Deferred();
	    this.isCancelled = false;
	    _.defer(this.calculateTrianglesAsync, result);
	    return this.deferred.promise();
	  };
	
	  PolygonFactory.prototype.cancel = function() {
	    return this.isCancelled = true;
	  };
	
	  PolygonFactory.prototype.calculateTrianglesAsync = function(result, lastPosition) {
	    var i, position;
	    if (this.isCancelled) {
	      return;
	    }
	    i = 0;
	    position = this.getNextPosition(lastPosition);
	    while (this.isPositionInBoundingBox(position)) {
	      this.updateTriangles(result, position);
	      if (i === this.chunkSize) {
	        _.defer(this.calculateTrianglesAsync, result, position);
	        return;
	      }
	      i++;
	      position = this.getNextPosition(position);
	    }
	    return this.deferred.resolve(result);
	  };
	
	  PolygonFactory.prototype.isPositionInBoundingBox = function(position) {
	    var x, y, z;
	    if (position != null) {
	      x = position[0], y = position[1], z = position[2];
	      return (x >= this.startX && y >= this.startY && z >= this.startZ) && (x <= this.endX && y <= this.endY && z <= this.endZ);
	    }
	    return false;
	  };
	
	  PolygonFactory.prototype.getNextPosition = function(lastPosition) {
	    var oldX, oldY, oldZ;
	    if (lastPosition == null) {
	      return [this.startX, this.startY, this.startZ];
	    } else {
	      oldX = lastPosition[0], oldY = lastPosition[1], oldZ = lastPosition[2];
	      if (oldX + this.voxelsToSkip < this.endX) {
	        return [oldX + this.voxelsToSkip, oldY, oldZ];
	      }
	      if (oldY + this.voxelsToSkip < this.endY) {
	        return [this.startX, oldY + this.voxelsToSkip, oldZ];
	      } else {
	        return [this.startX, this.startY, oldZ + 1];
	      }
	    }
	  };
	
	  PolygonFactory.prototype.updateTriangles = function(result, position) {
	    var cellId, cubeIndex, cubeIndices, results;
	    cubeIndices = this.getCubeIndices(position);
	    results = [];
	    for (cellId in cubeIndices) {
	      cubeIndex = cubeIndices[cellId];
	      if (result[cellId] == null) {
	        result[cellId] = [];
	      }
	      if (!(cubeIndex === 0 || cubeIndex === 256)) {
	        results.push(this.addNewTriangles(result[cellId], cubeIndex, position));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  PolygonFactory.prototype.getCubeIndices = function(arg) {
	    var bit, cellId, cellIds, cubeIndex, i, j, k, l, label, labels, len, len1, result, x, y, z;
	    x = arg[0], y = arg[1], z = arg[2];
	    labels = [this.modelCube.getDataValue([x, y, z]), this.modelCube.getDataValue([x + this.voxelsToSkip, y, z]), this.modelCube.getDataValue([x + this.voxelsToSkip, y, z + this.voxelsToSkip]), this.modelCube.getDataValue([x, y, z + this.voxelsToSkip]), this.modelCube.getDataValue([x, y + this.voxelsToSkip, z]), this.modelCube.getDataValue([x + this.voxelsToSkip, y + this.voxelsToSkip, z]), this.modelCube.getDataValue([x + this.voxelsToSkip, y + this.voxelsToSkip, z + this.voxelsToSkip]), this.modelCube.getDataValue([x, y + this.voxelsToSkip, z + this.voxelsToSkip])];
	    cellIds = [];
	    for (j = 0, len = labels.length; j < len; j++) {
	      label = labels[j];
	      if (!(indexOf.call(cellIds, label) >= 0 || label === 0 || ((this.id != null) && this.id !== label))) {
	        cellIds.push(label);
	      }
	    }
	    result = {};
	    for (k = 0, len1 = cellIds.length; k < len1; k++) {
	      cellId = cellIds[k];
	      cubeIndex = 0;
	      for (i = l = 0; l <= 7; i = ++l) {
	        bit = cellId === labels[i] ? 1 : 0;
	        cubeIndex |= bit << i;
	      }
	      result[cellId] = cubeIndex;
	    }
	    return result;
	  };
	
	  PolygonFactory.prototype.addNewTriangles = function(triangleList, cubeIndex, arg) {
	    var j, k, len, len1, ref, results, triangle, vertex, vertices, x, y, z;
	    x = arg[0], y = arg[1], z = arg[2];
	    ref = tlt[cubeIndex];
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      triangle = ref[j];
	      vertices = [];
	      for (k = 0, len1 = triangle.length; k < len1; k++) {
	        vertex = triangle[k];
	        vertices.push([vertex[0] * this.voxelsToSkip + x, vertex[1] * this.voxelsToSkip + y, vertex[2] * this.voxelsToSkip + z]);
	      }
	      results.push(triangleList.push(vertices));
	    }
	    return results;
	  };
	
	  return PolygonFactory;
	
	})();
	
	module.exports = PolygonFactory;


/***/ },
/* 326 */
/***/ function(module, exports) {

	var tlt;
	
	tlt = [[], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]]], [[[1, 0, 0.5], [0, 0.5, 0], [0, 0, 0.5]], [[1, 0.5, 0], [0, 0.5, 0], [1, 0, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]]], [[[1, 0.5, 0], [0.5, 0, 1], [1, 0.5, 1]], [[0.5, 0, 0], [0.5, 0, 1], [1, 0.5, 0]]], [[[0.5, 0, 1], [0, 0.5, 0], [0, 0, 0.5]], [[0.5, 0, 1], [1, 0.5, 1], [0, 0.5, 0]], [[1, 0.5, 1], [1, 0.5, 0], [0, 0.5, 0]]], [[[0, 0, 0.5], [0, 0.5, 1], [0.5, 0, 1]]], [[[0.5, 0, 0], [0, 0.5, 1], [0.5, 0, 1]], [[0, 0.5, 0], [0, 0.5, 1], [0.5, 0, 0]]], [[[1, 0, 0.5], [1, 0.5, 0], [0.5, 0, 0]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]]], [[[1, 0, 0.5], [0, 0.5, 1], [0.5, 0, 1]], [[1, 0, 0.5], [1, 0.5, 0], [0, 0.5, 1]], [[1, 0.5, 0], [0, 0.5, 0], [0, 0.5, 1]]], [[[0, 0, 0.5], [1, 0.5, 1], [1, 0, 0.5]], [[0, 0.5, 1], [1, 0.5, 1], [0, 0, 0.5]]], [[[0.5, 0, 0], [1, 0.5, 1], [1, 0, 0.5]], [[0.5, 0, 0], [0, 0.5, 0], [1, 0.5, 1]], [[0, 0.5, 0], [0, 0.5, 1], [1, 0.5, 1]]], [[[0, 0, 0.5], [1, 0.5, 0], [0.5, 0, 0]], [[0, 0, 0.5], [0, 0.5, 1], [1, 0.5, 0]], [[0, 0.5, 1], [1, 0.5, 1], [1, 0.5, 0]]], [[[1, 0.5, 0], [0, 0.5, 0], [1, 0.5, 1]], [[1, 0.5, 1], [0, 0.5, 0], [0, 0.5, 1]]], [[[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 0]]], [[[0.5, 1, 0], [0, 0, 0.5], [0.5, 0, 0]], [[0, 1, 0.5], [0, 0, 0.5], [0.5, 1, 0]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]]], [[[0.5, 1, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0.5, 1, 0], [0, 1, 0.5], [1, 0, 0.5]], [[0, 1, 0.5], [0, 0, 0.5], [1, 0, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]]], [[[0, 0, 0.5], [0.5, 1, 0], [0, 1, 0.5]], [[0, 0, 0.5], [0.5, 0, 0], [0.5, 1, 0]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]]], [[[1, 0.5, 0], [0.5, 0, 1], [1, 0.5, 1]], [[1, 0.5, 0], [0.5, 0, 0], [0.5, 0, 1]], [[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]]], [[[0.5, 0, 1], [1, 0.5, 1], [1, 0.5, 0]], [[0.5, 0, 1], [1, 0.5, 0], [0, 1, 0.5]], [[0.5, 0, 1], [0, 1, 0.5], [0, 0, 0.5]], [[0, 1, 0.5], [1, 0.5, 0], [0.5, 1, 0]]], [[[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]], [[0, 0, 0.5], [0, 0.5, 1], [0.5, 0, 1]]], [[[0, 0.5, 1], [0.5, 1, 0], [0, 1, 0.5]], [[0, 0.5, 1], [0.5, 0, 1], [0.5, 1, 0]], [[0.5, 0, 1], [0.5, 0, 0], [0.5, 1, 0]]], [[[1, 0.5, 0], [0.5, 0, 0], [1, 0, 0.5]], [[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]]], [[[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 1]], [[1, 0.5, 0], [0.5, 1, 0], [0, 0.5, 1]], [[1, 0.5, 0], [0, 0.5, 1], [0.5, 0, 1]], [[1, 0.5, 0], [0.5, 0, 1], [1, 0, 0.5]]], [[[0, 0, 0.5], [1, 0.5, 1], [1, 0, 0.5]], [[0, 0, 0.5], [0, 0.5, 1], [1, 0.5, 1]], [[0, 1, 0.5], [0, 0.5, 0], [0.5, 1, 0]]], [[[1, 0, 0.5], [0, 0.5, 1], [1, 0.5, 1]], [[1, 0, 0.5], [0.5, 1, 0], [0, 0.5, 1]], [[1, 0, 0.5], [0.5, 0, 0], [0.5, 1, 0]], [[0, 1, 0.5], [0, 0.5, 1], [0.5, 1, 0]]], [[[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 0]], [[1, 0.5, 0], [0.5, 0, 0], [0, 0.5, 1]], [[1, 0.5, 0], [0, 0.5, 1], [1, 0.5, 1]], [[0, 0.5, 1], [0.5, 0, 0], [0, 0, 0.5]]], [[[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 1]], [[0.5, 1, 0], [0, 0.5, 1], [1, 0.5, 0]], [[1, 0.5, 0], [0, 0.5, 1], [1, 0.5, 1]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]], [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]]], [[[0.5, 0, 0], [1, 1, 0.5], [0.5, 1, 0]], [[1, 0, 0.5], [1, 1, 0.5], [0.5, 0, 0]]], [[[0, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]], [[0, 0.5, 0], [0, 0, 0.5], [1, 1, 0.5]], [[0, 0, 0.5], [1, 0, 0.5], [1, 1, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]]], [[[0, 0, 0.5], [0.5, 0, 0], [0, 0.5, 0]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[0.5, 1, 0], [1, 0.5, 0], [1, 1, 0.5]]], [[[1, 1, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[1, 1, 0.5], [0.5, 1, 0], [0.5, 0, 1]], [[0.5, 1, 0], [0.5, 0, 0], [0.5, 0, 1]]], [[[0.5, 0, 1], [1, 0.5, 1], [1, 1, 0.5]], [[0, 0, 0.5], [0.5, 0, 1], [1, 1, 0.5]], [[0, 0, 0.5], [1, 1, 0.5], [0.5, 1, 0]], [[0, 0, 0.5], [0.5, 1, 0], [0, 0.5, 0]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]]], [[[0.5, 0, 0], [0, 0.5, 1], [0.5, 0, 1]], [[0.5, 0, 0], [0, 0.5, 0], [0, 0.5, 1]], [[0.5, 1, 0], [1, 0.5, 0], [1, 1, 0.5]]], [[[0.5, 0, 0], [1, 1, 0.5], [0.5, 1, 0]], [[0.5, 0, 0], [1, 0, 0.5], [1, 1, 0.5]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]]], [[[0.5, 0, 1], [1, 0, 0.5], [1, 1, 0.5]], [[0.5, 0, 1], [1, 1, 0.5], [0, 0.5, 0]], [[0.5, 0, 1], [0, 0.5, 0], [0, 0.5, 1]], [[0.5, 1, 0], [0, 0.5, 0], [1, 1, 0.5]]], [[[1, 0.5, 1], [0, 0, 0.5], [0, 0.5, 1]], [[1, 0.5, 1], [1, 0, 0.5], [0, 0, 0.5]], [[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]]], [[[0.5, 1, 0], [1, 0.5, 0], [1, 1, 0.5]], [[0.5, 0, 0], [0, 0.5, 0], [1, 0, 0.5]], [[0, 0.5, 0], [1, 0.5, 1], [1, 0, 0.5]], [[0, 0.5, 0], [0, 0.5, 1], [1, 0.5, 1]]], [[[1, 1, 0.5], [0.5, 1, 0], [0.5, 0, 0]], [[1, 1, 0.5], [0.5, 0, 0], [0, 0.5, 1]], [[1, 1, 0.5], [0, 0.5, 1], [1, 0.5, 1]], [[0, 0.5, 1], [0.5, 0, 0], [0, 0, 0.5]]], [[[1, 1, 0.5], [0.5, 1, 0], [0, 0.5, 0]], [[1, 1, 0.5], [0, 0.5, 0], [1, 0.5, 1]], [[1, 0.5, 1], [0, 0.5, 0], [0, 0.5, 1]]], [[[1, 0.5, 0], [0, 1, 0.5], [0, 0.5, 0]], [[1, 1, 0.5], [0, 1, 0.5], [1, 0.5, 0]]], [[[1, 0.5, 0], [0, 0, 0.5], [0.5, 0, 0]], [[1, 0.5, 0], [1, 1, 0.5], [0, 0, 0.5]], [[1, 1, 0.5], [0, 1, 0.5], [0, 0, 0.5]]], [[[0.5, 0, 0], [0, 1, 0.5], [0, 0.5, 0]], [[0.5, 0, 0], [1, 0, 0.5], [0, 1, 0.5]], [[1, 0, 0.5], [1, 1, 0.5], [0, 1, 0.5]]], [[[1, 0, 0.5], [1, 1, 0.5], [0, 0, 0.5]], [[0, 0, 0.5], [1, 1, 0.5], [0, 1, 0.5]]], [[[1, 0.5, 0], [0, 1, 0.5], [0, 0.5, 0]], [[1, 0.5, 0], [1, 1, 0.5], [0, 1, 0.5]], [[1, 0.5, 1], [1, 0, 0.5], [0.5, 0, 1]]], [[[1, 0.5, 1], [1, 0, 0.5], [0.5, 0, 1]], [[1, 0.5, 0], [1, 1, 0.5], [0.5, 0, 0]], [[1, 1, 0.5], [0, 0, 0.5], [0.5, 0, 0]], [[1, 1, 0.5], [0, 1, 0.5], [0, 0, 0.5]]], [[[0, 0.5, 0], [0.5, 0, 0], [0.5, 0, 1]], [[0, 0.5, 0], [0.5, 0, 1], [1, 1, 0.5]], [[0, 0.5, 0], [1, 1, 0.5], [0, 1, 0.5]], [[1, 0.5, 1], [1, 1, 0.5], [0.5, 0, 1]]], [[[0.5, 0, 1], [1, 0.5, 1], [1, 1, 0.5]], [[0.5, 0, 1], [1, 1, 0.5], [0, 0, 0.5]], [[0, 0, 0.5], [1, 1, 0.5], [0, 1, 0.5]]], [[[0, 1, 0.5], [1, 0.5, 0], [1, 1, 0.5]], [[0, 1, 0.5], [0, 0.5, 0], [1, 0.5, 0]], [[0, 0, 0.5], [0, 0.5, 1], [0.5, 0, 1]]], [[[1, 0.5, 0], [1, 1, 0.5], [0, 1, 0.5]], [[1, 0.5, 0], [0, 1, 0.5], [0.5, 0, 1]], [[1, 0.5, 0], [0.5, 0, 1], [0.5, 0, 0]], [[0.5, 0, 1], [0, 1, 0.5], [0, 0.5, 1]]], [[[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]], [[0.5, 0, 0], [1, 0, 0.5], [0, 0.5, 0]], [[1, 0, 0.5], [0, 1, 0.5], [0, 0.5, 0]], [[1, 0, 0.5], [1, 1, 0.5], [0, 1, 0.5]]], [[[0, 0.5, 1], [0.5, 0, 1], [1, 0, 0.5]], [[0, 0.5, 1], [1, 0, 0.5], [0, 1, 0.5]], [[0, 1, 0.5], [1, 0, 0.5], [1, 1, 0.5]]], [[[1, 0.5, 0], [1, 1, 0.5], [0, 0.5, 0]], [[0, 0.5, 0], [1, 1, 0.5], [0, 1, 0.5]], [[1, 0.5, 1], [1, 0, 0.5], [0, 0, 0.5]], [[1, 0.5, 1], [0, 0, 0.5], [0, 0.5, 1]]], [[[1, 1, 0.5], [0, 1, 0.5], [0.5, 0, 0]], [[1, 1, 0.5], [0.5, 0, 0], [1, 0.5, 0]], [[0, 1, 0.5], [0, 0.5, 1], [0.5, 0, 0]], [[1, 0, 0.5], [0.5, 0, 0], [1, 0.5, 1]], [[0, 0.5, 1], [1, 0.5, 1], [0.5, 0, 0]]], [[[0, 0.5, 1], [1, 0.5, 1], [0.5, 0, 0]], [[0, 0.5, 1], [0.5, 0, 0], [0, 0, 0.5]], [[1, 0.5, 1], [1, 1, 0.5], [0.5, 0, 0]], [[0, 0.5, 0], [0.5, 0, 0], [0, 1, 0.5]], [[1, 1, 0.5], [0, 1, 0.5], [0.5, 0, 0]]], [[[0, 0.5, 1], [1, 0.5, 1], [1, 1, 0.5]], [[0, 1, 0.5], [0, 0.5, 1], [1, 1, 0.5]]], [[[1, 0.5, 1], [0.5, 1, 1], [1, 1, 0.5]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]]], [[[1, 0.5, 0], [0.5, 0, 0], [1, 0, 0.5]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]]], [[[1, 0, 0.5], [0, 0.5, 0], [0, 0, 0.5]], [[1, 0, 0.5], [1, 0.5, 0], [0, 0.5, 0]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]]], [[[1, 0, 0.5], [0.5, 1, 1], [1, 1, 0.5]], [[0.5, 0, 1], [0.5, 1, 1], [1, 0, 0.5]]], [[[1, 0, 0.5], [0.5, 1, 1], [1, 1, 0.5]], [[1, 0, 0.5], [0.5, 0, 1], [0.5, 1, 1]], [[0, 0, 0.5], [0.5, 0, 0], [0, 0.5, 0]]], [[[1, 0.5, 0], [0.5, 1, 1], [1, 1, 0.5]], [[1, 0.5, 0], [0.5, 0, 0], [0.5, 1, 1]], [[0.5, 0, 0], [0.5, 0, 1], [0.5, 1, 1]]], [[[1, 1, 0.5], [1, 0.5, 0], [0, 0.5, 0]], [[1, 1, 0.5], [0, 0.5, 0], [0.5, 0, 1]], [[1, 1, 0.5], [0.5, 0, 1], [0.5, 1, 1]], [[0, 0, 0.5], [0.5, 0, 1], [0, 0.5, 0]]], [[[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]], [[1, 0.5, 1], [0.5, 1, 1], [1, 1, 0.5]]], [[[0, 0.5, 1], [0.5, 0, 0], [0, 0.5, 0]], [[0, 0.5, 1], [0.5, 0, 1], [0.5, 0, 0]], [[1, 0.5, 1], [0.5, 1, 1], [1, 1, 0.5]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]]], [[[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]], [[1, 0, 0.5], [1, 0.5, 0], [0.5, 0, 1]], [[1, 0.5, 0], [0, 0.5, 1], [0.5, 0, 1]], [[1, 0.5, 0], [0, 0.5, 0], [0, 0.5, 1]]], [[[0.5, 1, 1], [0, 0, 0.5], [0, 0.5, 1]], [[0.5, 1, 1], [1, 1, 0.5], [0, 0, 0.5]], [[1, 1, 0.5], [1, 0, 0.5], [0, 0, 0.5]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0.5, 1]], [[0.5, 0, 0], [0, 0.5, 1], [1, 1, 0.5]], [[0.5, 0, 0], [1, 1, 0.5], [1, 0, 0.5]], [[1, 1, 0.5], [0, 0.5, 1], [0.5, 1, 1]]], [[[0, 0, 0.5], [0, 0.5, 1], [0.5, 1, 1]], [[0.5, 0, 0], [0, 0, 0.5], [0.5, 1, 1]], [[0.5, 0, 0], [0.5, 1, 1], [1, 1, 0.5]], [[0.5, 0, 0], [1, 1, 0.5], [1, 0.5, 0]]], [[[0.5, 1, 1], [1, 1, 0.5], [1, 0.5, 0]], [[0.5, 1, 1], [1, 0.5, 0], [0, 0.5, 1]], [[0, 0.5, 1], [1, 0.5, 0], [0, 0.5, 0]]], [[[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]], [[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 0]]], [[[0.5, 1, 0], [0, 0, 0.5], [0.5, 0, 0]], [[0.5, 1, 0], [0, 1, 0.5], [0, 0, 0.5]], [[0.5, 1, 1], [1, 1, 0.5], [1, 0.5, 1]]], [[[1, 0, 0.5], [1, 0.5, 0], [0.5, 0, 0]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]], [[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]]], [[[1, 0.5, 1], [0.5, 1, 1], [1, 1, 0.5]], [[1, 0, 0.5], [1, 0.5, 0], [0, 1, 0.5]], [[1, 0, 0.5], [0, 1, 0.5], [0, 0, 0.5]], [[0, 1, 0.5], [1, 0.5, 0], [0.5, 1, 0]]], [[[0.5, 1, 1], [1, 0, 0.5], [0.5, 0, 1]], [[0.5, 1, 1], [1, 1, 0.5], [1, 0, 0.5]], [[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 0]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 1, 0.5]], [[1, 1, 0.5], [0.5, 0, 1], [0.5, 1, 1]], [[0, 0, 0.5], [0.5, 0, 0], [0.5, 1, 0]], [[0, 0, 0.5], [0.5, 1, 0], [0, 1, 0.5]]], [[[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]], [[1, 0.5, 0], [0.5, 0, 0], [1, 1, 0.5]], [[0.5, 0, 0], [0.5, 1, 1], [1, 1, 0.5]], [[0.5, 0, 0], [0.5, 0, 1], [0.5, 1, 1]]], [[[0, 1, 0.5], [0, 0, 0.5], [1, 0.5, 0]], [[0, 1, 0.5], [1, 0.5, 0], [0.5, 1, 0]], [[0, 0, 0.5], [0.5, 0, 1], [1, 0.5, 0]], [[1, 1, 0.5], [1, 0.5, 0], [0.5, 1, 1]], [[0.5, 0, 1], [0.5, 1, 1], [1, 0.5, 0]]], [[[0, 0, 0.5], [0, 0.5, 1], [0.5, 0, 1]], [[0, 1, 0.5], [0, 0.5, 0], [0.5, 1, 0]], [[1, 0.5, 1], [0.5, 1, 1], [1, 1, 0.5]]], [[[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]], [[0.5, 1, 0], [0, 1, 0.5], [0.5, 0, 1]], [[0.5, 1, 0], [0.5, 0, 1], [0.5, 0, 0]], [[0.5, 0, 1], [0, 1, 0.5], [0, 0.5, 1]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0.5, 1, 0], [0, 1, 0.5], [0, 0.5, 0]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]]], [[[1, 0.5, 0], [0.5, 0, 1], [1, 0, 0.5]], [[1, 0.5, 0], [0, 0.5, 1], [0.5, 0, 1]], [[1, 0.5, 0], [0.5, 1, 0], [0, 0.5, 1]], [[0, 1, 0.5], [0, 0.5, 1], [0.5, 1, 0]], [[1, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]]], [[[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]], [[0, 0, 0.5], [0, 0.5, 1], [1, 1, 0.5]], [[0, 0, 0.5], [1, 1, 0.5], [1, 0, 0.5]], [[1, 1, 0.5], [0, 0.5, 1], [0.5, 1, 1]]], [[[1, 1, 0.5], [1, 0, 0.5], [0, 0.5, 1]], [[1, 1, 0.5], [0, 0.5, 1], [0.5, 1, 1]], [[1, 0, 0.5], [0.5, 0, 0], [0, 0.5, 1]], [[0, 1, 0.5], [0, 0.5, 1], [0.5, 1, 0]], [[0.5, 0, 0], [0.5, 1, 0], [0, 0.5, 1]]], [[[0.5, 0, 0], [1, 1, 0.5], [1, 0.5, 0]], [[0.5, 0, 0], [0.5, 1, 1], [1, 1, 0.5]], [[0.5, 0, 0], [0, 0, 0.5], [0.5, 1, 1]], [[0, 0.5, 1], [0.5, 1, 1], [0, 0, 0.5]], [[0, 0.5, 0], [0.5, 1, 0], [0, 1, 0.5]]], [[[0.5, 1, 1], [1, 1, 0.5], [1, 0.5, 0]], [[0.5, 1, 1], [1, 0.5, 0], [0, 0.5, 1]], [[0.5, 1, 0], [0, 1, 0.5], [1, 0.5, 0]], [[0, 1, 0.5], [0, 0.5, 1], [1, 0.5, 0]]], [[[1, 0.5, 1], [0.5, 1, 0], [1, 0.5, 0]], [[0.5, 1, 1], [0.5, 1, 0], [1, 0.5, 1]]], [[[0.5, 1, 0], [1, 0.5, 1], [0.5, 1, 1]], [[0.5, 1, 0], [1, 0.5, 0], [1, 0.5, 1]], [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]]], [[[1, 0.5, 1], [0.5, 0, 0], [1, 0, 0.5]], [[1, 0.5, 1], [0.5, 1, 1], [0.5, 0, 0]], [[0.5, 1, 1], [0.5, 1, 0], [0.5, 0, 0]]], [[[0, 0.5, 0], [0, 0, 0.5], [1, 0, 0.5]], [[0, 0.5, 0], [1, 0, 0.5], [0.5, 1, 1]], [[0, 0.5, 0], [0.5, 1, 1], [0.5, 1, 0]], [[0.5, 1, 1], [1, 0, 0.5], [1, 0.5, 1]]], [[[1, 0, 0.5], [0.5, 1, 0], [1, 0.5, 0]], [[1, 0, 0.5], [0.5, 0, 1], [0.5, 1, 0]], [[0.5, 0, 1], [0.5, 1, 1], [0.5, 1, 0]]], [[[0, 0, 0.5], [0.5, 0, 0], [0, 0.5, 0]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 0]], [[0.5, 0, 1], [0.5, 1, 0], [1, 0.5, 0]], [[0.5, 0, 1], [0.5, 1, 1], [0.5, 1, 0]]], [[[0.5, 0, 0], [0.5, 0, 1], [0.5, 1, 0]], [[0.5, 1, 0], [0.5, 0, 1], [0.5, 1, 1]]], [[[0, 0.5, 0], [0, 0, 0.5], [0.5, 0, 1]], [[0, 0.5, 0], [0.5, 0, 1], [0.5, 1, 0]], [[0.5, 1, 0], [0.5, 0, 1], [0.5, 1, 1]]], [[[1, 0.5, 1], [0.5, 1, 0], [1, 0.5, 0]], [[1, 0.5, 1], [0.5, 1, 1], [0.5, 1, 0]], [[0, 0.5, 1], [0.5, 0, 1], [0, 0, 0.5]]], [[[0.5, 0, 0], [0, 0.5, 0], [0.5, 0, 1]], [[0.5, 0, 1], [0, 0.5, 0], [0, 0.5, 1]], [[0.5, 1, 0], [1, 0.5, 0], [1, 0.5, 1]], [[0.5, 1, 0], [1, 0.5, 1], [0.5, 1, 1]]], [[[0, 0, 0.5], [0, 0.5, 1], [0.5, 0, 1]], [[0.5, 0, 0], [1, 0, 0.5], [0.5, 1, 1]], [[0.5, 0, 0], [0.5, 1, 1], [0.5, 1, 0]], [[0.5, 1, 1], [1, 0, 0.5], [1, 0.5, 1]]], [[[0.5, 1, 1], [0.5, 1, 0], [1, 0, 0.5]], [[0.5, 1, 1], [1, 0, 0.5], [1, 0.5, 1]], [[0.5, 1, 0], [0, 0.5, 0], [1, 0, 0.5]], [[0.5, 0, 1], [1, 0, 0.5], [0, 0.5, 1]], [[0, 0.5, 0], [0, 0.5, 1], [1, 0, 0.5]]], [[[1, 0.5, 0], [0.5, 1, 1], [0.5, 1, 0]], [[1, 0.5, 0], [0, 0, 0.5], [0.5, 1, 1]], [[1, 0.5, 0], [1, 0, 0.5], [0, 0, 0.5]], [[0, 0.5, 1], [0.5, 1, 1], [0, 0, 0.5]]], [[[0, 0.5, 0], [0, 0.5, 1], [1, 0, 0.5]], [[0, 0.5, 0], [1, 0, 0.5], [0.5, 0, 0]], [[0, 0.5, 1], [0.5, 1, 1], [1, 0, 0.5]], [[1, 0.5, 0], [1, 0, 0.5], [0.5, 1, 0]], [[0.5, 1, 1], [0.5, 1, 0], [1, 0, 0.5]]], [[[0, 0, 0.5], [0, 0.5, 1], [0.5, 1, 1]], [[0, 0, 0.5], [0.5, 1, 1], [0.5, 0, 0]], [[0.5, 0, 0], [0.5, 1, 1], [0.5, 1, 0]]], [[[0.5, 1, 1], [0.5, 1, 0], [0, 0.5, 0]], [[0, 0.5, 1], [0.5, 1, 1], [0, 0.5, 0]]], [[[0, 1, 0.5], [1, 0.5, 1], [0.5, 1, 1]], [[0, 1, 0.5], [0, 0.5, 0], [1, 0.5, 1]], [[0, 0.5, 0], [1, 0.5, 0], [1, 0.5, 1]]], [[[0.5, 0, 0], [0, 1, 0.5], [0, 0, 0.5]], [[0.5, 0, 0], [1, 0.5, 1], [0, 1, 0.5]], [[0.5, 0, 0], [1, 0.5, 0], [1, 0.5, 1]], [[0.5, 1, 1], [0, 1, 0.5], [1, 0.5, 1]]], [[[1, 0.5, 1], [0.5, 1, 1], [0, 1, 0.5]], [[1, 0, 0.5], [1, 0.5, 1], [0, 1, 0.5]], [[1, 0, 0.5], [0, 1, 0.5], [0, 0.5, 0]], [[1, 0, 0.5], [0, 0.5, 0], [0.5, 0, 0]]], [[[1, 0.5, 1], [0.5, 1, 1], [0, 1, 0.5]], [[1, 0.5, 1], [0, 1, 0.5], [1, 0, 0.5]], [[1, 0, 0.5], [0, 1, 0.5], [0, 0, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [0.5, 1, 1]], [[1, 0, 0.5], [0.5, 1, 1], [0, 0.5, 0]], [[1, 0, 0.5], [0, 0.5, 0], [1, 0.5, 0]], [[0, 0.5, 0], [0.5, 1, 1], [0, 1, 0.5]]], [[[0.5, 0, 1], [0.5, 1, 1], [1, 0.5, 0]], [[0.5, 0, 1], [1, 0.5, 0], [1, 0, 0.5]], [[0.5, 1, 1], [0, 1, 0.5], [1, 0.5, 0]], [[0.5, 0, 0], [1, 0.5, 0], [0, 0, 0.5]], [[0, 1, 0.5], [0, 0, 0.5], [1, 0.5, 0]]], [[[0, 1, 0.5], [0, 0.5, 0], [0.5, 0, 0]], [[0, 1, 0.5], [0.5, 0, 0], [0.5, 1, 1]], [[0.5, 1, 1], [0.5, 0, 0], [0.5, 0, 1]]], [[[0, 1, 0.5], [0, 0, 0.5], [0.5, 0, 1]], [[0.5, 1, 1], [0, 1, 0.5], [0.5, 0, 1]]], [[[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]], [[1, 0.5, 1], [0.5, 1, 1], [0, 0.5, 0]], [[1, 0.5, 1], [0, 0.5, 0], [1, 0.5, 0]], [[0, 0.5, 0], [0.5, 1, 1], [0, 1, 0.5]]], [[[0.5, 0, 1], [0.5, 0, 0], [0, 1, 0.5]], [[0.5, 0, 1], [0, 1, 0.5], [0, 0.5, 1]], [[0.5, 0, 0], [1, 0.5, 0], [0, 1, 0.5]], [[0.5, 1, 1], [0, 1, 0.5], [1, 0.5, 1]], [[1, 0.5, 0], [1, 0.5, 1], [0, 1, 0.5]]], [[[1, 0, 0.5], [0, 0.5, 0], [0.5, 0, 0]], [[1, 0, 0.5], [0, 1, 0.5], [0, 0.5, 0]], [[1, 0, 0.5], [1, 0.5, 1], [0, 1, 0.5]], [[0.5, 1, 1], [0, 1, 0.5], [1, 0.5, 1]], [[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 1]]], [[[0, 0.5, 1], [0.5, 0, 1], [1, 0, 0.5]], [[0, 0.5, 1], [1, 0, 0.5], [0, 1, 0.5]], [[1, 0.5, 1], [0.5, 1, 1], [1, 0, 0.5]], [[0.5, 1, 1], [0, 1, 0.5], [1, 0, 0.5]]], [[[0, 0.5, 0], [1, 0.5, 0], [0.5, 1, 1]], [[0, 0.5, 0], [0.5, 1, 1], [0, 1, 0.5]], [[1, 0.5, 0], [1, 0, 0.5], [0.5, 1, 1]], [[0, 0.5, 1], [0.5, 1, 1], [0, 0, 0.5]], [[1, 0, 0.5], [0, 0, 0.5], [0.5, 1, 1]]], [[[0.5, 0, 0], [1, 0.5, 0], [1, 0, 0.5]], [[0, 0.5, 1], [0.5, 1, 1], [0, 1, 0.5]]], [[[0, 1, 0.5], [0, 0.5, 0], [0.5, 0, 0]], [[0, 1, 0.5], [0.5, 0, 0], [0.5, 1, 1]], [[0, 0, 0.5], [0, 0.5, 1], [0.5, 0, 0]], [[0, 0.5, 1], [0.5, 1, 1], [0.5, 0, 0]]], [[[0, 1, 0.5], [0, 0.5, 1], [0.5, 1, 1]]], [[[0, 1, 0.5], [0.5, 1, 1], [0, 0.5, 1]]], [[[0, 0, 0.5], [0.5, 0, 0], [0, 0.5, 0]], [[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]]], [[[0, 0.5, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0, 0.5, 0], [0, 0, 0.5], [1, 0, 0.5]], [[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]]], [[[1, 0.5, 1], [1, 0, 0.5], [0.5, 0, 1]], [[0.5, 1, 1], [0, 0.5, 1], [0, 1, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[0, 0, 0.5], [0.5, 0, 0], [0, 0.5, 0]], [[0.5, 1, 1], [0, 0.5, 1], [0, 1, 0.5]]], [[[0.5, 0, 1], [1, 0.5, 0], [0.5, 0, 0]], [[0.5, 0, 1], [1, 0.5, 1], [1, 0.5, 0]], [[0.5, 1, 1], [0, 0.5, 1], [0, 1, 0.5]]], [[[0.5, 1, 1], [0, 0.5, 1], [0, 1, 0.5]], [[0.5, 0, 1], [1, 0.5, 1], [0, 0, 0.5]], [[1, 0.5, 1], [0, 0.5, 0], [0, 0, 0.5]], [[1, 0.5, 1], [1, 0.5, 0], [0, 0.5, 0]]], [[[0, 1, 0.5], [0.5, 0, 1], [0, 0, 0.5]], [[0.5, 1, 1], [0.5, 0, 1], [0, 1, 0.5]]], [[[0, 1, 0.5], [0.5, 0, 0], [0, 0.5, 0]], [[0, 1, 0.5], [0.5, 1, 1], [0.5, 0, 0]], [[0.5, 1, 1], [0.5, 0, 1], [0.5, 0, 0]]], [[[0.5, 0, 1], [0, 1, 0.5], [0.5, 1, 1]], [[0.5, 0, 1], [0, 0, 0.5], [0, 1, 0.5]], [[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]]], [[[1, 0, 0.5], [0.5, 1, 1], [0.5, 0, 1]], [[1, 0, 0.5], [0, 0.5, 0], [0.5, 1, 1]], [[1, 0, 0.5], [1, 0.5, 0], [0, 0.5, 0]], [[0, 0.5, 0], [0, 1, 0.5], [0.5, 1, 1]]], [[[1, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]], [[1, 0.5, 1], [1, 0, 0.5], [0, 1, 0.5]], [[1, 0, 0.5], [0, 0, 0.5], [0, 1, 0.5]]], [[[1, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]], [[1, 0, 0.5], [0, 1, 0.5], [1, 0.5, 1]], [[1, 0, 0.5], [0, 0.5, 0], [0, 1, 0.5]], [[1, 0, 0.5], [0.5, 0, 0], [0, 0.5, 0]]], [[[0.5, 0, 0], [0, 0, 0.5], [0, 1, 0.5]], [[0.5, 0, 0], [0, 1, 0.5], [1, 0.5, 1]], [[0.5, 0, 0], [1, 0.5, 1], [1, 0.5, 0]], [[0.5, 1, 1], [1, 0.5, 1], [0, 1, 0.5]]], [[[0, 1, 0.5], [0.5, 1, 1], [1, 0.5, 1]], [[0, 1, 0.5], [1, 0.5, 1], [0, 0.5, 0]], [[0, 0.5, 0], [1, 0.5, 1], [1, 0.5, 0]]], [[[0.5, 1, 1], [0, 0.5, 0], [0.5, 1, 0]], [[0, 0.5, 1], [0, 0.5, 0], [0.5, 1, 1]]], [[[0, 0, 0.5], [0.5, 1, 1], [0, 0.5, 1]], [[0, 0, 0.5], [0.5, 0, 0], [0.5, 1, 1]], [[0.5, 0, 0], [0.5, 1, 0], [0.5, 1, 1]]], [[[0, 0.5, 0], [0.5, 1, 1], [0, 0.5, 1]], [[0, 0.5, 0], [0.5, 1, 0], [0.5, 1, 1]], [[1, 0.5, 0], [0.5, 0, 0], [1, 0, 0.5]]], [[[1, 0.5, 0], [0.5, 1, 0], [0.5, 1, 1]], [[1, 0.5, 0], [0.5, 1, 1], [0, 0, 0.5]], [[1, 0.5, 0], [0, 0, 0.5], [1, 0, 0.5]], [[0, 0.5, 1], [0, 0, 0.5], [0.5, 1, 1]]], [[[0.5, 1, 1], [0, 0.5, 0], [0.5, 1, 0]], [[0.5, 1, 1], [0, 0.5, 1], [0, 0.5, 0]], [[0.5, 0, 1], [1, 0.5, 1], [1, 0, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[0, 0, 0.5], [0.5, 0, 0], [0, 0.5, 1]], [[0.5, 0, 0], [0.5, 1, 1], [0, 0.5, 1]], [[0.5, 0, 0], [0.5, 1, 0], [0.5, 1, 1]]], [[[0.5, 1, 0], [0, 0.5, 1], [0, 0.5, 0]], [[0.5, 1, 0], [0.5, 1, 1], [0, 0.5, 1]], [[0.5, 0, 0], [0.5, 0, 1], [1, 0.5, 0]], [[0.5, 0, 1], [1, 0.5, 1], [1, 0.5, 0]]], [[[1, 0.5, 1], [1, 0.5, 0], [0, 0, 0.5]], [[1, 0.5, 1], [0, 0, 0.5], [0.5, 0, 1]], [[1, 0.5, 0], [0.5, 1, 0], [0, 0, 0.5]], [[0, 0.5, 1], [0, 0, 0.5], [0.5, 1, 1]], [[0.5, 1, 0], [0.5, 1, 1], [0, 0, 0.5]]], [[[0, 0.5, 0], [0.5, 0, 1], [0, 0, 0.5]], [[0, 0.5, 0], [0.5, 1, 0], [0.5, 0, 1]], [[0.5, 1, 0], [0.5, 1, 1], [0.5, 0, 1]]], [[[0.5, 0, 0], [0.5, 1, 0], [0.5, 0, 1]], [[0.5, 1, 0], [0.5, 1, 1], [0.5, 0, 1]]], [[[1, 0, 0.5], [1, 0.5, 0], [0.5, 0, 0]], [[0.5, 0, 1], [0, 0, 0.5], [0.5, 1, 0]], [[0.5, 0, 1], [0.5, 1, 0], [0.5, 1, 1]], [[0.5, 1, 0], [0, 0, 0.5], [0, 0.5, 0]]], [[[1, 0, 0.5], [1, 0.5, 0], [0.5, 1, 0]], [[1, 0, 0.5], [0.5, 1, 0], [0.5, 0, 1]], [[0.5, 0, 1], [0.5, 1, 0], [0.5, 1, 1]]], [[[0, 0.5, 0], [1, 0, 0.5], [0, 0, 0.5]], [[0, 0.5, 0], [0.5, 1, 1], [1, 0, 0.5]], [[0, 0.5, 0], [0.5, 1, 0], [0.5, 1, 1]], [[0.5, 1, 1], [1, 0.5, 1], [1, 0, 0.5]]], [[[1, 0.5, 1], [1, 0, 0.5], [0.5, 0, 0]], [[1, 0.5, 1], [0.5, 0, 0], [0.5, 1, 1]], [[0.5, 1, 1], [0.5, 0, 0], [0.5, 1, 0]]], [[[0.5, 1, 0], [0.5, 1, 1], [0, 0, 0.5]], [[0.5, 1, 0], [0, 0, 0.5], [0, 0.5, 0]], [[0.5, 1, 1], [1, 0.5, 1], [0, 0, 0.5]], [[0.5, 0, 0], [0, 0, 0.5], [1, 0.5, 0]], [[1, 0.5, 1], [1, 0.5, 0], [0, 0, 0.5]]], [[[1, 0.5, 1], [1, 0.5, 0], [0.5, 1, 0]], [[0.5, 1, 1], [1, 0.5, 1], [0.5, 1, 0]]], [[[0.5, 1, 0], [1, 0.5, 0], [1, 1, 0.5]], [[0, 1, 0.5], [0.5, 1, 1], [0, 0.5, 1]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], [[0.5, 1, 0], [1, 0.5, 0], [1, 1, 0.5]], [[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]]], [[[1, 1, 0.5], [0.5, 0, 0], [1, 0, 0.5]], [[1, 1, 0.5], [0.5, 1, 0], [0.5, 0, 0]], [[0, 1, 0.5], [0.5, 1, 1], [0, 0.5, 1]]], [[[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]], [[0, 0.5, 0], [0, 0, 0.5], [0.5, 1, 0]], [[0, 0, 0.5], [1, 1, 0.5], [0.5, 1, 0]], [[0, 0, 0.5], [1, 0, 0.5], [1, 1, 0.5]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]], [[1, 0.5, 1], [1, 0, 0.5], [0.5, 0, 1]], [[0, 1, 0.5], [0.5, 1, 1], [0, 0.5, 1]]], [[[0.5, 1, 1], [0, 0.5, 1], [0, 1, 0.5]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], [[0.5, 1, 0], [1, 0.5, 0], [1, 1, 0.5]]], [[[0, 1, 0.5], [0.5, 1, 1], [0, 0.5, 1]], [[1, 1, 0.5], [0.5, 1, 0], [1, 0.5, 1]], [[0.5, 1, 0], [0.5, 0, 1], [1, 0.5, 1]], [[0.5, 1, 0], [0.5, 0, 0], [0.5, 0, 1]]], [[[0, 0, 0.5], [0.5, 1, 0], [0, 0.5, 0]], [[0, 0, 0.5], [1, 1, 0.5], [0.5, 1, 0]], [[0, 0, 0.5], [0.5, 0, 1], [1, 1, 0.5]], [[1, 0.5, 1], [1, 1, 0.5], [0.5, 0, 1]], [[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 1]]], [[[0, 1, 0.5], [0.5, 0, 1], [0, 0, 0.5]], [[0, 1, 0.5], [0.5, 1, 1], [0.5, 0, 1]], [[1, 1, 0.5], [0.5, 1, 0], [1, 0.5, 0]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]], [[0.5, 0, 0], [0, 0.5, 0], [0.5, 1, 1]], [[0.5, 0, 0], [0.5, 1, 1], [0.5, 0, 1]], [[0.5, 1, 1], [0, 0.5, 0], [0, 1, 0.5]]], [[[0, 0, 0.5], [0.5, 1, 1], [0.5, 0, 1]], [[0, 0, 0.5], [0, 1, 0.5], [0.5, 1, 1]], [[1, 0, 0.5], [1, 1, 0.5], [0.5, 0, 0]], [[1, 1, 0.5], [0.5, 1, 0], [0.5, 0, 0]]], [[[0.5, 1, 1], [0.5, 0, 1], [0, 0.5, 0]], [[0.5, 1, 1], [0, 0.5, 0], [0, 1, 0.5]], [[0.5, 0, 1], [1, 0, 0.5], [0, 0.5, 0]], [[0.5, 1, 0], [0, 0.5, 0], [1, 1, 0.5]], [[1, 0, 0.5], [1, 1, 0.5], [0, 0.5, 0]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]], [[1, 0.5, 1], [1, 0, 0.5], [0.5, 1, 1]], [[1, 0, 0.5], [0, 1, 0.5], [0.5, 1, 1]], [[1, 0, 0.5], [0, 0, 0.5], [0, 1, 0.5]]], [[[1, 0, 0.5], [0.5, 1, 1], [1, 0.5, 1]], [[1, 0, 0.5], [0, 1, 0.5], [0.5, 1, 1]], [[1, 0, 0.5], [0.5, 0, 0], [0, 1, 0.5]], [[0, 0.5, 0], [0, 1, 0.5], [0.5, 0, 0]], [[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 0]]], [[[0.5, 1, 0], [0.5, 0, 0], [1, 0.5, 1]], [[0.5, 1, 0], [1, 0.5, 1], [1, 1, 0.5]], [[0.5, 0, 0], [0, 0, 0.5], [1, 0.5, 1]], [[0.5, 1, 1], [1, 0.5, 1], [0, 1, 0.5]], [[0, 0, 0.5], [0, 1, 0.5], [1, 0.5, 1]]], [[[0, 1, 0.5], [0.5, 1, 1], [1, 0.5, 1]], [[0, 1, 0.5], [1, 0.5, 1], [0, 0.5, 0]], [[1, 1, 0.5], [0.5, 1, 0], [1, 0.5, 1]], [[0.5, 1, 0], [0, 0.5, 0], [1, 0.5, 1]]], [[[0.5, 1, 1], [1, 0.5, 0], [1, 1, 0.5]], [[0.5, 1, 1], [0, 0.5, 1], [1, 0.5, 0]], [[0, 0.5, 1], [0, 0.5, 0], [1, 0.5, 0]]], [[[0, 0, 0.5], [0.5, 1, 1], [0, 0.5, 1]], [[0.5, 0, 0], [0.5, 1, 1], [0, 0, 0.5]], [[0.5, 0, 0], [1, 1, 0.5], [0.5, 1, 1]], [[0.5, 0, 0], [1, 0.5, 0], [1, 1, 0.5]]], [[[0.5, 0, 0], [0, 0.5, 1], [0, 0.5, 0]], [[0.5, 0, 0], [1, 1, 0.5], [0, 0.5, 1]], [[0.5, 0, 0], [1, 0, 0.5], [1, 1, 0.5]], [[1, 1, 0.5], [0.5, 1, 1], [0, 0.5, 1]]], [[[0.5, 1, 1], [0, 0.5, 1], [0, 0, 0.5]], [[0.5, 1, 1], [0, 0, 0.5], [1, 1, 0.5]], [[1, 1, 0.5], [0, 0, 0.5], [1, 0, 0.5]]], [[[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]], [[1, 0.5, 0], [1, 1, 0.5], [0, 0.5, 1]], [[1, 0.5, 0], [0, 0.5, 1], [0, 0.5, 0]], [[0, 0.5, 1], [1, 1, 0.5], [0.5, 1, 1]]], [[[0.5, 0, 0], [0, 0.5, 1], [0, 0, 0.5]], [[0.5, 0, 0], [0.5, 1, 1], [0, 0.5, 1]], [[0.5, 0, 0], [1, 0.5, 0], [0.5, 1, 1]], [[1, 1, 0.5], [0.5, 1, 1], [1, 0.5, 0]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 1]]], [[[0, 0.5, 1], [0, 0.5, 0], [1, 1, 0.5]], [[0, 0.5, 1], [1, 1, 0.5], [0.5, 1, 1]], [[0, 0.5, 0], [0.5, 0, 0], [1, 1, 0.5]], [[1, 0.5, 1], [1, 1, 0.5], [0.5, 0, 1]], [[0.5, 0, 0], [0.5, 0, 1], [1, 1, 0.5]]], [[[0.5, 1, 1], [0, 0.5, 1], [0, 0, 0.5]], [[0.5, 1, 1], [0, 0, 0.5], [1, 1, 0.5]], [[0.5, 0, 1], [1, 0.5, 1], [0, 0, 0.5]], [[1, 0.5, 1], [1, 1, 0.5], [0, 0, 0.5]]], [[[1, 1, 0.5], [0, 0.5, 0], [1, 0.5, 0]], [[1, 1, 0.5], [0.5, 0, 1], [0, 0.5, 0]], [[1, 1, 0.5], [0.5, 1, 1], [0.5, 0, 1]], [[0, 0, 0.5], [0, 0.5, 0], [0.5, 0, 1]]], [[[1, 0.5, 0], [1, 1, 0.5], [0.5, 1, 1]], [[1, 0.5, 0], [0.5, 1, 1], [0.5, 0, 0]], [[0.5, 0, 0], [0.5, 1, 1], [0.5, 0, 1]]], [[[1, 0, 0.5], [1, 1, 0.5], [0, 0.5, 0]], [[1, 0, 0.5], [0, 0.5, 0], [0.5, 0, 0]], [[1, 1, 0.5], [0.5, 1, 1], [0, 0.5, 0]], [[0, 0, 0.5], [0, 0.5, 0], [0.5, 0, 1]], [[0.5, 1, 1], [0.5, 0, 1], [0, 0.5, 0]]], [[[1, 0, 0.5], [1, 1, 0.5], [0.5, 1, 1]], [[0.5, 0, 1], [1, 0, 0.5], [0.5, 1, 1]]], [[[1, 0, 0.5], [0, 0, 0.5], [0.5, 1, 1]], [[1, 0, 0.5], [0.5, 1, 1], [1, 0.5, 1]], [[0, 0, 0.5], [0, 0.5, 0], [0.5, 1, 1]], [[1, 1, 0.5], [0.5, 1, 1], [1, 0.5, 0]], [[0, 0.5, 0], [1, 0.5, 0], [0.5, 1, 1]]], [[[1, 0.5, 1], [1, 0, 0.5], [0.5, 0, 0]], [[1, 0.5, 1], [0.5, 0, 0], [0.5, 1, 1]], [[1, 0.5, 0], [1, 1, 0.5], [0.5, 0, 0]], [[1, 1, 0.5], [0.5, 1, 1], [0.5, 0, 0]]], [[[0.5, 0, 0], [0, 0, 0.5], [0, 0.5, 0]], [[1, 1, 0.5], [0.5, 1, 1], [1, 0.5, 1]]], [[[1, 0.5, 1], [1, 1, 0.5], [0.5, 1, 1]]], [[[0, 0.5, 1], [1, 1, 0.5], [1, 0.5, 1]], [[0, 1, 0.5], [1, 1, 0.5], [0, 0.5, 1]]], [[[0, 0.5, 1], [1, 1, 0.5], [1, 0.5, 1]], [[0, 0.5, 1], [0, 1, 0.5], [1, 1, 0.5]], [[0, 0.5, 0], [0, 0, 0.5], [0.5, 0, 0]]], [[[1, 1, 0.5], [0, 0.5, 1], [0, 1, 0.5]], [[1, 1, 0.5], [1, 0.5, 1], [0, 0.5, 1]], [[1, 0, 0.5], [1, 0.5, 0], [0.5, 0, 0]]], [[[1, 0.5, 1], [0, 1, 0.5], [1, 1, 0.5]], [[1, 0.5, 1], [0, 0.5, 1], [0, 1, 0.5]], [[1, 0.5, 0], [0, 0.5, 0], [1, 0, 0.5]], [[0, 0.5, 0], [0, 0, 0.5], [1, 0, 0.5]]], [[[0, 0.5, 1], [1, 0, 0.5], [0.5, 0, 1]], [[0, 0.5, 1], [0, 1, 0.5], [1, 0, 0.5]], [[0, 1, 0.5], [1, 1, 0.5], [1, 0, 0.5]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], [[1, 0, 0.5], [0.5, 0, 1], [0, 1, 0.5]], [[1, 0, 0.5], [0, 1, 0.5], [1, 1, 0.5]], [[0, 1, 0.5], [0.5, 0, 1], [0, 0.5, 1]]], [[[1, 0.5, 0], [0, 1, 0.5], [1, 1, 0.5]], [[1, 0.5, 0], [0.5, 0, 1], [0, 1, 0.5]], [[1, 0.5, 0], [0.5, 0, 0], [0.5, 0, 1]], [[0.5, 0, 1], [0, 0.5, 1], [0, 1, 0.5]]], [[[0, 1, 0.5], [1, 1, 0.5], [0.5, 0, 1]], [[0, 1, 0.5], [0.5, 0, 1], [0, 0.5, 1]], [[1, 1, 0.5], [1, 0.5, 0], [0.5, 0, 1]], [[0, 0, 0.5], [0.5, 0, 1], [0, 0.5, 0]], [[1, 0.5, 0], [0, 0.5, 0], [0.5, 0, 1]]], [[[0.5, 0, 1], [1, 1, 0.5], [1, 0.5, 1]], [[0.5, 0, 1], [0, 0, 0.5], [1, 1, 0.5]], [[0, 0, 0.5], [0, 1, 0.5], [1, 1, 0.5]]], [[[0, 0.5, 0], [0.5, 0, 1], [0.5, 0, 0]], [[0, 0.5, 0], [1, 1, 0.5], [0.5, 0, 1]], [[0, 0.5, 0], [0, 1, 0.5], [1, 1, 0.5]], [[1, 0.5, 1], [0.5, 0, 1], [1, 1, 0.5]]], [[[1, 0.5, 0], [0.5, 0, 0], [1, 0, 0.5]], [[1, 1, 0.5], [1, 0.5, 1], [0, 0, 0.5]], [[1, 1, 0.5], [0, 0, 0.5], [0, 1, 0.5]], [[0, 0, 0.5], [1, 0.5, 1], [0.5, 0, 1]]], [[[1, 0.5, 0], [0, 0.5, 0], [0.5, 0, 1]], [[1, 0.5, 0], [0.5, 0, 1], [1, 0, 0.5]], [[0, 0.5, 0], [0, 1, 0.5], [0.5, 0, 1]], [[1, 0.5, 1], [0.5, 0, 1], [1, 1, 0.5]], [[0, 1, 0.5], [1, 1, 0.5], [0.5, 0, 1]]], [[[1, 0, 0.5], [0, 0, 0.5], [1, 1, 0.5]], [[0, 0, 0.5], [0, 1, 0.5], [1, 1, 0.5]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 1, 0.5]], [[0.5, 0, 0], [0, 1, 0.5], [1, 0, 0.5]], [[1, 0, 0.5], [0, 1, 0.5], [1, 1, 0.5]]], [[[1, 0.5, 0], [0.5, 0, 0], [0, 0, 0.5]], [[1, 0.5, 0], [0, 0, 0.5], [1, 1, 0.5]], [[1, 1, 0.5], [0, 0, 0.5], [0, 1, 0.5]]], [[[1, 0.5, 0], [0, 0.5, 0], [0, 1, 0.5]], [[1, 1, 0.5], [1, 0.5, 0], [0, 1, 0.5]]], [[[1, 1, 0.5], [0, 0.5, 0], [0.5, 1, 0]], [[1, 1, 0.5], [1, 0.5, 1], [0, 0.5, 0]], [[1, 0.5, 1], [0, 0.5, 1], [0, 0.5, 0]]], [[[1, 1, 0.5], [0.5, 0, 0], [0.5, 1, 0]], [[1, 1, 0.5], [0, 0.5, 1], [0.5, 0, 0]], [[1, 1, 0.5], [1, 0.5, 1], [0, 0.5, 1]], [[0, 0.5, 1], [0, 0, 0.5], [0.5, 0, 0]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]], [[0, 0.5, 0], [0.5, 1, 0], [1, 0.5, 1]], [[0, 0.5, 0], [1, 0.5, 1], [0, 0.5, 1]], [[1, 0.5, 1], [0.5, 1, 0], [1, 1, 0.5]]], [[[1, 0.5, 1], [0, 0.5, 1], [0.5, 1, 0]], [[1, 0.5, 1], [0.5, 1, 0], [1, 1, 0.5]], [[0, 0.5, 1], [0, 0, 0.5], [0.5, 1, 0]], [[1, 0.5, 0], [0.5, 1, 0], [1, 0, 0.5]], [[0, 0, 0.5], [1, 0, 0.5], [0.5, 1, 0]]], [[[0.5, 0, 1], [1, 1, 0.5], [1, 0, 0.5]], [[0.5, 0, 1], [0, 0.5, 0], [1, 1, 0.5]], [[0.5, 0, 1], [0, 0.5, 1], [0, 0.5, 0]], [[0.5, 1, 0], [1, 1, 0.5], [0, 0.5, 0]]], [[[0.5, 0, 0], [0.5, 1, 0], [0, 0.5, 1]], [[0.5, 0, 0], [0, 0.5, 1], [0, 0, 0.5]], [[0.5, 1, 0], [1, 1, 0.5], [0, 0.5, 1]], [[0.5, 0, 1], [0, 0.5, 1], [1, 0, 0.5]], [[1, 1, 0.5], [1, 0, 0.5], [0, 0.5, 1]]], [[[0.5, 0, 0], [0.5, 0, 1], [1, 1, 0.5]], [[0.5, 0, 0], [1, 1, 0.5], [1, 0.5, 0]], [[0.5, 0, 1], [0, 0.5, 1], [1, 1, 0.5]], [[0.5, 1, 0], [1, 1, 0.5], [0, 0.5, 0]], [[0, 0.5, 1], [0, 0.5, 0], [1, 1, 0.5]]], [[[1, 0.5, 0], [0.5, 1, 0], [1, 1, 0.5]], [[0.5, 0, 1], [0, 0.5, 1], [0, 0, 0.5]]], [[[0.5, 0, 1], [1, 1, 0.5], [1, 0.5, 1]], [[0, 0, 0.5], [1, 1, 0.5], [0.5, 0, 1]], [[0, 0, 0.5], [0.5, 1, 0], [1, 1, 0.5]], [[0, 0, 0.5], [0, 0.5, 0], [0.5, 1, 0]]], [[[1, 1, 0.5], [1, 0.5, 1], [0.5, 0, 1]], [[1, 1, 0.5], [0.5, 0, 1], [0.5, 1, 0]], [[0.5, 1, 0], [0.5, 0, 1], [0.5, 0, 0]]], [[[0, 0, 0.5], [1, 0.5, 1], [0.5, 0, 1]], [[0, 0, 0.5], [1, 1, 0.5], [1, 0.5, 1]], [[0, 0, 0.5], [0, 0.5, 0], [1, 1, 0.5]], [[0.5, 1, 0], [1, 1, 0.5], [0, 0.5, 0]], [[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 0]]], [[[1, 1, 0.5], [1, 0.5, 1], [0.5, 0, 1]], [[1, 1, 0.5], [0.5, 0, 1], [0.5, 1, 0]], [[1, 0, 0.5], [1, 0.5, 0], [0.5, 0, 1]], [[1, 0.5, 0], [0.5, 1, 0], [0.5, 0, 1]]], [[[0, 0.5, 0], [0.5, 1, 0], [1, 1, 0.5]], [[0, 0.5, 0], [1, 1, 0.5], [0, 0, 0.5]], [[0, 0, 0.5], [1, 1, 0.5], [1, 0, 0.5]]], [[[0.5, 0, 0], [0.5, 1, 0], [1, 1, 0.5]], [[1, 0, 0.5], [0.5, 0, 0], [1, 1, 0.5]]], [[[0, 0.5, 0], [0.5, 1, 0], [1, 1, 0.5]], [[0, 0.5, 0], [1, 1, 0.5], [0, 0, 0.5]], [[1, 0.5, 0], [0.5, 0, 0], [1, 1, 0.5]], [[0.5, 0, 0], [0, 0, 0.5], [1, 1, 0.5]]], [[[1, 0.5, 0], [0.5, 1, 0], [1, 1, 0.5]]], [[[0.5, 1, 0], [0, 0.5, 1], [0, 1, 0.5]], [[0.5, 1, 0], [1, 0.5, 0], [0, 0.5, 1]], [[1, 0.5, 0], [1, 0.5, 1], [0, 0.5, 1]]], [[[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], [[0.5, 1, 0], [1, 0.5, 0], [0, 1, 0.5]], [[1, 0.5, 0], [0, 0.5, 1], [0, 1, 0.5]], [[1, 0.5, 0], [1, 0.5, 1], [0, 0.5, 1]]], [[[1, 0, 0.5], [1, 0.5, 1], [0, 0.5, 1]], [[1, 0, 0.5], [0, 0.5, 1], [0.5, 1, 0]], [[1, 0, 0.5], [0.5, 1, 0], [0.5, 0, 0]], [[0, 1, 0.5], [0.5, 1, 0], [0, 0.5, 1]]], [[[0, 0, 0.5], [1, 0, 0.5], [0.5, 1, 0]], [[0, 0, 0.5], [0.5, 1, 0], [0, 0.5, 0]], [[1, 0, 0.5], [1, 0.5, 1], [0.5, 1, 0]], [[0, 1, 0.5], [0.5, 1, 0], [0, 0.5, 1]], [[1, 0.5, 1], [0, 0.5, 1], [0.5, 1, 0]]], [[[0.5, 1, 0], [0, 0.5, 1], [0, 1, 0.5]], [[1, 0.5, 0], [0, 0.5, 1], [0.5, 1, 0]], [[1, 0.5, 0], [0.5, 0, 1], [0, 0.5, 1]], [[1, 0.5, 0], [1, 0, 0.5], [0.5, 0, 1]]], [[[1, 0.5, 0], [0, 1, 0.5], [0.5, 1, 0]], [[1, 0.5, 0], [0, 0.5, 1], [0, 1, 0.5]], [[1, 0.5, 0], [1, 0, 0.5], [0, 0.5, 1]], [[0.5, 0, 1], [0, 0.5, 1], [1, 0, 0.5]], [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]]], [[[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 0]], [[0, 0.5, 1], [0.5, 1, 0], [0.5, 0, 1]], [[0.5, 0, 1], [0.5, 1, 0], [0.5, 0, 0]]], [[[0, 0.5, 1], [0, 1, 0.5], [0.5, 1, 0]], [[0, 0.5, 1], [0.5, 1, 0], [0.5, 0, 1]], [[0, 0.5, 0], [0, 0, 0.5], [0.5, 1, 0]], [[0, 0, 0.5], [0.5, 0, 1], [0.5, 1, 0]]], [[[0.5, 0, 1], [1, 0.5, 0], [1, 0.5, 1]], [[0.5, 0, 1], [0, 1, 0.5], [1, 0.5, 0]], [[0.5, 0, 1], [0, 0, 0.5], [0, 1, 0.5]], [[0, 1, 0.5], [0.5, 1, 0], [1, 0.5, 0]]], [[[1, 0.5, 0], [1, 0.5, 1], [0, 1, 0.5]], [[1, 0.5, 0], [0, 1, 0.5], [0.5, 1, 0]], [[1, 0.5, 1], [0.5, 0, 1], [0, 1, 0.5]], [[0, 0.5, 0], [0, 1, 0.5], [0.5, 0, 0]], [[0.5, 0, 1], [0.5, 0, 0], [0, 1, 0.5]]], [[[0, 0, 0.5], [0, 1, 0.5], [1, 0.5, 1]], [[0, 0, 0.5], [1, 0.5, 1], [0.5, 0, 1]], [[0, 1, 0.5], [0.5, 1, 0], [1, 0.5, 1]], [[1, 0, 0.5], [1, 0.5, 1], [0.5, 0, 0]], [[0.5, 1, 0], [0.5, 0, 0], [1, 0.5, 1]]], [[[1, 0, 0.5], [1, 0.5, 1], [0.5, 0, 1]], [[0, 0.5, 0], [0, 1, 0.5], [0.5, 1, 0]]], [[[0.5, 1, 0], [1, 0.5, 0], [1, 0, 0.5]], [[0.5, 1, 0], [1, 0, 0.5], [0, 1, 0.5]], [[0, 1, 0.5], [1, 0, 0.5], [0, 0, 0.5]]], [[[0.5, 1, 0], [1, 0.5, 0], [1, 0, 0.5]], [[0.5, 1, 0], [1, 0, 0.5], [0, 1, 0.5]], [[0.5, 0, 0], [0, 0.5, 0], [1, 0, 0.5]], [[0, 0.5, 0], [0, 1, 0.5], [1, 0, 0.5]]], [[[0.5, 1, 0], [0.5, 0, 0], [0, 0, 0.5]], [[0, 1, 0.5], [0.5, 1, 0], [0, 0, 0.5]]], [[[0.5, 1, 0], [0, 0.5, 0], [0, 1, 0.5]]], [[[1, 0.5, 0], [1, 0.5, 1], [0, 0.5, 0]], [[1, 0.5, 1], [0, 0.5, 1], [0, 0.5, 0]]], [[[0, 0, 0.5], [0.5, 0, 0], [1, 0.5, 0]], [[0, 0, 0.5], [1, 0.5, 0], [0, 0.5, 1]], [[0, 0.5, 1], [1, 0.5, 0], [1, 0.5, 1]]], [[[0.5, 0, 0], [1, 0, 0.5], [1, 0.5, 1]], [[0.5, 0, 0], [1, 0.5, 1], [0, 0.5, 0]], [[0, 0.5, 0], [1, 0.5, 1], [0, 0.5, 1]]], [[[0, 0, 0.5], [1, 0, 0.5], [1, 0.5, 1]], [[0, 0.5, 1], [0, 0, 0.5], [1, 0.5, 1]]], [[[1, 0, 0.5], [0.5, 0, 1], [0, 0.5, 1]], [[1, 0, 0.5], [0, 0.5, 1], [1, 0.5, 0]], [[1, 0.5, 0], [0, 0.5, 1], [0, 0.5, 0]]], [[[0, 0, 0.5], [0.5, 0, 0], [1, 0.5, 0]], [[0, 0, 0.5], [1, 0.5, 0], [0, 0.5, 1]], [[1, 0, 0.5], [0.5, 0, 1], [1, 0.5, 0]], [[0.5, 0, 1], [0, 0.5, 1], [1, 0.5, 0]]], [[[0.5, 0, 0], [0.5, 0, 1], [0, 0.5, 1]], [[0, 0.5, 0], [0.5, 0, 0], [0, 0.5, 1]]], [[[0, 0, 0.5], [0.5, 0, 1], [0, 0.5, 1]]], [[[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 0]], [[0.5, 0, 1], [0, 0.5, 0], [1, 0.5, 1]], [[1, 0.5, 1], [0, 0.5, 0], [1, 0.5, 0]]], [[[1, 0.5, 0], [1, 0.5, 1], [0.5, 0, 1]], [[0.5, 0, 0], [1, 0.5, 0], [0.5, 0, 1]]], [[[0.5, 0, 1], [0, 0, 0.5], [0, 0.5, 0]], [[0.5, 0, 1], [0, 0.5, 0], [1, 0.5, 1]], [[0.5, 0, 0], [1, 0, 0.5], [0, 0.5, 0]], [[1, 0, 0.5], [1, 0.5, 1], [0, 0.5, 0]]], [[[1, 0, 0.5], [1, 0.5, 1], [0.5, 0, 1]]], [[[1, 0, 0.5], [0, 0, 0.5], [0, 0.5, 0]], [[1, 0.5, 0], [1, 0, 0.5], [0, 0.5, 0]]], [[[0.5, 0, 0], [1, 0.5, 0], [1, 0, 0.5]]], [[[0.5, 0, 0], [0, 0, 0.5], [0, 0.5, 0]]], []];
	
	module.exports = tlt;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {var UrlManager, V3, app, backbone, constants,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	app = __webpack_require__(48);
	
	backbone = __webpack_require__(3);
	
	constants = __webpack_require__(61);
	
	V3 = __webpack_require__(189).V3;
	
	UrlManager = (function() {
	  UrlManager.prototype.MAX_UPDATE_INTERVAL = 1000;
	
	  function UrlManager(model) {
	    this.model = model;
	    this.baseUrl = document.location.pathname + document.location.search;
	    this.initialState = this.parseUrl();
	    this.update = _.throttle((function(_this) {
	      return function() {
	        return location.replace(_this.buildUrl());
	      };
	    })(this), this.MAX_UPDATE_INTERVAL);
	    _.extend(this, Backbone.Events);
	  }
	
	  UrlManager.prototype.parseUrl = function() {
	    var state, stateArray, stateString;
	    stateString = location.hash.slice(1);
	    state = {};
	    if (stateString) {
	      stateArray = stateString.split(",");
	      if (stateArray.length >= 5) {
	        state.position = _.map(stateArray.slice(0, 3), function(e) {
	          return +e;
	        });
	        state.mode = +stateArray[3];
	        state.zoomStep = +stateArray[4];
	        if (stateArray.length >= 8) {
	          state.rotation = _.map(stateArray.slice(5, 8), function(e) {
	            return +e;
	          });
	          if (stateArray[8] != null) {
	            state.activeNode = +stateArray[8];
	          }
	        } else {
	          if (stateArray[5] != null) {
	            state.activeNode = +stateArray[5];
	          }
	        }
	      }
	    }
	    return state;
	  };
	
	  UrlManager.prototype.startUrlUpdater = function() {
	    this.listenTo(this.model.flycam, "changed", this.update);
	    this.listenTo(this.model.flycam3d, "changed", this.update);
	    this.listenTo(this.model, "change:mode", this.update);
	    if (this.model.skeletonTracing) {
	      return this.listenTo(this.model.skeletonTracing, "newActiveNode", this.update);
	    }
	  };
	
	  UrlManager.prototype.buildUrl = function() {
	    var flycam, flycam3d, ref, ref1, ref2, state;
	    ref = this.model, flycam = ref.flycam, flycam3d = ref.flycam3d;
	    state = V3.floor(flycam.getPosition());
	    state.push(this.model.mode);
	    if (ref1 = this.model.mode, indexOf.call(constants.MODES_ARBITRARY, ref1) >= 0) {
	      state = state.concat([flycam3d.getZoomStep().toFixed(2)]).concat(_.map(flycam3d.getRotation(), function(e) {
	        return e.toFixed(2);
	      }));
	    } else {
	      state = state.concat([flycam.getZoomStep().toFixed(2)]);
	    }
	    if (((ref2 = this.model.skeletonTracing) != null ? ref2.getActiveNodeId() : void 0) != null) {
	      state.push(this.model.skeletonTracing.getActiveNodeId());
	    }
	    return this.baseUrl + "#" + state.join(",");
	  };
	
	  return UrlManager;
	
	})();
	
	module.exports = UrlManager;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var $, SkeletonTracingView, Toast, View, _, modal,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	$ = __webpack_require__(1);
	
	_ = __webpack_require__(2);
	
	Toast = __webpack_require__(18);
	
	modal = __webpack_require__(307);
	
	View = __webpack_require__(306);
	
	SkeletonTracingView = (function(superClass) {
	  extend(SkeletonTracingView, superClass);
	
	  function SkeletonTracingView(model) {
	    var autoSaveFailureMessage;
	    this.model = model;
	    SkeletonTracingView.__super__.constructor.call(this, this.model);
	    _.extend(this, Backbone.Events);
	    this.listenTo(this.model.skeletonTracing, "emptyBranchStack", function() {
	      return Toast.error("No more branchpoints", false);
	    });
	    this.listenTo(this.model.skeletonTracing, "noBranchPoints", function() {
	      return Toast.error("Setting branchpoints isn't necessary in this tracing mode.", false);
	    });
	    this.listenTo(this.model.skeletonTracing, "wrongDirection", function() {
	      return Toast.error("You're tracing in the wrong direction");
	    });
	    autoSaveFailureMessage = "Auto-Save failed!";
	    this.listenTo(this.model.skeletonTracing.stateLogger, "pushFailed", function() {
	      if (this.reloadDenied) {
	        return Toast.error(autoSaveFailureMessage, true);
	      } else {
	        return modal.show("Several attempts to reach our server have failed. You should reload the page to make sure that your work won't be lost.", "Connection error", [
	          {
	            id: "reload-button",
	            label: "OK, reload",
	            callback: function() {
	              app.router.off("beforeunload");
	              return app.router.reload();
	            }
	          }, {
	            id: "cancel-button",
	            label: "Cancel",
	            callback: (function(_this) {
	              return function() {
	                return _this.reloadDenied = true;
	              };
	            })(this)
	          }
	        ]);
	      }
	    });
	    this.listenTo(this.model.skeletonTracing.stateLogger, "pushDone", function() {
	      return Toast["delete"]("danger", autoSaveFailureMessage);
	    });
	  }
	
	  SkeletonTracingView.prototype.showFirstVisToggle = function() {
	    return modal.show("You just toggled the skeleton visibility. To toggle back, just hit the 1-Key.", "Skeleton visibility", [
	      {
	        id: "ok-button",
	        label: "OK, Got it."
	      }
	    ]);
	  };
	
	  return SkeletonTracingView;
	
	})(View);
	
	module.exports = SkeletonTracingView;


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	var $, View, VolumeTracingView,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	$ = __webpack_require__(1);
	
	View = __webpack_require__(306);
	
	VolumeTracingView = (function(superClass) {
	  extend(VolumeTracingView, superClass);
	
	  function VolumeTracingView(model) {
	    this.model = model;
	    VolumeTracingView.__super__.constructor.call(this, this.model);
	    $(".skeleton-controls").hide();
	    $(".skeleton-plane-controls").hide();
	    $(".skeleton-arbitrary-controls").hide();
	  }
	
	  return VolumeTracingView;
	
	})(View);
	
	module.exports = VolumeTracingView;


/***/ }
]));
//# sourceMappingURL=1.1.js.map